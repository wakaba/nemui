<!DOCTYPE HTML>
<meta charset=utf-8>
<title></title>
<link rel=stylesheet href=https://raw.githack.com/pawjy/html-page-components/master/css/default.css>

<style>
  html, body {
      margin: 0;
      padding: 0;
  }

  .phase-list canvas {
   display: block;
      width: fit-content;
      border: 1px solid blue;
  }

  c-panel {
      display: grid;
      grid-template: "in out";
      height: 100vh;
  }
  c-panel > c-box {
      display: block;
      overflow: auto;
      height: 100vh;
  }
  c-panel > c-box:first-child {
      grid-area: in;
  }
  c-panel > c-box:last-child {
      grid-area: out;
  }

  c-phase {
      display: block;
  }
  c-phase > p {
      grid-area: prop;
      margin: 0;
  }
  c-phase > ul {
      grid-area: list;
      margin: 0;
      margin-inline-start: 1em;
      padding: 0;
      max-height: 100vh;
      overflow: auto;
  }
  c-phase > ul > li {
      display: block;
      margin: 0;
      padding: 0;
  }
  c-phase strong {
      cursor: pointer;
  }

  can-copy {
    display: block;
  }

  .linked { color: red }
  .base { color: black; cursor: pointer }
  .data { color: green; cursor: pointer }
  .ignored { opacity: 0.5 }

  .team-list {
    display: block;
    margin: 0;
    padding: 0;
  }
  .team-list > li {
    display: inline-block;
    margin: 0;
    padding: 0;
  }

  unit-number {
    color: gray;
    font-size: 80%;
  }

  status-box.ok { color: green }
  status-box.ng { background: red; color: white }

  .error {
    border: red 1px solid;
  }

</style>

<c-panel>

<c-box>
  <map-area gsi controls></map-area>

<form action=javascript:>
<nav>
  <label><input type=radio name=mode value=0> base</label>
  <a href target=_blank class=base-link><unit-number type=duration class=base-elapsed></unit-number></a>
  <label class=data><input type=radio name=mode value=1 checked> data</label>
  <a href target=_blank class=data-link><unit-number type=duration class=data-elapsed></unit-number></a>
  <button type=button is=select-gpx>GPX</button>
  <input type=url name=url placeholder=https://ibuki.run/ev/{}/ list=urls>
  <button type=button is=fetch-ibuki>IBUKI</button>
  <label><var>r</var> = <input type=number name=radius value=300></label>
  <button type=button class=all-button>All</button>
</nav>
  <datalist id=urls>
    <option value=https://ibuki.run/ev/8963707529176734833/>
    <option value=https://ibuki.run/ev/8963707529176734833/t/830/>
    <option value=https://ibuki.run/ev/8963798851961188547/>
    <option value=https://ibuki.run/a/log/8963798851961229137/>
    <option value=https://ibuki.run/c/8963250946391261698/>
    <option value=https://ibuki.run/a/log/8960902124485476562/>
  </datalist>
  <ul class=team-list></ul>
</form>

</c-box>

<c-box>

  <section class=phase-list></section>

</c-box>

</c-panel>

<script>

  function init () {
    let map = document.querySelector ('map-area');
    let phaseView = document.querySelector ('.phase-list');
    let teamList = document.querySelector ('.team-list');

    let pointsList = [];
    let mode = 1;
    pointsList[0] = [];
    pointsList[1] = [];
    pointsList[2] = [];

    let inputParams = {};
    let teamIds = new Set;

    document.querySelectorAll ('input[name=mode]').forEach (input => {
      input.onchange = () => {
        if (input.checked) mode = input.value;
      };
    });

    let pageURL = new URL (location);
    let radius;
    document.querySelectorAll ('input[name=radius]').forEach (input => {
      radius = input.valueAsNumber || 100;
      input.onchange = () => {
        radius = input.valueAsNumber || 100;
        pageURL.searchParams.set ('r', radius);
        inputParams.radius = radius;
        rerun ({});
        history.replaceState (null, null, pageURL);
      };
    });
    {
      let v = pageURL.searchParams.get ('r');
      if (v) {
        document.querySelector ('input[name=radius]').value = v;
        radius = parseFloat (v) || 100;
      }
    }
    inputParams.radius = radius;

    document.querySelectorAll ('button[is=select-gpx]').forEach (b => {
      b.onclick = () => {
        new Promise ((resolve, reject) => {
          b.xCancel = reject;
          var fileInput = document.createElement ('input');
          fileInput.type = 'file';
          fileInput.accept = '.gpx';
          fileInput.multiple = true;
          fileInput.onchange = () => {
            resolve (fileInput.files);
            b.xCancel = null;
            fileInput.remove ();
          };
          fileInput.hidden = true;
          document.body.appendChild (fileInput);
          fileInput.click ();
        }).then ((files) => {
          let file = files[0];
          return new Promise ((resolve, reject) => {
            var reader = new FileReader;
            reader.onload = () => resolve (reader.result);
            reader.onerror = () => reject (reader.error);
            reader.readAsText (file);
          });
        }).then (parseGPX).then (points => {
          pointsList[mode] = points;
          delete inputParams["url" + mode];
          inputParams["key" + mode] = Math.random ();
          window.scrolled = false;
          rerun ({});
        });
      };
    });

    let openURL = (mode, u) => {
      return fetchIbuki (u).then (ib => {
          pointsList[mode] = ib.routePoints;
          if (mode == 0) inputParams.markedPoints = ib.markedPoints;
          if (mode == 1) pointsList[2] = ib.forcedPoints;
          if (mode == 1) {
            teamIds = ib.teamIds;
            inputParams.teamListURL = ib.teamListURL;
          }
          if (mode == 1) inputParams.teamResultItems = ib.teamResultItems;
          pageURL.searchParams.set ('url' + mode, u);
          inputParams["url" + mode] = u.replace (/^https:\/\/ibuki.run\//, '/');
          inputParams["key" + mode] = Math.random ();
          window.scrolled = false;
          rerun ({fetchElapsed: ib.elapsed});
          let opt = document.createElement ('option');
          opt.value = u;
          document.querySelector ('#urls').appendChild (opt);
        if (mode == 0) {
          document.querySelector ('.base-link').href = new URL (inputParams.url0, 'https://ibuki.run/');
        } else if (mode == 1) {
          document.querySelector ('.data-link').href = new URL (inputParams.url1, new URL (inputParams.url0, 'https://ibuki.run/'));
        }
        history.replaceState (null, null, pageURL);
      });
    }; // openURL

    document.querySelectorAll ('button[is=fetch-ibuki]').forEach (b => {
      b.onclick = () => {
        let u = document.forms[0].elements.url.value;
        openURL (mode, u).catch (e => {
          console.log (e);
          alert (e);
        });
      };
    });
    [0, 1].forEach (_ => {
      let u = pageURL.searchParams.get ('url' + _);
      if (u) {
        openURL (_, u).catch (e => {
          console.log (e);
          alert (e);
        });
      }
    });
    let clickTeamButton = button => {
      let tid = button.value;
      if (tid == null) return;
      let u = new URL ('t/' + tid + '/', new URL (inputParams.url0, 'https://ibuki.run/'));
      let statusBox = button.nextElementSibling;
      if (!statusBox || statusBox.localName !== 'status-box') {
        statusBox = document.createElement ('status-box');
        button.parentNode.insertBefore (statusBox, button.nextSibling);
      }
      inputParams.statusBox = statusBox;
      button.classList.add ('clicked');
      return openURL (1, u + '');
    }; // clickTeamButton
    teamList.onclick = (ev) => clickTeamButton (ev.target).catch (e => {
      console.log (e);
      alert (e);
    });

    let lastComputed;
    let lastComputedKey = Math.random ();
    let rerun = (opts) => {
      let computed = {elapsed: {}};
      if (lastComputedKey === inputParams.key0) {
        computed = lastComputed;
      } else {
        computeBase (pointsList, radius, computed);
        lastComputed = computed;
        lastComputedKey = inputParams.key0;
      }
      computeData (pointsList, computed);
      computeDataPointTimes (pointsList, inputParams.markedPoints || [], computed);

      computed._mps = inputParams.markedPoints;
      if (opts.fetchElapsed) computed.elapsed.fetch = opts.fetchElapsed;
      redraw ({map, phaseView, pointsList, teamList,
               computed, inputParams, teamIds,
               baseElapsedView: document.querySelector ('.base-elapsed'),
               dataElapsedView: document.querySelector ('.data-elapsed')});
      console.log (computed);
    }; // rerun

    document.querySelector ('.all-button').onclick = async () => {
      while (true) {
        let button = teamList.querySelector ('button:not(.clicked)');
        if (button) {
          await clickTeamButton (button);
        } else {
          break;
        }
      }
    };

    rerun ({});
  }
  setTimeout (() => init (), 1000);


</script>
<script src=https://raw.githack.com/pawjy/html-page-components/master/src/page-components.js async></script>
<script src=https://raw.githack.com/pawjy/html-page-components/master/src/maps.js async></script>
<script src=https://raw.githack.com/wakaba/js-gpx-parser/master/gpx-parser.js async></script>
<script src=https://raw.githack.com/wakaba/js-geo-encodedpolyline/master/encodedpolyline.js async></script>
<script src=https://raw.githack.com/wakaba/html-unit-number/master/src/unit-number.js async></script>
<script>
  
function MapOverlay (opts) {
  var bgContainer = this.bgContainer = document.createElement ('map-overlay');
  bgContainer.setAttribute ('type', 'background');
  let baseContainer = this.baseContainer = document.createElement ('map-overlay');
  baseContainer.setAttribute ('type', 'overlay');
  let hisContainer = this.historyContainer
      = document.createElement ('map-overlay');
  hisContainer.setAttribute ('type', 'history');
  let locContainer = this.locationContainer
      = document.createElement ('map-overlay');
  locContainer.setAttribute ('type', 'location');
  var overlayContainer = this.overlayContainer = document.createElement ('map-overlay');
  overlayContainer.setAttribute ('type', 'editing');
  var tooltipContainer = this.tooltipContainer = document.createElement ('map-overlay');
  tooltipContainer.setAttribute ('type', 'tooltip');

  overlayContainer.addEventListener ('contextmenu', ev => ev.preventDefault ());

  let foreground = document.createElement ('div');
  foreground.appendChild (baseContainer);
  foreground.appendChild (hisContainer);
  foreground.appendChild (locContainer);

  var elements = {
    background: bgContainer,
    foreground,
    tooltip: tooltipContainer,
    interactive: overlayContainer,
  };
  this.map = opts.map;
  var obj = this.map.addElementOverlays (elements, opts.redraw);
  this.mapReadyToDraw = () => obj.ready ();
  this.mapGetProjection = () => obj.getProjection ();
  this.mapMakeClickable = (e) => obj.clickable (e);
} // MapOverlay

MapOverlay.prototype.mapInitOverlayContainer = function (container) {
  var projection = this.mapGetProjection ();
  var mapBounds = this.map.getMapBounds ();
  var nwPoint = {lat: mapBounds.north, lon: mapBounds.west};
  var sePoint = {lat: mapBounds.south, lon: mapBounds.east};
  var nw = projection.divPoint (nwPoint);
  var se = projection.divPoint (sePoint);

  var cc = (ll) => {
    var p = projection.divPoint (ll);
    return {x: p.x - nw.x, y: p.y - nw.y};
  }; // cc

  var nm = 16;
  var width = se.x - nw.x || 1;
  var height = se.y - nw.y || 1;
  var canvas = container.querySelector ('map-overlay-container');
  if (!canvas) {
    canvas = document.createElement ('map-overlay-container');
    container.appendChild (canvas);
  }
  canvas.style.display = 'block';
  canvas.style.position = "absolute";
  canvas.style.top = nw.y + "px";
  canvas.style.left = nw.x + "px";
  canvas.style.height = height + "px";
  canvas.style.width = width + "px";
  canvas.width = width;
  canvas.height = height;

  return {
    getCanvasPoint: cc,
    container: canvas,
  };
}; // mapInitOverlayContainer

MapOverlay.prototype.mapInitCanvas = function (container) {
  var projection = this.mapGetProjection ();
  var mapBounds = this.map.getMapBounds ();
  var nwPoint = {lat: mapBounds.north, lon: mapBounds.west};
  var sePoint = {lat: mapBounds.south, lon: mapBounds.east};
  var nw = projection.divPoint (nwPoint);
  var se = projection.divPoint (sePoint);

  var cc = (ll) => {
    var p = projection.divPoint (ll);
    return {x: p.x - nw.x, y: p.y - nw.y};
  }; // cc
  
  var cp = (ll) => {
    return projection.divPoint (ll);
  }; // cp

  var nm = 16;
  var width = se.x - nw.x || 1;
  var height = se.y - nw.y || 1;
  var canvas = container.querySelector ('canvas');
  if (!canvas) {
    canvas = document.createElement ('canvas');
    container.appendChild (canvas);
  }
  canvas.style.position = "absolute";
  canvas.style.top = nw.y + "px";
  canvas.style.left = nw.x + "px";
  canvas.style.height = height + "px";
  canvas.style.width = width + "px";
  canvas.width = width;
  canvas.height = height;
  canvas.style.webkitUserSelect = 'none';

  this.pxPerDistance = Math.pow (width*width + height*height, 0.5)
                     / (distanceH84 (nwPoint, sePoint) || 1);

  var inRange = (p) => (-nm <= p.x && p.x <= width + nm && -nm <= p.y && p.y <= height + nm);

  var extract = (points, minIndex, maxIndex) => {
    var segments = [];
    if ((!Number.isFinite (minIndex) && !Number.isFinite (maxIndex)) ||
        !(maxIndex - minIndex >= 1)) return segments;

  var segment = [];
  var prevPoint = points[minIndex];
    var currentRT = null;
  for (var i = minIndex+1; i <= maxIndex; i++) {
    var pt = points[i];

    if (!Number.isFinite (pt.prevDistance)) {
      if (currentRT !== null && segment.length > 0) segments.push (segment);
      prevPoint = pt;
      currentRT = null;
      continue;
    }

    var p = cc (pt);

    if (currentRT === null) {
      if (!inRange (p)) {
        if (i === 1 && inRange (cc (prevPoint))) {
          //
        } else {
          prevPoint = pt;
          continue;
        }
      }

      segment = [[prevPoint, cc (prevPoint)]];
    }

      var ptRT = pt.roadtype || pt.computedRoadtype || 0;
      if (currentRT === null || currentRT != ptRT) {
        if (currentRT !== null && segment.length > 0) segments.push (segment);
        if (segment.length) {
          segment = [JSON.parse (JSON.stringify (segment[segment.length-1]))];
          segment[0][0].roadtype = ptRT;
        } else {
          segment = [];
        }
        currentRT = ptRT;
      }

      segment.push ([pt, p]);

      if (!inRange (p)) {
        if (currentRT !== null && segment.length > 0) segments.push (segment);
        prevPoint = pt;
        currentRT = null;
      }
    } // pt
    if (currentRT !== null && segment.length > 0) segments.push (segment);
    
    return segments;
  }; // extract

  var ctx = canvas.getContext ('2d');
  return {
    ctx: ctx,
    getContainerPoint: cp,
    getCanvasPoint: cc,
    inRange,
    extract: extract,
    setShadowStyle: style => {
      var shadow = style.boxShadow;
      if (shadow === 'none') {
        ctx.shadowColor = 'transparent';
      } else {
        var shadowOpts = [];
        shadow = shadow.replace (/^[^\()]+\([^()]+\)\s+/, _ => {
          shadowOpts.push (_);
          return '';
        });
        shadowOpts = shadowOpts.concat (shadow.split (/\s+/));
        ctx.shadowColor = shadowOpts[0];
        ctx.shadowOffsetX = parseFloat (shadowOpts[1]);
        ctx.shadowOffsetY = parseFloat (shadowOpts[2]);
        ctx.shadowBlur = parseFloat (shadowOpts[3]);
      }
    }, // setShadowStyle
  };
}; // mapInitCanvas

MapOverlay.prototype.mapGetPointOffset = function (point, opts) {
  if (!this.mapReadyToDraw ()) throw new Error ("The map is not ready");

  var projection = this.mapGetProjection ();

  var p = projection.containerPoint (point);
  var result = {x: p.x, y: p.y};

  if (opts && opts.debugLabel) {
    var m = document.createElement ('div');
    m.style.position = 'absolute';
    m.style.left = result.x + 'px';
    m.style.top = result.y + 'px';
    m.style.border = '1px red solid';
    m.style.pointerEvents = 'none';
    m.textContent = opts.debugLabel;
    this.map.appendChild (m);
  }

  return result;
}; // mapGetPointOffset

MapOverlay.prototype.mapGetPixelDistance = function (p1, p2) {
  var distance = distanceH84 (p1, p2);
  return this.pxPerDistance * distance;
}; // mapGetPixelDistance

function redraw ({map, phaseView, pointsList, teamList,
                  inputParams, computed, teamIds,
                  baseElapsedView, dataElapsedView}) {
    let start = performance.now ();

    let overlay = window.overlay = window.overlay || new MapOverlay ({
      map,
      redraw: () => overlay.redraw (),
    });

    overlay.redraw = () => {
      overlay.bgContainer.textContent = '';
      var dc = overlay.mapInitCanvas (overlay.bgContainer);
      var ctx = dc.ctx;

        let drawPolyline = (ctx, pts, color, width) => {
          ctx.beginPath ();
          ctx.moveTo (pts[0][1].x, pts[0][1].y);
          pts.forEach ((_) => ctx.lineTo (_[1].x, _[1].y));
          ctx.strokeStyle = color;
          ctx.lineWidth = width;
          ctx.stroke ();
        };
        let drawCircle = (ctx, pt, rPx, color1, color2) => {
          ctx.beginPath ();
          ctx.arc (pt[1].x, pt[1].y, rPx, 0, 2 * Math.PI);
          if (pt[0].additional) {
            ctx.strokeStyle = color2;
          } else {
            ctx.strokeStyle = color1;
          }
          ctx.lineWidth = 1;
          ctx.stroke ();
        };
        let drawEnclose = (ctx, point, color) => {
          ctx.beginPath ();
          ctx.arc (point.x, point.y, 8, 0, 2 * Math.PI);
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.stroke ();
        };
        let drawPoint = (ctx, pt, color) => {
          ctx.beginPath ();
          ctx.arc (pt[1].x, pt[1].y, 5, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill ();
        };
        let drawWhitePoint = (ctx, pt, color) => {
          ctx.beginPath ();
          ctx.arc (pt[1].x, pt[1].y, 5, 0, 2 * Math.PI);
          ctx.strokeStyle = color;
          ctx.stroke ();
        };
        let drawLine = (ctx, pc, qc, color) => {
          ctx.beginPath ();
          ctx.moveTo (qc.x, qc.y);
          ctx.lineTo (pc.x, pc.y);
          ctx.strokeStyle = color;
          ctx.stroke ();
        };
      let drawText = (ctx, pt, color, text) => {
        ctx.beginPath ();
        ctx.fillStyle = color;
        ctx.fillText (text, pt[1].x + 16, pt[1].y);
      };

        {
          let delta = Math.pow (computed.threshold, 0.5);
          let s = (computed.basePoints.length ? distanceH84 (
            {lat: computed.basePoints[0].lat,
             lon: computed.basePoints[0].lon},
            {lat: computed.basePoints[0].lat + delta,
             lon: computed.basePoints[0].lon},
          ) : 0);
          let r = s * overlay.pxPerDistance;
          computed.thresholdM = s;
          computed.thresholdPx = r;
        }
        {
          let delta = Math.pow (computed.thresholdC, 0.5);
          let s = (computed.basePoints.length ? distanceH84 (
            {lat: computed.basePoints[0].lat,
             lon: computed.basePoints[0].lon},
            {lat: computed.basePoints[0].lat + delta,
             lon: computed.basePoints[0].lon},
          ) : 0);
          let r = s * overlay.pxPerDistance;
          computed.thresholdCPx = r;
        }
        
        if (computed.basePoints.length) {
          let segs = dc.extract
              (computed.basePoints, 0, computed.basePoints.length-1);
          segs.forEach ((segment) => {
            drawPolyline (ctx, segment, 'orange', 5);
          });
          segs.forEach ((segment) => {
            segment.forEach (point => {
              if (computed.useThresholdC[point[0].index]) {
                drawCircle (ctx, point, computed.thresholdCPx, 'blue');
              }
              drawCircle (ctx, point, computed.thresholdPx, '#888', '#ccc');
              drawPoint (ctx, point, 'gray');
              drawText (ctx, point, 'black', point[0].index + (point[0].origIndex != null ? ' {'+point[0].origIndex+'}' : ''));
            });
          });
        } // basePoints

        computed.omittedPoints.forEach (p => {
          let cp = dc.getCanvasPoint (p);
          if (dc.inRange (cp)) {
            drawWhitePoint (ctx, [p, cp], 'gray');
            drawText (ctx, [p, cp], 'gray', '{'+p.origIndex+'}');
          }
        }); // omittedPoints
        
        if (computed.dataPoints.length) {
          let segs = dc.extract
              (computed.dataPoints, 0, computed.dataPoints.length-1);
          segs.forEach ((segment) => {
            drawPolyline (ctx, segment, 'rgba(0, 255, 0, 0.6)', 5);
          });
          segs.forEach ((segment) => {
            segment.forEach (point => {
              drawCircle (ctx, point, computed.thresholdPx,
                          'rgba(0, 255, 0, 0.3)', '#eee');
              drawPoint (ctx, point, 'green');
              drawText (ctx, point, 'green', point[0].index + (point[0].origIndex != null ? ' {'+point[0].origIndex+'}' : ''));
            });
          });
        } // dataPoints

        for (let i in computed.dataToBase) {
          let link = computed.dataToBase[i];
          if (link) {
            let p = computed.basePoints[link.nearestIndex];
            let q = computed.dataPoints[i];
            let pc = dc.getCanvasPoint (p);
            let qc = dc.getCanvasPoint (q);
            if (dc.inRange (pc) || dc.inRange (qc)) {
              drawLine (ctx, pc, qc, 'rgba(255, 0, 0, 0.3)');
            }
            if (link.effectiveIndex != null) {
              let r = computed.basePoints[link.effectiveIndex];
              let rc = dc.getCanvasPoint (r);
              if (dc.inRange (pc) || dc.inRange (qc) || dc.inRange (rc)) {
                drawLine (ctx, qc, rc, 'red');
                drawEnclose (ctx, qc, 'red');
                drawEnclose (ctx, rc, 'red');
              }
            }
          }
        }
        

    }; // redraw
    
    let showPhase = ph => {
      let pp = [];
      for (let i = ph[0]; i <= ph[1]; i++) {
        pp.push (computed.basePoints[i]);
      }
      let bb = bounds (pp);
      map.pcScroll ({bounds: bb});
    };

    let showBasePoint = i => {
      let p = computed.basePoints[i];
      map.pcScroll ({center: p});
    };

    let showDataPoint = j => {
      let p = computed.dataPoints[j];
      map.pcScroll ({center: p});
    };

    computed.omittedPoints = [];
    pointsList[0].forEach (p => {
      if (p.index == null) {
        computed.omittedPoints.push (p);
      }
    });
    console.log ("orig", pointsList, "omitted", computed.omittedPoints);

    let pp = null;
    computed.basePoints.forEach (p => {
      if (pp) {
        p.prevDistance = distanceH84 (pp, p);
      }
      pp = p;
    });
    pp = null;
    computed.dataPoints.forEach (p => {
      if (pp) {
        p.prevDistance = distanceH84 (pp, p);
      }
      pp = p;
    });

    if (!window.scrolled) {
      window.scrolled = true;
      let bb = bounds (computed.basePoints);
      map.pcScroll ({bounds: bb});
    }
    overlay.redraw ();
    
    phaseView.textContent = '';
    let phs = [];
    computed.basePhases.forEach (ph => {
      let item = document.createElement ('c-phase');
      phaseView.appendChild (item);

      let el = document.createElement ('p');
      let nears = computed.baseNears[ph[0]];
      nears.forEach (near => {
        if (near[1] === ph[0]) {
          let x = document.createElement ('strong');
          x.textContent = ph[0] + '-' + ph[1];
          el.appendChild (x);
          x.onclick = () => {
            showPhase (ph);
          };

          el.appendChild (document.createTextNode (' ['+ph.index+']'));
        } else {
          let x = document.createElement ('span');
          x.textContent = near[0] + '-...';
          el.appendChild (x);
        }
        el.appendChild (document.createTextNode (' '));
      });
      item.appendChild (el);

      let list = document.createElement ('ul');
      item.appendChild (list);
      phs.push ([ph, list]);
    });
    {
      let j = 0;
      for (let [ph, list] of phs) {
        let pp = [];
        while (j < computed.dataPoints.length && 
               (!computed.dataToBase[j] ||
                computed.dataToBase[j].effectiveIndex == null ||
                (ph[0] <= computed.dataToBase[j].effectiveIndex &&
                 computed.dataToBase[j].effectiveIndex <= ph[1]))) {
          let link = computed.dataToBase[j];
          let li = document.createElement ('li');
          list.appendChild (li);

          (j => {
            li.ondblclick = () => {
              let expected = {};
              if (link && link.effectiveIndex != null) {
                let i1 = link.effectiveIndex;
                while (i1 >= 0 && computed.basePoints[i1].additional) i1--;
                let i2 = link.effectiveIndex;
                while (i2 < computed.basePoints.length && computed.basePoints[i2].additional) i2++;
                expected.basePoint = [computed.basePoints[i1].origIndex,
                                      computed.basePoints[i2].origIndex];
              }
              expected.dataPoint = computed.dataPoints[j].origIndex;
              if (expected.dataPoint == null) {
                expected.dataPointSource = computed.dataPoints[j].source;
              }
              expected.in = {};
              expected.in.url0 = inputParams.url0;
              expected.in.url1 = inputParams.url1;
              expected.in.radius = inputParams.radius;
              if (expected.in.url0 && expected.in.url1 &&
                  expected.in.url1.startsWith (expected.in.url0)) {
                expected.in.url1 = expected.in.url1.substring (expected.in.url0.length);
              }
              let cc = document.createElement ('can-copy');
              let code = document.createElement ('code');
              code.textContent = JSON.stringify (expected) + ",";
              cc.appendChild (code);
              li.appendChild (cc);
            };

            let s = document.createElement ('span');
            s.className = 'data';
            s.textContent = j;
            s.onclick = () => {
              showDataPoint (j);
            };
            li.appendChild (s);
            li.appendChild (document.createTextNode (' '));
            let t = document.createElement ('span');
            t.className = 'linked';
            t.textContent = '~';
            li.appendChild (t);
            li.appendChild (document.createTextNode (' '));
          }) (j);
          if (!link) {
            let s = document.createElement ('span');
            s.innerHTML = '()';
            li.appendChild (s);
            li.className = 'ignored';
          } else if (link.effectiveIndex != null) {
            let point = computed.dataPoints[j];
            pp.push (point);

            {
              let s = document.createElement ('span');
              s.className = 'base';
              s.onclick = () => {
                showBasePoint (link.effectiveIndex);
              };
              s.textContent = link.effectiveIndex;
              li.appendChild (s);
            }

            {
              let s = document.createElement ('span');
              s.innerHTML = ' ['+link.phase+']';
              li.appendChild (s);
            }
            if (link.effectiveIndex === link.nearestIndex) {
              //
            } else {
              li.appendChild (document.createTextNode (' <- '));
              {
                let s = document.createElement ('span');
                s.className = 'base';
                s.textContent = link.nearestIndex;
                s.onclick = () => {
                  showBasePoint (link.nearestIndex);
                };
                li.appendChild (s);
              }
            }
          } else {
            li.appendChild (document.createTextNode ('('));
            if (link.unusedIndex != null &&
                link.unusedIndex !== link.nearestIndex) {
              let s = document.createElement ('span');
              s.className = 'base';
              s.textContent = link.unusedIndex;
              s.onclick = () => {
                showBasePoint (link.unusedIndex);
              };
              li.appendChild (s);
              li.appendChild (document.createTextNode (' <- '));
            }
            let s = document.createElement ('span');
            s.className = 'base';
            s.textContent = link.nearestIndex;
            s.onclick = () => {
              showBasePoint (link.nearestIndex);
            };
            li.appendChild (s);
            li.appendChild (document.createTextNode (')'));
            li.className = 'ignored';
          }

          j++;
        }

        
      }
    }
    {
      let item = document.createElement ('c-phase');
      phaseView.appendChild (item);

      let ul = document.createElement ('ul');
      item.appendChild (ul);
      pointsList[2].forEach (p => {
        let li = document.createElement ('li');
        ul.appendChild (li);

        let code = document.createElement ('code');
        code.textContent = p.source;
        li.appendChild (code);
        li.appendChild (document.createTextNode (' '));

        {
          let span = document.createElement ('span');
          span.textContent = p.index;
          span.className = 'data';
          span.onclick = () => {
            showDataPoint (p.index);
          };
          li.appendChild (span);
        }
        li.appendChild (document.createTextNode (' = '));
        {
          let bp = pointsList[0][p.baseOrigIndex];
          let span = document.createElement ('span');
          span.textContent = bp ? bp.index : '-';
          span.className = 'base';
          if (bp) span.onclick = () => {
            showBasePoint (bp.index);
          };
          li.appendChild (span);
        }

      });
    }
    {
      let item = document.createElement ('c-phase');
      phaseView.appendChild (item);

      let count = 0;
      let okCount = 0;
      let ul = document.createElement ('ul');
      item.appendChild (ul);
      let rItems = inputParams.teamResultItems || [];
      (inputParams.markedPoints || []).forEach (mp => {
        let li = document.createElement ('li');
        ul.appendChild (li);

        let code = document.createElement ('code');
        code.textContent = '#' + mp.id;
        li.appendChild (code);
        li.appendChild (document.createTextNode (' '));

        let dp = computed.pointTimes[mp.id] || {};
        if (dp.baseIndex != null) {
          if (dp.dataIndex) {
            {
              let span = document.createElement ('span');
              span.textContent = dp.dataIndex[0];
              span.className = 'data';
              span.onclick = () => {
                showDataPoint (dp.dataIndex[0]);
              };
              li.appendChild (span);
            }
            if (dp.dataIndex[0] !== dp.dataIndex[1]) {
              li.appendChild (document.createTextNode (','));
              let span = document.createElement ('span');
              span.textContent = dp.dataIndex[1];
              span.className = 'data';
              span.onclick = () => {
                showDataPoint (dp.dataIndex[1]);
              };
              li.appendChild (span);
            }
          } else {
            li.appendChild (document.createTextNode ('- '));
          }
          {
            li.appendChild (document.createTextNode (' '));
            let t = document.createElement ('span');
            t.className = 'linked';
            t.textContent = '~';
            li.appendChild (t);
            li.appendChild (document.createTextNode (' '));
          }
          let span = document.createElement ('span');
          span.textContent = dp.baseIndex;
          span.className = 'base';
          span.onclick = () => {
            showBasePoint (dp.baseIndex);
          };
          li.appendChild (span);

          {
            let rItem = rItems.filter (_ => _.p == mp.id)[0] || {};
            let delta = Math.abs (dp.timestamp - rItem.c);

            li.appendChild (document.createTextNode ('; Δ = '));
            let span = document.createElement ('unit-number');
            span.setAttribute ('type', 'duration');
            span.setAttribute ('value', delta);
            span.setAttribute ('data-debug', [dp.timestamp, rItem.c].join (' '));
            li.appendChild (span);

            if (Number.isFinite (delta) && rItem.n &&
                Math.abs (delta) < 60*10) {
              okCount++;
            } else if (!Number.isFinite (delta) && !rItem.n) {
              okCount++;
            } else {
              li.classList.add ('error');
            }
          }
        }
        count++;
      });
      let statusBox = inputParams.statusBox || {};
      statusBox.textContent = Math.floor (okCount / (count || 1) * 100);
      statusBox.className = statusBox.textContent === "100" ? 'ok' : 'ng';
    }

    if (teamList.url !== inputParams.teamListURL) {
      teamList.url = inputParams.teamListURL;
      teamList.textContent = '';
      Array.from (teamIds).sort ((a, b) => a - b).forEach (tid => {
        let li = document.createElement ('li');
        let button = document.createElement ('button');
        button.type = 'button';
        button.value = button.textContent = tid;
        li.appendChild (button);
        teamList.appendChild (li);
      });
    }

    computed.elapsed.redraw = performance.now () - start;
    baseElapsedView.setAttribute ('value', computed.elapsed.base/1000);
    dataElapsedView.setAttribute ('value', computed.elapsed.data/1000);
  } // redraw


</script>
<script src=routes.js async></script>

<!--

Copyright 2019-2024 Wakaba <wakaba@suikawiki.org>.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Affero General Public License for more details.

You does not have received a copy of the GNU Affero General Public
License along with this program, see <https://www.gnu.org/licenses/>.

-->
