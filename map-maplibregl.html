<!DOCTYPE HTML>
<html>
  <meta charset=utf-8>
  <title>Map</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
<link rel=stylesheet href=https://pawjy.github.io/html-unit-number/css/default.css>
<link rel=stylesheet href=https://pawjy.github.io/html-page-components/css/default.css>
<style>
  body {
    margin: 1em;
  }
  p {
    margin: 0;
  }
  .buttons {
    display: flex;
    flex-wrap: wrap;
  }
  map-area {
    height: 40em;
    /*--paco-map-touch-scroll-viewport: none;*/
    /*--paco-map-zoom-animation: none;*/
  }
  map-area[formcontrol] {
    /*--paco-marker-value: circle red 1000m green 2px;*/
  }
  x-1, x-2, x-3, x-4 {
    position: absolute;
    display: block;
    border: 5px solid gray;
    min-width: 10px;
    min-height: 10px;
  }
  x-2 { border-color: blue }
  x-3 { border-color: green }
  x-4 { border-color: red }
</style>
<script src=https://pawjy.github.io/html-page-components/src/page-components.js async></script>
<script src=../html-page-components/src/maps.js onerror='src="https://pawjy.github.io/html-page-components/src/maps.js"' async></script>
<script src=https://wiki.suikawiki.org/scripts/time async data-time-selector=time></script>
<script src=https://pawjy.github.io/html-unit-number/src/unit-number.js async></script>
<script src=https://raw.githack.com/wakaba/js-geo-encodedpolyline/master/encodedpolyline.js></script>

  <section id=map-section-1 lang=ja>
    <map-area engine=maplibre controls="type typebuttons scale fullscreen currentposition zoom streetview togglelegend coordinates pitch" maptype=osm-gsi-hillshade+gsi-optimal_bvmap-label pitch=35 terrain=1.2 gsi jma osm lat=35.2 lon=135.4 zoom=12 formcontrol>
      <map-controls>ABC</map-controls>
      <map-controls position=top-left>XYZ</map-controls>
      <map-controls position=top-left><button>xyz</button></map-controls>
      <map-controls position=top-center>123</map-controls>
      <map-controls position=top-left legend>A legend</map-controls>
      <map-controls position=top-left>Not a legend</map-controls>
    </map-area>

    <script>
  function parseEncodedRoutes (encodedRoutes) {
    let routes = [];
    encodedRoutes.forEach (function (_) {
      var latlon = EncodedPolyline.decode (_.latlon, 2, 1e5);
      var elevation = EncodedPolyline.decode (_.elevation, 1, 1e3);
      var distance = _.distance != null ? EncodedPolyline.decode (_.distance, 1, 1e3) : [];
      delete distance[0];
      var timestamp = _.timestamp != null ? EncodedPolyline.decode (_.timestamp, 1, 1e0) : [];
      var roadtype = _.roadtype != null ? EncodedPolyline.decode (_.roadtype, 1, 1e0) : [];
      var points = [];
      for (var i = 0; i < latlon.length; i++) {
        points.push ({lat: latlon[i][0], lon: latlon[i][1],
                      elevation: elevation[i][0],
                      to_distance: (distance[i] ? distance[i][0] : null),
                      timestamp: (timestamp[i] ? timestamp[i][0] : null),
                      roadtype: (roadtype[i] ? roadtype[i][0] : null)});
      }
      if (points.length) routes.push ({points: points});
    });
    return routes;
  } // parseEncodedRoutes

      async function createMarkerImage(id, options) {
        const {
          width = 64,
          height = 64,
          text = "",
          fontFamily = "sans-serif",
    fontSize = 20,
    fgColor = "#ffffff",
    circleFill = "#ff0000",
    circleStrokeColor = "#000000",
    circleStrokeWidth = 2,
    padding = 6,
    maxFontShrinkIterations = 10
  } = options;

        const dpr = window.devicePixelRatio || 1;

        const canvas = document.createElement("canvas");
        canvas.width = Math.round(width * dpr);
        canvas.height = Math.round(height * dpr);
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;

        const ctx = canvas.getContext("2d");
        ctx.scale(dpr, dpr);

        ctx.clearRect(0, 0, width, height);

        const cx = width / 2;
        const cy = height / 2;

        const maxPossibleRadius = Math.min(width, height) / 2;
        const radius = Math.max(0, maxPossibleRadius - Math.max(circleStrokeWidth / 2, padding));

        if (circleFill) {
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = circleFill;
    ctx.fill();
  }

        if (circleStrokeWidth > 0) {
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.lineWidth = circleStrokeWidth;
          ctx.strokeStyle = circleStrokeColor;
    ctx.stroke();
  }

  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = fgColor;

        ctx.font = `${fontSize}px ${fontFamily}`;
        
        ctx.fillText(text, cx, cy);
        
        return {id, url: canvas.toDataURL("image/png"), width, height};
      }

      async function createTextImageDataURL(id, text, options) {
        const { fontFamily = 'sans-serif', fontSize = 24, color = '#000',
                  strokeColor = 'white',
                  strokeWidth = 1,
                  vertical = false } = options;

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, 'svg');
        const textEl = document.createElementNS(svgNS, 'text');

        if (vertical) {
          textEl.setAttribute('writing-mode', 'vertical-rl');
        }
        
  textEl.setAttribute('x', 0);
  textEl.setAttribute('y', 0);
  textEl.setAttribute('font-family', fontFamily);
        textEl.setAttribute('font-size', fontSize);
        textEl.setAttribute('fill', color);
        textEl.setAttribute('stroke', strokeColor);
        textEl.setAttribute('stroke-width', strokeWidth);
          textEl.setAttribute('paint-order', 'stroke');
  textEl.textContent = text;

        svg.appendChild(textEl);
        document.body.appendChild(svg);

        const bbox = textEl.getBBox();
        svg.setAttribute('width', bbox.width);
        svg.setAttribute('height', bbox.height);
        //  textEl.setAttribute('y', bbox.height * 0.8);
        if (vertical) {
          textEl.setAttribute('writing-mode', 'vertical-rl');
          textEl.setAttribute('dominant-baseline', 'text-after-edge');
          textEl.setAttribute('text-anchor', 'start');
          textEl.setAttribute('x', 0);
        } else {
          textEl.setAttribute('dominant-baseline', 'alphabetic');
          textEl.setAttribute('text-anchor', 'start');
          textEl.setAttribute('y', fontSize);
        }

  const svgData = new XMLSerializer().serializeToString(svg);
          document.body.removeChild(svg);

        return new Promise((resolve) => {
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          return resolve({id, url,width:bbox.width,height:bbox.height});
        });
      }
    </script>

    <script>
      let icons = {};
      async function addTeamIcon (map, team)  {
        let id = 'team-icon-' + team.id;
        if (map.hasImage (id)) return icons[id];

        let x = await createMarkerImage (id, {
          width: 64,
          height: 64,
          text: team.short_label,
          fontFamily: "sans-serif",
          fontSize: 20,
          fgColor: "black",
          circleFill: "white",
          circleStrokeColor: "black",
    circleStrokeWidth: 3,
    padding: 6
        });

        return new Promise ((ok, ng) => {
          let img = document.createElement ('img');
          img.onerror = ng;
          img.onload = () => {
            map.addImage (id, img);
            ok (icons[id] = x);
          };
          img.src = x.url;
        });
      } // addTeamIcon

      async function addMarkedPointIcon (map, mp)  {
        let id = 'markedpoint-icon-' + mp.id;
        if (map.hasImage (id)) return icons[id];

        let x = await createMarkerImage (id, {
          width: 64,
          height: 64,
          text: mp.short_label,
          fontFamily: "sans-serif",
          fontSize: 20,
          fgColor: "white",
          circleFill: "blue",
          circleStrokeColor: "blue",
    circleStrokeWidth: 3,
    padding: 6
        });

        return new Promise ((ok, ng) => {
          let img = document.createElement ('img');
          img.onerror = ng;
          img.onload = () => {
            map.addImage (id, img);
            ok (icons[id] = x);
          };
          img.src = x.url;
        });
      } // addMarkedPointIcon
      async function addMarkedPointLabel (map, mp)  {
        let id = 'markedpoint-label-' + mp.id;
        if (map.hasImage (id)) return icons[id];

        let x = await createTextImageDataURL (id, mp.label, {
          color: 'blue',
          vertical: true
        });

        return new Promise ((ok, ng) => {
          let img = document.createElement ('img');
          img.onerror = ng;
          img.onload = () => {
            map.addImage (id, img);
            ok (icons[id] = x);
          };
          img.src = x.url;
        });
      } // addMarkedPointLabel

      let hasHandlers = {};
      async function showMarkedPoints (map, mps) {
        await Promise.all (mps.map (_ => addMarkedPointIcon (map, _).then (x => _.icon = x)));
        await Promise.all (mps.map (_ => addMarkedPointLabel (map, _).then (x => _.labelImage = x)));

        let data = {
          type: 'FeatureCollection',
          features: [
            ...mps.map ((item, i) => ({
              type: 'Feature',
              geometry: {type: 'Point', coordinates: [item.lon, item.lat]},
              properties: {
                markedPoint: item,
                iconImage: item.icon.id,
                iconImageOffset: [0, - (item.icon.height/2 + 10)],
                labelImage: item.labelImage.id,
                labelImageOffset: [0, - (item.labelImage.height/2 + 2 + item.icon.height + 10)],
              },
            })),
          ],
        };
        let source = map.getSource ('markedpoints');
        if (source) {
          source.setData (data);
        } else {
          map.addSource ('markedpoints', {type: 'geojson', data});
        }

        if (!map.getLayer ('markedpoints')) {
          map.addLayer ({
            id: 'markedpoints',
            source: 'markedpoints',
            type: 'symbol',
            layout: {
              'icon-image': ['get', 'iconImage'],
              'icon-size': 1,
              'icon-allow-overlap': true,
              'icon-offset': ['get', 'iconImageOffset'],
            },
          });
          map.addLayer ({
            id: 'markedpoint-labels',
            source: 'markedpoints',
            type: 'symbol',
            layout: {
              'icon-image': ['get', 'labelImage'],
              'icon-size': 1,
              'icon-allow-overlap': false,
              'icon-offset': ['get', 'labelImageOffset'],
            },
          });
          if (!hasHandlers.markedPointClick) {
            hasHandlers.markedPointClick = true;
            map.on ('click', 'markedpoints', (e) => {
              let feature = e.features[0];
              console.log (feature.properties.markedPoint);
            });
          }
        }
      } // showMarkedPoints

      async function showTeamLocations (map, locs) {
        await Promise.all (locs.map (_ => addTeamIcon (map, _.team).then (x => _.icon = x)));

        let data = {
          type: 'FeatureCollection',
          features: [
            ...locs.map ((item, i) => ({
              type: 'Feature',
              geometry: {type: 'Point', coordinates: [item.lon, item.lat]},
              properties: {
                team: item.team,
                iconImage: item.icon.id,
                iconImageOffset: [0, - (item.icon.height/2 + 10)],
              },
            })),
          ],
        };
        let source = map.getSource ('team-locations');
        if (source) {
          source.setData (data);
        } else {
          map.addSource ('team-locations', {type: 'geojson', data});
        }

        if (!map.getLayer ('team-locations')) {
          map.addLayer ({
            id: 'team-locations',
            source: 'team-locations',
            type: 'symbol',
            layout: {
              'icon-image': ['get', 'iconImage'],
              'icon-size': 1,
              'icon-allow-overlap': true,
              'icon-offset': ['get', 'iconImageffset'],
            },
          });
          if (!hasHandlers.teamClick) {
            hasHandlers.teamClick = true;
            map.on ('click', 'team-locations', (e) => {
              let feature = e.features[0];
              console.log (feature.properties.team);
            });
          }
        }
      } // showTeamLocations

      function showRoutes (map, routes) {
        let data = {
          type: 'FeatureCollection',
          features: [
            ...routes.map (_ => _.points).flat ().map (p => ({
              type: 'Feature',
              geometry: {type: 'Point', coordinates: [p.lon, p.lat]},
              properties: {},
            })),
            ...routes.map (_ => _.points).map (pp => ({
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: pp.map (p => [p.lon, p.lat]),
              },
              properties: {},
            })),
          ],
        };
        let source = map.getSource ('routes');
        if (source) {
          source.setData (data);
        } else {
          map.addSource ('routes', {type: 'geojson', data});
        }

        if (!map.getLayer ('route-points')) {
          map.addLayer ({
            id: 'route-points',
            source: 'routes',
            type: 'circle',
            paint: {
              'circle-radius': 2,
              'circle-color': 'red',
              'circle-stroke-color': '#000000',
              'circle-stroke-width': 1,
            },
            filter: ['==', ['geometry-type'], 'Point']
          });
          map.addLayer({
            id: 'route-lines',
            source: 'routes',
            type: 'line',
            paint: {
              'line-color': 'green',
              'line-width': 2,
            },
            filter: ['==', ['geometry-type'], 'LineString']
          });
        }
      } // showRoutes
      
      function showIbukiEvent (url, opts) {
        let ma = document.querySelector ('map-area');
        let map = ma.pc_MLMap;
        if (!map) return false;
        
        url = url.replace (/^https?:\/\/ibuki.run\//, 'https://od.ibuki.run/');
        //not return
        Promise.all ([
          fetch (new URL ('info.json?with_routes=1', url)).then (res => {
            if (res.status !== 200) throw res;
            return res.json ();
          }).then (info => {
            showRoutes (map, parseEncodedRoutes (info.encoded_routes));
            showMarkedPoints (map, info.marked_points);
            return info;
          }),
          fetch (new URL ('teams.json', url)).then (res => {
            if (res.status !== 200) throw res;
            return res.json ();
          }),
          fetch (new URL ('teamlocations.json', url)).then (res => {
            if (res.status !== 200) throw res;
            return res.json ();
          }),
        ]).then (([info, teams, locs]) => {
          let teamByDK = {};
          teams.items.forEach (t => {
            teamByDK['tt,,' + t.id] = t;
          });
          let tls = [];
          Object.keys (locs.items).forEach (dk => {
            let loc = locs.items[dk];
            loc.team = teamByDK[dk] || {};
            tls.push (loc);
          });

          showTeamLocations (map, tls);

          if (opts.new) {
            if (tls.length || info.marked_points.length) {
              ma.pcScroll ({
                center: tls[0] || info.marked_points.at (-1),
              });
            }
          }
        });

        return true;
      } // showIbukiEvent
    </script>

    <p class=buttons>
      <button value=gsi-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">standard</button>
      <button value=gsi-english onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">english</button>
      <button value=gsi-english-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">english/standard</button>
      <button value=gsi-lang onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">lang-dependent</button>
      <button value=gsi-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">hillshade</button>
      <button value=gsi-photo onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">photo</button>
      <button value=gsi-standard-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">standard+hillshade</button>
      <button value=gsi-hillshade-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">hillshade+standard</button>
      <button value=gsi-photo-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">photo+standard</button>
      <button value=none onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">none</button>
      <button value=B13/TBB onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (B13/TBB)</button>
      <button value=B03/ALBD onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (B03/ALBD)</button>
      <button value=B08/TBB onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (B08/TBB)</button>
      <button value=REP/ETC onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (REP/ETC)</button>
      <button value=SND/ETC onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (SND/ETC)</button>
      <button value=B13/TBB onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (B13/TBB)</button>
      <button value=B03/ALBD onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (B03/ALBD)</button>
      <button value=B08/TBB onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (B08/TBB)</button>
      <button value=REP/ETC onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (REP/ETC)</button>
      <button value=SND/ETC onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (SND/ETC)</button>
      <button value=jma-umimesh-wind onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">jma-umimesh-wind</button>
      <button value=jma-umimesh-wind+gsi-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">jma-umimesh-wind+gsi-standard</button>
      <button value=osm onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">osm</button>
      <button value=osm-gsi-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">osm-gsi-hillshade</button>
      <button value=osm-gsi-hillshade+gsi-optimal_bvmap-label onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">osm-gsi-hillshade+gsi-optimal_bvmap-label</button>
      <button value=osm-gsi-hillshade+gsi-optimal_bvmap-contour-label onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">osm-gsi-hillshade+gsi-optimal_bvmap-contour-label</button>
      <button value=gsi-optimal_bvmap onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-optimal_bvmap</button>
      <button value=gsi-optimal_bvmap-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-optimal_bvmap-hillshade</button>
      <button value=gsi-optimal_bvmap-nocontour-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-optimal_bvmap-nocontour-hillshade</button>
      <button value=gsi-photo-optimal_bvmap onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-photo-optimal_bvmap</button>
      <button value=gsi-photo-optimal_bvmap-nocontour onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-photo-optimal_bvmap-nocontour</button>
      <button value=gsi-hillshade-optimal_bvmap onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-hillshade-optimal_bvmap</button>
      <button value=gsi-hillshade-optimal_bvmap-nocontour onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-hillshade-optimal_bvmap-nocontour</button>
      <button value=SND/ETC onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-optimal_bvmap:'+this.value);
      ">himawari+gsi-optimal_bvmap (SND/ETC)</button>

      <input id=latlon onfocus=this.select() onchange="
        var [lat, lon] = this.value.split (/,/);
        var m = document.querySelector ('map-area');
        m.setAttribute ('lat', lat);
        m.setAttribute ('lon', lon);
      ">
    <p>
      <output name=bounds></output>
    <p>
      <output name=value></output>
    <script>
    (() => {
      var testRenderCount = 0;
      var s = document.querySelector ('#map-section-1');
      s.querySelector ('map-area').addEventListener ('pcRedraw', (ev) => {
        var o = s.querySelector ('output[name=bounds]');
        var b = ev.target.getMapBounds ();
        let zoom = ev.target.pcZoomLevel;
        if (b) o.textContent = [b.north, b.east, b.south, b.west, zoom,
                                ev.target.pc_Bearing,
                                ev.target.pc_Pitch].join (' ');

        var c = ev.target.getMapCenter ();
        document.querySelector ('#latlon').value = c.lat + ',' + c.lon;
        
        var n = ++testRenderCount;
        ev.target.setMouseHandlers ({
          mousedown: obj => {
            console.log (n, "mousedown", obj.getMouseButton (), obj.getPoint ());
          },
          mousemove: obj => {
            //console.log (n, "mousemove", obj.getMouseButton (), obj.getPoint ());
          },
          mouseup: obj => {
            console.log (n, "mouseup", obj.getMouseButton (), obj.getPoint ());
          },
        });
      });
      s.querySelector ('map-area').addEventListener ('change', (ev) => {
        var o = s.querySelector ('output[name=value]');

        var v = ev.target.valueAsLatLon;
        o.textContent = [v.lat, v.lon, null];

        console.pcMaps.getElevation (v.lat, v.lon).then (elevation => {
          o.textContent = [v.lat, v.lon, elevation];
        });
      });
    }) ();
    </script>
    <p>
      <button type=button onclick="
        parentNode.parentNode.querySelector ('map-area').noMapDraggable = false;
      ">Draggable</button>
      <button type=button onclick="
        parentNode.parentNode.querySelector ('map-area').noMapDraggable = true;
      ">Non-draggable</button>
      <button type=button onclick="
        var map = document.querySelector ('map-area');
        var e1 = document.createElement ('x-1');
        var e2 = document.createElement ('x-2');
        var e3 = document.createElement ('x-3');
        var e4 = document.createElement ('x-4');
        var pp = map.addElementOverlays ({
          background: e1, foreground: e2, tooltip: e3, interactive: e4,
        }, () => {
          var center = map.getMapCenter ();
          var p1 = pp.getProjection ().divPoint (center);
          e1.style.left = p1.x + 'px';
          e1.style.top = p1.y + 'px';
          
          e2.style.left = p1.x + 100 + 'px';
          e2.style.top = p1.y + 'px';
          
          e3.style.left = p1.x + 'px';
          e3.style.top = p1.y + 100 + 'px';
          
          e4.style.left = p1.x + 100 + 'px';
          e4.style.top = p1.y + 100 + 'px';
        });
      ">addElementOverlays</button>

    <p>
      <input-datetime oninput="
        var map = document.querySelector ('map-area');
        map.explicitTime = querySelector ('input[type=checkbox]').checked ? this.value : null;
      ">
        <input type=checkbox>
        <input type=date>
        <input type=time>
      </input-datetime>

      <input type=range min=0 value=1.2 max=5 step=0.1 oninput="
        var map = document.querySelector ('map-area');
        map.setAttribute ('terrain', this.value);
      ">

    <p>
      <input type=url name=ibukiURL onchange="
        setURL (value, {initiator: 'input'});
      " style="width: 100%">
    <script>
      let ibukiURL = null;
      let newRequest = true;
      {
        let sp = new URLSearchParams (location.hash.replace (/^#/, ''));
        let ib = sp.get ('ibuki');
        if (ib) setURL (ib, {initiator: 'hash'});
        let mt = sp.get ('map');
        if (mt) document.querySelector ('map-area').setAttribute ('maptype', mt);
      }

      document.querySelector ('map-area').addEventListener ('pcMapTypeChange', () => {
        if (ibukiURL) {
          showIbukiEvent (ibukiURL, {new: newRequest});
          newRequest = false;
          updateURL ();
        }
      });

      function setURL (u, opts) {
        if (/\/ev\/[0-9]+\//.test (u)) {
          ibukiURL = u;
          newRequest = true;
          if (showIbukiEvent (ibukiURL, {new: newRequest})) {
            newRequest = false;
          }
          if (opts.initiator !== 'hash') updateURL ();
          if (opts.initiator !== 'input') document.querySelectorAll ('input[name=ibukiURL]').forEach (_ => _.value = ibukiURL);
        } else {
          throw new Error ("Bad URL: " + u);
        }
      } // setURL

      function updateURL () {
        let mt = document.querySelector ('map-area').pcMapType;
        history.replaceState (null, null, '#ibuki=' + encodeURIComponent (ibukiURL) + '&map=' + mt);
      }
    </script>
      
    <hr style="margin-top: 10em">

    <form>
      <input type=number name=lat value=0 step=0.0001>
      <input type=number name=lon value=0 step=0.0001>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          center: {lat: form.elements.lat.value,
                   lon: form.elements.lon.value},
        });
      ">setCenter</button>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          center: {lat: form.elements.lat.value,
                   lon: form.elements.lon.value},
          setValue: true,
        });
      ">setCenter + setValue</button>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          center: {lat: form.elements.lat.value,
                   lon: form.elements.lon.value},
          intoView: true,
        });
      ">setCenter + scrollIntoView</button>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          center: {lat: form.elements.lat.value,
                   lon: form.elements.lon.value},
          intoView: true,
          ifNeeded: true,
        });
      ">setCenter + scrollIntoViewIfNeeded</button>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          bounds: {north: form.elements.lat.valueAsNumber,
                   west: form.elements.lon.valueAsNumber,
                   south: form.elements.lat.valueAsNumber + 1,
                   east: form.elements.lon.valueAsNumber + 1,
                   },
        });
      ">setBounds</button>
    </form>

    <hr style="margin-top: 10em">

    <p><map-area engine=maplibre gsi controls style="height:28em"></map-area>
    <p><map-area engine=maplibre controls style="height:17em"></map-area>
    <p><map-area engine=maplibre controls=coordinates style="height:17em"></map-area>
  </section>
