<!DOCTYPE HTML>
<html>
  <meta charset=utf-8>
  <title>Map</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
<link rel=stylesheet href=https://pawjy.github.io/html-unit-number/css/default.css>
<link rel=stylesheet href=https://pawjy.github.io/html-page-components/css/default.css>
<style>
  body {
    margin: 1em;
  }
  p {
    margin: 0;
  }
  .buttons {
    display: flex;
    flex-wrap: wrap;
  }
  map-area {
    height: 40em;
    /*--paco-map-touch-scroll-viewport: none;*/
    /*--paco-map-zoom-animation: none;*/
  }
  map-area[formcontrol] {
    /*--paco-marker-value: circle red 1000m green 2px;*/
  }
  x-1, x-2, x-3, x-4 {
    position: absolute;
    display: block;
    border: 5px solid gray;
    min-width: 10px;
    min-height: 10px;
  }
  x-2 { border-color: blue }
  x-3 { border-color: green }
  x-4 { border-color: red }
</style>
<script src=https://pawjy.github.io/html-page-components/src/page-components.js async></script>
<script src=../html-page-components/src/maps.js onerror='src="https://pawjy.github.io/html-page-components/src/maps.js"' async></script>
<script src=https://wiki.suikawiki.org/scripts/time async data-time-selector=time></script>
<script src=https://pawjy.github.io/html-unit-number/src/unit-number.js async></script>
<script src=https://raw.githack.com/wakaba/js-geo-encodedpolyline/master/encodedpolyline.js></script>

  <section id=map-section-1 lang=ja>
    <map-area engine=maplibre controls="type typebuttons scale fullscreen currentposition zoom streetview togglelegend coordinates pitch" maptype=osm-gsi-hillshade+gsi-optimal_bvmap-label pitch=35 terrain=1.2 gsi jma osm lat=35.2 lon=135.4 zoom=12 formcontrol>
      <map-controls>ABC</map-controls>
      <map-controls position=top-left>XYZ</map-controls>
      <map-controls position=top-left><button>xyz</button></map-controls>
      <map-controls position=top-center>123</map-controls>
      <map-controls position=top-left legend>A legend</map-controls>
      <map-controls position=top-left>Not a legend</map-controls>
    </map-area>

    <script>
  function parseEncodedRoutes (encodedRoutes) {
    let routes = [];
    encodedRoutes.forEach (function (_) {
      var latlon = EncodedPolyline.decode (_.latlon, 2, 1e5);
      var elevation = EncodedPolyline.decode (_.elevation, 1, 1e3);
      var distance = _.distance != null ? EncodedPolyline.decode (_.distance, 1, 1e3) : [];
      delete distance[0];
      var timestamp = _.timestamp != null ? EncodedPolyline.decode (_.timestamp, 1, 1e0) : [];
      var roadtype = _.roadtype != null ? EncodedPolyline.decode (_.roadtype, 1, 1e0) : [];
      var points = [];
      for (var i = 0; i < latlon.length; i++) {
        points.push ({lat: latlon[i][0], lon: latlon[i][1],
                      elevation: elevation[i][0],
                      to_distance: (distance[i] ? distance[i][0] : null),
                      timestamp: (timestamp[i] ? timestamp[i][0] : null),
                      roadtype: (roadtype[i] ? roadtype[i][0] : null)});
      }
      if (points.length) routes.push ({points: points});
    });
    return routes;
  } // parseEncodedRoutes

      async function createMarkerImage(id, options) {
        const {
          width = 64,
          height = 64,
          text = "",
          fontFamily = "sans-serif",
    fontSize = 20,
    fgColor = "#ffffff",
    circleFill = "#ff0000",
    circleStrokeColor = "#000000",
    circleStrokeWidth = 2,
    padding = 6,
    maxFontShrinkIterations = 10
  } = options;

        const dpr = window.devicePixelRatio || 1;

        const canvas = document.createElement("canvas");
        canvas.width = Math.round(width * dpr);
        canvas.height = Math.round(height * dpr);
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;

        const ctx = canvas.getContext("2d");
        ctx.scale(dpr, dpr);

        ctx.clearRect(0, 0, width, height);

        const cx = width / 2;
        const cy = height / 2;

        const maxPossibleRadius = Math.min(width, height) / 2;
        const radius = Math.max(0, maxPossibleRadius - Math.max(circleStrokeWidth / 2, padding));

        if (circleFill) {
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = circleFill;
    ctx.fill();
  }

        if (circleStrokeWidth > 0) {
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.lineWidth = circleStrokeWidth;
          ctx.strokeStyle = circleStrokeColor;
    ctx.stroke();
  }

  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = fgColor;

        ctx.font = `${fontSize}px ${fontFamily}`;
        
        ctx.fillText(text, cx, cy);
        
        return {id, url: canvas.toDataURL("image/png"), width, height};
      }

      async function createTextImageDataURL(id, text, options) {
        const { fontFamily = 'sans-serif', fontSize = 24, color = '#000',
                  strokeColor = 'white',
                  strokeWidth = 1,
                  vertical = false } = options;

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, 'svg');
        const textEl = document.createElementNS(svgNS, 'text');

        if (vertical) {
          textEl.setAttribute('writing-mode', 'vertical-rl');
        }
        
  textEl.setAttribute('x', 0);
  textEl.setAttribute('y', 0);
  textEl.setAttribute('font-family', fontFamily);
        textEl.setAttribute('font-size', fontSize);
        textEl.setAttribute('fill', color);
        textEl.setAttribute('stroke', strokeColor);
        textEl.setAttribute('stroke-width', strokeWidth);
          textEl.setAttribute('paint-order', 'stroke');
  textEl.textContent = text;

        svg.appendChild(textEl);
        document.body.appendChild(svg);

        const bbox = textEl.getBBox();
        svg.setAttribute('width', bbox.width);
        svg.setAttribute('height', bbox.height);
        //  textEl.setAttribute('y', bbox.height * 0.8);
        if (vertical) {
          textEl.setAttribute('writing-mode', 'vertical-rl');
          textEl.setAttribute('dominant-baseline', 'text-after-edge');
          textEl.setAttribute('text-anchor', 'start');
          textEl.setAttribute('x', 0);
        } else {
          textEl.setAttribute('dominant-baseline', 'alphabetic');
          textEl.setAttribute('text-anchor', 'start');
          textEl.setAttribute('y', fontSize);
        }

  const svgData = new XMLSerializer().serializeToString(svg);
          document.body.removeChild(svg);

        return new Promise((resolve) => {
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          return resolve({id, url,width:bbox.width,height:bbox.height});
        });
      }
    </script>

    <script>
      let icons = {};
      async function addTeamIcon (map, team)  {
        let id = 'team-icon-' + team.id;
        if (map.hasImage (id)) return icons[id];

        let x = await createMarkerImage (id, {
          width: 64,
          height: 64,
          text: team.short_label,
          fontFamily: "sans-serif",
          fontSize: 20,
          fgColor: "black",
          circleFill: "white",
          circleStrokeColor: "black",
    circleStrokeWidth: 3,
    padding: 6
        });

        return new Promise ((ok, ng) => {
          let img = document.createElement ('img');
          img.onerror = ng;
          img.onload = () => {
            map.addImage (id, img);
            ok (icons[id] = x);
          };
          img.src = x.url;
        });
      } // addTeamIcon

      async function addMarkedPointIcon (map, mp)  {
        let id = 'markedpoint-icon-' + mp.id;
        if (map.hasImage (id)) return icons[id];

        let x = await createMarkerImage (id, {
          width: 64,
          height: 64,
          text: mp.short_label,
          fontFamily: "sans-serif",
          fontSize: 20,
          fgColor: "white",
          circleFill: "blue",
          circleStrokeColor: "blue",
    circleStrokeWidth: 3,
    padding: 6
        });

        return new Promise ((ok, ng) => {
          let img = document.createElement ('img');
          img.onerror = ng;
          img.onload = () => {
            map.addImage (id, img);
            ok (icons[id] = x);
          };
          img.src = x.url;
        });
      } // addMarkedPointIcon
      async function addMarkedPointLabel (map, mp)  {
        let id = 'markedpoint-label-' + mp.id;
        if (map.hasImage (id)) return icons[id];

        let x = await createTextImageDataURL (id, mp.label, {
          color: 'blue',
          vertical: true
        });

        return new Promise ((ok, ng) => {
          let img = document.createElement ('img');
          img.onerror = ng;
          img.onload = () => {
            map.addImage (id, img);
            ok (icons[id] = x);
          };
          img.src = x.url;
        });
      } // addMarkedPointLabel

      let hasHandlers = {};
      async function showMarkedPoints (map, mps) {
        await Promise.all (mps.map (_ => addMarkedPointIcon (map, _).then (x => _.icon = x)));
        await Promise.all (mps.map (_ => addMarkedPointLabel (map, _).then (x => _.labelImage = x)));

        let data = {
          type: 'FeatureCollection',
          features: [
            ...mps.map ((item, i) => ({
              type: 'Feature',
              geometry: {type: 'Point', coordinates: [item.lon, item.lat]},
              properties: {
                markedPoint: item,
                iconImage: item.icon.id,
                iconImageOffset: [0, - (item.icon.height/2 + 10)],
                labelImage: item.labelImage.id,
                labelImageOffset: [0, - (item.labelImage.height/2 + 2 + item.icon.height + 10)],
              },
            })),
          ],
        };
        let source = map.getSource ('markedpoints');
        if (source) {
          source.setData (data);
        } else {
          map.addSource ('markedpoints', {type: 'geojson', data});
        }

        if (!map.getLayer ('markedpoints')) {
          map.addLayer ({
            id: 'markedpoints',
            source: 'markedpoints',
            type: 'symbol',
            layout: {
              'icon-image': ['get', 'iconImage'],
              'icon-size': 1,
              'icon-allow-overlap': true,
              'icon-offset': ['get', 'iconImageOffset'],
            },
          });
          map.addLayer ({
            id: 'markedpoint-labels',
            source: 'markedpoints',
            type: 'symbol',
            layout: {
              'icon-image': ['get', 'labelImage'],
              'icon-size': 1,
              'icon-allow-overlap': false,
              'icon-offset': ['get', 'labelImageOffset'],
            },
          });
          if (!hasHandlers.markedPointClick) {
            hasHandlers.markedPointClick = true;
            map.on ('click', 'markedpoints', (e) => {
              let feature = e.features[0];
              console.log (feature.properties.markedPoint);
            });
          }
        }
      } // showMarkedPoints

      async function showTeamLocations (map, locs, opts) {
        await Promise.all (locs.map (_ => addTeamIcon (map, _.team).then (x => _.icon = x)));

        let data = {
          type: 'FeatureCollection',
          features: [
            ...locs.map ((item, i) => ({
              type: 'Feature',
              geometry: {type: 'Point', coordinates: [item.lon, item.lat]},
              properties: {
                team: item.team,
                iconImage: item.icon.id,
                iconImageOffset: [0, - (item.icon.height/2 + 10)],
              },
            })),
          ],
        };
        let source = map.getSource ('team-locations-' + opts.id);
        if (source) {
          source.setData (data);
        } else {
          map.addSource ('team-locations-' + opts.id, {type: 'geojson', data});
        }

        if (!map.getLayer ('team-locations-' + opts.id)) {
          map.addLayer ({
            id: 'team-locations-' + opts.id,
            source: 'team-locations-' + opts.id,
            type: 'symbol',
            layout: {
              'icon-image': ['get', 'iconImage'],
              'icon-size': 1,
              'icon-allow-overlap': true,
              'icon-offset': ['get', 'iconImageffset'],
            },
          });
          if (!hasHandlers['teamClick-' + opts.id]) {
            hasHandlers['teamClick-' + opts.id] = true;
            map.on ('click', 'team-locations-' + opts.id, (e) => {
              let feature = e.features[0];
              console.log (feature.properties.team);
            });
          }
        }
      } // showTeamLocations

      function showRoutes (map, routes, opts) {
        let data = {
          type: 'FeatureCollection',
          features: [
            ...routes.map (_ => _.points).flat ().map (p => ({
              type: 'Feature',
              geometry: {type: 'Point', coordinates: [p.lon, p.lat]},
              properties: {},
            })),
            ...routes.map (_ => _.points).map (pp => ({
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: pp.map (p => [p.lon, p.lat]),
              },
              properties: {},
            })),
          ],
        };
        let source = map.getSource ('routes-' + opts.id);
        if (source) {
          source.setData (data);
        } else {
          map.addSource ('routes-' + opts.id, {type: 'geojson', data});
        }

        if (!map.getLayer ('route-points-' + opts.id)) {
          map.addLayer ({
            id: 'route-points-' + opts.id,
            source: 'routes-' + opts.id,
            type: 'circle',
            paint: opts.pointPaint,
            filter: ['==', ['geometry-type'], 'Point']
          });
          map.addLayer({
            id: 'route-lines-' + opts.id,
            source: 'routes-' + opts.id,
            type: 'line',
            paint: opts.linePaint,
            filter: ['==', ['geometry-type'], 'LineString']
          });
        }
      } // showRoutes

      function showTeamHistory (map, taem, routes) {
        showRoutes (map, routes, {
          id: 'team-history',
          linePaint: {
            'line-color': '#ffff0087',
            'line-width': 5,
          },
          pointPaint: {
            'circle-radius': 5,
            'circle-color': 'yellow',
            'circle-stroke-color': 'gray',
            'circle-stroke-width': 1,
          },
        });
      } // showTeamHistory

      function directionByPCA (points, idx, window) {
        const center = points[idx];
        const deg2rad = Math.PI/180;
        const R = 6371000;
        const lat0 = center.lat * deg2rad;
        const cosLat0 = Math.cos(lat0);

        const start = Math.max(0, idx - window);
        const end   = Math.min(points.length - 1, idx + window);

        const arr = [];
        for (let i = start; i <= end; i++) {
          const p = points[i];
          const dx = (p.lon - center.lon) * deg2rad * R * cosLat0; 
          const dy = (p.lat - center.lat) * deg2rad * R;
          arr.push([dx, dy]);
        }

        let sx=0, sy=0, sxx=0, sxy=0, syy=0;
        const n = arr.length;
        for (const [dx, dy] of arr) { sx += dx; sy += dy; sxx += dx*dx; sxy += dx*dy; syy += dy*dy; }
  const mx = sx / n, my = sy / n;
  const covxx = sxx/n - mx*mx;
  const covxy = sxy/n - mx*my;
  const covyy = syy/n - my*my;

        const trace = covxx + covyy;
  const det = covxx*covyy - covxy*covxy;
  const lambda = trace/2 + Math.sqrt((trace*trace)/4 - det);
        let vx = covxy;
  let vy = lambda - covxx;
  if (Math.abs(vx) < 1e-12 && Math.abs(vy) < 1e-12) { vx = 1; vy = 0; }
        const len = Math.hypot(vx, vy) || 1;
        vx /= len; vy /= len;

        const angRad = Math.atan2(vy, vx);
        const bearing = (90 - angRad*180/Math.PI + 360) % 360;
        return bearing;
      }


      let prevBearing = 0;
      let prevPosition = null;
      let prevNow = 0;
      let prevTime = 0;
      let prevEased = 0;
      function showByTime (ma, map, info, team, routes, time, opts) {
        let path = routes.map (_ => _.points).flat ();
        if (path.length < 2) return;

        if (time === null) {
          let now = performance.now ();
          let delta = (now - prevNow) / 1000;
          let factor = 100;
          time = prevTime + delta * factor;
          prevNow = now;
        }
        prevTime = time;

        let i = 0;
        while (i < path.length-1 && path[i+1].timestamp < time) i++;
        if (i >= path.length-1) i = path.length-2;

  const p0 = path[i];
  const p1 = path[i+1];

        const t = (time - p0.timestamp)/(p1.timestamp - p0.timestamp);

                   const lat = p0.lat + t*(p1.lat - p0.lat);
                   const lon = p0.lon + t*(p1.lon - p0.lon);

                   const ele0 = p0.elevation == null ? getElevation(p0.lat, p0.lon) : p0.elevation;
  const ele1 = p1.elevation == null ? getElevation(p1.lat, p1.lon) : p1.elevation;
  const elevation = ele0 + t*(ele1 - ele0);

        const deltaLon = (p1.lon - p0.lon) * Math.PI/180;
  const y = Math.sin(deltaLon) * Math.cos(p1.lat*Math.PI/180);
  const x = Math.cos(p0.lat*Math.PI/180)*Math.sin(p1.lat*Math.PI/180) -
            Math.sin(p0.lat*Math.PI/180)*Math.cos(p1.lat*Math.PI/180)*Math.cos(deltaLon);
                   let targetBearing = (Math.atan2(y,x) * 180/Math.PI + 360) % 360;
                   targetBearing = directionByPCA (path, i, 10);

          let container = map.getContainer ();
          let rect = container.getBoundingClientRect ();
          let width = rect.width;
          let height = rect.height;

        if (width > height) targetBearing += 90;
        
        const diff = ((targetBearing - prevBearing + 540) % 360) - 180;
        const limited = prevBearing + Math.max(Math.min(diff, 5), -5);

        let bearing = opts.animated ? limited : targetBearing;
        
        let newCenter = {lon, lat, team};

        let camera = opts.animated ? prevPosition || newCenter : newCenter;

        bearing = targetBearing;
        camera = newCenter;
        let cameraOffset = undefined;
        if (opts.animated) {
          let targetPoint = map.project (newCenter);
          let centerPoint = map.project (map.getCenter ());
          let centerX = width / 2;
          let centerY = height / 2;
          let allowedX = width * 0.6 / 2;
          let allowedY = height * 0.6 / 2;
          let dx = targetPoint.x - centerPoint.x;
          let dy = targetPoint.y - centerPoint.y;
          let overX = 0;
          let overY = 0;
          if (dx >  allowedX) overX = +1;
          if (dx < -allowedX) overX = -1;
          if (dy >  allowedY) overY = +1;
          if (dy < -allowedY) overY = -1;
          if (Math.abs (dx) < allowedX) overX = 0;
          if (Math.abs (dy) < allowedY) overY = 0;
          let biasAmountX = width * 0.20;
          let biasAmountY = height * 0.20;
          let offsetX = (centerX - centerPoint.x) + -overX * biasAmountX;
          let offsetY = (centerY - centerPoint.y) + -overY * biasAmountY;
          cameraOffset = [offsetX, offsetY];
          if (overX || overY) {
            //
          } else {
            camera = cameraOffset = undefined;
          }
          if (map.XXXdragging) camera = cameraOffset = bearing = undefined;
        }
        
        showTeamLocations (map, [newCenter], {
          id: 'history-current',
        });
        let now = performance.now ();
        if (!opts.animated || now - prevEased > 3*1000) {
          if (bearing != null) map.easeTo({
          bearing: bearing,
          //pitch: pitch,
          //zoom: zoom,
            duration: opts.animated ? 60*1000 : 0,
          });
          if (camera) console.log(camera)
          if (camera) map.easeTo({
            center: camera,
            ...(cameraOffset ? {offset: cameraOffset} : {}),
          //pitch: pitch,
          //zoom: zoom,
            duration: opts.animated ? 3*1000 : 0,
            easing : t => t,
        });
          prevBearing = bearing;
          prevPosition = newCenter;
          prevEased = now;
        }

        if (document.querySelector ('input[name=animated]:checked')) {
          requestAnimationFrame (() => {
            showByTime (ma, map, info, team, routes, null, {animated: true});
          });
        }
      } // showByTime

      document.querySelectorAll ('map-area').forEach (ma => {
        ma.addEventListener ('mousedown', () => {
          ma.pc_MLMap.XXXdragging = true;
        }, {capture: true});
        window.addEventListener ('mouseup', () => {
          ma.pc_MLMap.XXXdragging = false;
        }, {capture: true});
      });

      let timeSetter;
      let timeSetterMain = () => {};
      
      function showIbukiEvent (url, opts) {
        let ma = document.querySelector ('map-area');
        let map = ma.pc_MLMap;
        if (!map) return false;

        if (!timeSetter) {
          ma.pcTimeSetters.push (timeSetter = _ => timeSetterMain (_));
        }
        
        url = url.replace (/^https?:\/\/ibuki.run\//, 'https://od.ibuki.run/');
        //not return
        Promise.all ([
          fetch (new URL ('info.json?with_routes=1', url)).then (res => {
            if (res.status !== 200) throw res;
            return res.json ();
          }).then (info => {
            showRoutes (map, parseEncodedRoutes (info.encoded_routes), {
              id: 'route',
              linePaint: {
                'line-color': 'green',
                'line-width': 2,
              },
              pointPaint: {
                'circle-radius': 2,
                'circle-color': 'green',
                'circle-stroke-color': '#000000',
                'circle-stroke-width': 1,
              },
            });
            showMarkedPoints (map, info.marked_points);
            return info;
          }),
          fetch (new URL ('teams.json', url)).then (res => {
            if (res.status !== 200) throw res;
            return res.json ();
          }),
          fetch (new URL ('teamlocations.json', url)).then (res => {
            if (res.status !== 200) throw res;
            return res.json ();
          }),
          opts.teamId ? fetch (new URL ('t/' + opts.teamId + '/locationhistory.json', url)).then (res => {
            if (res.status !== 200) throw res;
            return res.json ();
          }).then (json => {
            return parseEncodedRoutes (json.encoded_routes);
          }) : null,
        ]).then (([info, teams, locs, hist]) => {
          let teamByDK = {};
          teams.items.forEach (t => {
            teamByDK['tt,,' + t.id] = t;
          });
          let tls = [];
          Object.keys (locs.items).forEach (dk => {
            let loc = locs.items[dk];
            loc.team = teamByDK[dk] || {};
            tls.push (loc);
          });

          showTeamLocations (map, tls, {
            id: 'teamlocations',
          });

          if (hist) {
            let team = teamByDK['tt,,' + opts.teamId];
            showTeamHistory (map, team, hist)
            timeSetterMain = (time) => {
              if (!time) return;
              showByTime (ma, map, info, team, hist, time, {});
            };
          }

          let now = new Date () . valueOf () / 1000;
          if (hist) {
            now = hist?.[0]?.points.at (-1).timestamp;
          }
          if (info.end_date < now) now = info.end_date
          if (now < info.start_date) now = info.start_date;
          document.querySelectorAll ('input[name=event-time-range]').forEach (e => {
            e.min = info.start_date
            e.max = info.end_date;
            e.valueAsNumber = now;
            e.dispatchEvent (new Event ('input', {bubbles: true}));
            e.closest ('input-datetime').querySelector ('input[type=checkbox]').checked = true;
          });

          if (opts.new) {
            ma.pcScroll ({
              center: hist?.[0]?.points[0] || tls[0] || info.marked_points.at (-1) || undefined,
            });
          }
        });

        return true;
      } // showIbukiEvent

      function showIbukiEventByURL (u, opts) {
        let m = u.match (/^(https?:\/\/[^\/]+\/ev\/[0-9]+\/)(?:t\/([0-9]+)\/|)/);
        if (!m) throw new Error ("Bad URL: " + u);

        let r = showIbukiEvent (m[1], {...opts, teamId: m[2]});
        return r;
      } // showIbukiEventByURL
    </script>

    <p class=buttons>
      <button value=gsi-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">standard</button>
      <button value=gsi-english onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">english</button>
      <button value=gsi-english-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">english/standard</button>
      <button value=gsi-lang onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">lang-dependent</button>
      <button value=gsi-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">hillshade</button>
      <button value=gsi-photo onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">photo</button>
      <button value=gsi-standard-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">standard+hillshade</button>
      <button value=gsi-hillshade-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">hillshade+standard</button>
      <button value=gsi-photo-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">photo+standard</button>
      <button value=none onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">none</button>
      <button value=B13/TBB onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (B13/TBB)</button>
      <button value=B03/ALBD onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (B03/ALBD)</button>
      <button value=B08/TBB onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (B08/TBB)</button>
      <button value=REP/ETC onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (REP/ETC)</button>
      <button value=SND/ETC onclick="
        document.querySelector('map-area').setMapType('himawari:'+this.value);
      ">himawari (SND/ETC)</button>
      <button value=B13/TBB onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (B13/TBB)</button>
      <button value=B03/ALBD onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (B03/ALBD)</button>
      <button value=B08/TBB onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (B08/TBB)</button>
      <button value=REP/ETC onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (REP/ETC)</button>
      <button value=SND/ETC onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-standard:'+this.value);
      ">himawari+gsi-standard (SND/ETC)</button>
      <button value=jma-umimesh-wind onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">jma-umimesh-wind</button>
      <button value=jma-umimesh-wind+gsi-standard onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">jma-umimesh-wind+gsi-standard</button>
      <button value=osm onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">osm</button>
      <button value=osm-gsi-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">osm-gsi-hillshade</button>
      <button value=osm-gsi-hillshade+gsi-optimal_bvmap-label onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">osm-gsi-hillshade+gsi-optimal_bvmap-label</button>
      <button value=osm-gsi-hillshade+gsi-optimal_bvmap-contour-label onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">osm-gsi-hillshade+gsi-optimal_bvmap-contour-label</button>
      <button value=gsi-optimal_bvmap onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-optimal_bvmap</button>
      <button value=gsi-optimal_bvmap-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-optimal_bvmap-hillshade</button>
      <button value=gsi-optimal_bvmap-nocontour-hillshade onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-optimal_bvmap-nocontour-hillshade</button>
      <button value=gsi-photo-optimal_bvmap onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-photo-optimal_bvmap</button>
      <button value=gsi-photo-optimal_bvmap-nocontour onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-photo-optimal_bvmap-nocontour</button>
      <button value=gsi-hillshade-optimal_bvmap onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-hillshade-optimal_bvmap</button>
      <button value=gsi-hillshade-optimal_bvmap-nocontour onclick="
        document.querySelector('map-area').setMapType(this.value);
      ">gsi-hillshade-optimal_bvmap-nocontour</button>
      <button value=SND/ETC onclick="
        document.querySelector('map-area').setMapType('himawari+gsi-optimal_bvmap:'+this.value);
      ">himawari+gsi-optimal_bvmap (SND/ETC)</button>

      <input id=latlon onfocus=this.select() onchange="
        var [lat, lon] = this.value.split (/,/);
        var m = document.querySelector ('map-area');
        m.setAttribute ('lat', lat);
        m.setAttribute ('lon', lon);
      ">
    <p>
      <output name=bounds></output>
    <p>
      <output name=value></output>
    <script>
    (() => {
      var testRenderCount = 0;
      var s = document.querySelector ('#map-section-1');
      s.querySelector ('map-area').addEventListener ('pcRedraw', (ev) => {
        var o = s.querySelector ('output[name=bounds]');
        var b = ev.target.getMapBounds ();
        let zoom = ev.target.pcZoomLevel;
        if (b) o.textContent = [b.north, b.east, b.south, b.west, zoom,
                                ev.target.pc_Bearing,
                                ev.target.pc_Pitch].join (' ');

        var c = ev.target.getMapCenter ();
        document.querySelector ('#latlon').value = c.lat + ',' + c.lon;
        
        var n = ++testRenderCount;
        ev.target.setMouseHandlers ({
          mousedown: obj => {
            console.log (n, "mousedown", obj.getMouseButton (), obj.getPoint ());
          },
          mousemove: obj => {
            //console.log (n, "mousemove", obj.getMouseButton (), obj.getPoint ());
          },
          mouseup: obj => {
            console.log (n, "mouseup", obj.getMouseButton (), obj.getPoint ());
          },
        });
      });
      s.querySelector ('map-area').addEventListener ('change', (ev) => {
        var o = s.querySelector ('output[name=value]');

        var v = ev.target.valueAsLatLon;
        o.textContent = [v.lat, v.lon, null];

        console.pcMaps.getElevation (v.lat, v.lon).then (elevation => {
          o.textContent = [v.lat, v.lon, elevation];
        });
      });
    }) ();
    </script>

      <input type=range min=0 value=1.2 max=5 step=0.1 oninput="
        var map = document.querySelector ('map-area');
        map.setAttribute ('terrain', this.value);
      ">
    <p>
      <button type=button onclick="
        parentNode.parentNode.querySelector ('map-area').noMapDraggable = false;
      ">Draggable</button>
      <button type=button onclick="
        parentNode.parentNode.querySelector ('map-area').noMapDraggable = true;
      ">Non-draggable</button>
      <button type=button onclick="
        var map = document.querySelector ('map-area');
        var e1 = document.createElement ('x-1');
        var e2 = document.createElement ('x-2');
        var e3 = document.createElement ('x-3');
        var e4 = document.createElement ('x-4');
        var pp = map.addElementOverlays ({
          background: e1, foreground: e2, tooltip: e3, interactive: e4,
        }, () => {
          var center = map.getMapCenter ();
          var p1 = pp.getProjection ().divPoint (center);
          e1.style.left = p1.x + 'px';
          e1.style.top = p1.y + 'px';
          
          e2.style.left = p1.x + 100 + 'px';
          e2.style.top = p1.y + 'px';
          
          e3.style.left = p1.x + 'px';
          e3.style.top = p1.y + 100 + 'px';
          
          e4.style.left = p1.x + 100 + 'px';
          e4.style.top = p1.y + 100 + 'px';
        });
      ">addElementOverlays</button>

    <p>
      <input-datetime oninput="
        var map = document.querySelector ('map-area');
        map.explicitTime = querySelector ('input[type=checkbox]').checked ? this.value : null;
      ">
        <input type=checkbox>
        <input type=date>
        <input type=time>

        <input type=range name=event-time-range step=60 oninput="
          parentNode.value = this.valueAsNumber;
        " style="width: 50%">
      </input-datetime>
      <label><input type=checkbox name=animated> â–¶</label>
      <button type=button onclick="
        let map = document.querySelector ('map-area');
        map.setAttribute ('zoom', 12);
        map.setAttribute ('pitch', 50);
        document.querySelector ('[name=animated]').checked = true;
        let time = document.querySelector ('[name=event-time-range]');
        time.value = parseFloat (time.min) + (time.max - time.min) / 3;
        time.dispatchEvent (new Event ('input', {bubbles: true}));
      ">A1</button>
      
    <p>
      <input type=url name=ibukiURL onchange="
        setURL (value, {initiator: 'input'});
      " style="width: 100%">
    <script>
      let ibukiURL = null;
      let newRequest = true;
      {
        let sp = new URLSearchParams (location.hash.replace (/^#/, ''));
        let ib = sp.get ('ibuki');
        if (ib) setURL (ib, {initiator: 'hash'});
        let mt = sp.get ('map');
        if (mt) document.querySelector ('map-area').setAttribute ('maptype', mt);
      }

      document.querySelector ('map-area').addEventListener ('pcMapTypeChange', () => {
        if (ibukiURL) {
          showIbukiEventByURL (ibukiURL, {new: newRequest});
          newRequest = false;
          updateURL ();
        }
      });

      function setURL (u, opts) {
        if (/\/ev\/[0-9]+\//.test (u)) {
          ibukiURL = u;
          newRequest = true;
          if (showIbukiEventByURL (ibukiURL, {new: newRequest})) {
            newRequest = false;
          }
          if (opts.initiator !== 'hash') updateURL ();
          if (opts.initiator !== 'input') document.querySelectorAll ('input[name=ibukiURL]').forEach (_ => _.value = ibukiURL);
        } else {
          throw new Error ("Bad URL: " + u);
        }
      } // setURL

      function updateURL () {
        let mt = document.querySelector ('map-area').pcMapType;
        history.replaceState (null, null, '#ibuki=' + encodeURIComponent (ibukiURL) + '&map=' + mt);
      }
    </script>
      
    <hr style="margin-top: 10em">

    <form>
      <input type=number name=lat value=0 step=0.0001>
      <input type=number name=lon value=0 step=0.0001>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          center: {lat: form.elements.lat.value,
                   lon: form.elements.lon.value},
        });
      ">setCenter</button>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          center: {lat: form.elements.lat.value,
                   lon: form.elements.lon.value},
          setValue: true,
        });
      ">setCenter + setValue</button>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          center: {lat: form.elements.lat.value,
                   lon: form.elements.lon.value},
          intoView: true,
        });
      ">setCenter + scrollIntoView</button>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          center: {lat: form.elements.lat.value,
                   lon: form.elements.lon.value},
          intoView: true,
          ifNeeded: true,
        });
      ">setCenter + scrollIntoViewIfNeeded</button>
      <button type=button onclick="
        document.querySelector ('map-area').pcScroll ({
          bounds: {north: form.elements.lat.valueAsNumber,
                   west: form.elements.lon.valueAsNumber,
                   south: form.elements.lat.valueAsNumber + 1,
                   east: form.elements.lon.valueAsNumber + 1,
                   },
        });
      ">setBounds</button>
    </form>

    <hr style="margin-top: 10em">

    <p><map-area engine=maplibre gsi controls style="height:28em"></map-area>
    <p><map-area engine=maplibre controls style="height:17em"></map-area>
    <p><map-area engine=maplibre controls=coordinates style="height:17em"></map-area>
  </section>
