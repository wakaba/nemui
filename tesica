#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AE';
  =head1 NAME
  
  AE - simpler/faster/newer/cooler AnyEvent API
  
  =head1 SYNOPSIS
  
    use AnyEvent; # not AE
  
    # file handle or descriptor readable
    my $w = AE::io $fh, 0, sub { ...  };
  
    # one-shot or repeating timers
    my $w = AE::timer $seconds,         0, sub { ... }; # once
    my $w = AE::timer $seconds, $interval, sub { ... }; # repeated
  
    print AE::now;  # prints current event loop time
    print AE::time; # think Time::HiRes::time or simply CORE::time.
  
    # POSIX signal
    my $w = AE::signal TERM => sub { ... };
  
    # child process exit
    my $w = AE::child $pid, sub {
       my ($pid, $status) = @_;
       ...
    };
  
    # called when event loop idle (if applicable)
    my $w = AE::idle sub { ... };
  
    my $cv = AE::cv; # stores whether a condition was flagged
    $cv->send; # wake up current and all future recv's
    $cv->recv; # enters "main loop" till $condvar gets ->send
    # use a condvar in callback mode:
    $cv->cb (sub { $_[0]->recv });
  
  
  =head1 DESCRIPTION
  
  This module documents the new simpler AnyEvent API.
  
  The rationale for the new API is that experience with L<EV> shows that
  this API actually "works", despite its lack of extensibility, leading to
  a shorter, easier and faster API.
  
  The main differences from AnyEvent is that function calls are used
  instead of method calls, and that no named arguments are used.
  
  This makes calls to watcher creation functions really short, which can
  make a program more readable despite the lack of named parameters.
  Function calls also allow more static type checking than method calls, so
  many mistakes are caught at compile-time with this API.
  
  Also, some backends (Perl and EV) are so fast that the method call
  overhead is very noticeable (with EV it increases the execution time five-
  to six-fold, with Perl the method call overhead is about a factor of two).
  
  Note that the C<AE> API is an alternative to, not the future version of,
  the AnyEvent API. Both APIs can be used interchangeably and there are
  no plans to "switch", so if in doubt, feel free to use the L<AnyEvent>
  API in new code.
  
  As the AE API is complementary, not everything in the AnyEvent API is
  available, and you still need to use AnyEvent for the finer stuff. Also,
  you should not C<use AE> directly, C<use AnyEvent> will provide the AE
  namespace.
  
  At the moment, these functions will become slower then their method-call
  counterparts when using L<AnyEvent::Strict> or L<AnyEvent::Debug>::wrap.
  
  =head2 FUNCTIONS
  
  This section briefly describes the alternative watcher constructors and
  other functions available inside the C<AE> namespace. Semantics are not
  described here; please refer to the description of the function or method
  with the same name in the L<AnyEvent> manpage for the details.
  
  =over 4
  
  =cut
  
  package AE;
  
  use AnyEvent (); # BEGIN { AnyEvent::common_sense }
  
  our $VERSION = $AnyEvent::VERSION;
  
  =item $w = AE::io $fh_or_fd, $watch_write, $cb
  
  Creates an I/O watcher that listens for read events (C<$watch_write>
  false) or write events (C<$watch_write> is true) on the file handle or
  file descriptor C<$fh_or_fd>.
  
  The callback C<$cb> is invoked as soon and as long as I/O of the type
  specified by C<$watch_write>) can be done on the file handle/descriptor.
  
  Example: wait until STDIN becomes readable.
  
    $stdin_ready = AE::io *STDIN, 0, sub { scalar <STDIN> };
  
  Example: wait until STDOUT becomes writable and print something.
  
    $stdout_ready = AE::io *STDOUT, 1, sub { print STDOUT "woaw\n" };
  
  =item $w = AE::timer $after, $interval, $cb
  
  Creates a timer watcher that invokes the callback C<$cb> after at least
  C<$after> second have passed (C<$after> can be negative or C<0>).
  
  If C<$interval> is C<0>, then the callback will only be invoked once,
  otherwise it must be a positive number of seconds that specifies the
  interval between successive invocations of the callback.
  
  Example: print "too late" after at least one second has passed.
  
    $timer_once = AE::timer 1, 0, sub { print "too late\n" };
  
  Example: print "blubb" once a second, starting as soon as possible.
  
    $timer_repeated = AE::timer 0, 1, sub { print "blubb\n" };
  
  =item $w = AE::signal $signame, $cb
  
  Invoke the callback C<$cb> each time one or more occurrences of the
  named signal C<$signame> are detected.
  
  =item $w = AE::child $pid, $cb
  
  Invokes the callback C<$cb> when the child with the given C<$pid> exits
  (or all children, when C<$pid> is zero).
  
  The callback will get the actual pid and exit status as arguments.
  
  =item $w = AE::idle $cb
  
  Invoke the callback C<$cb> each time the event loop is "idle" (has no
  events outstanding), but do not prevent the event loop from polling for
  more events.
  
  =item $cv = AE::cv
  
  =item $cv = AE::cv { BLOCK }
  
  Create a new condition variable. The first form is identical to C<<
  AnyEvent->condvar >>, the second form additionally sets the callback (as
  if the C<cb> method is called on the condition variable).
  
  =item AE::now
  
  Returns the current event loop time (may be cached by the event loop).
  
  =item AE::now_update
  
  Ensures that the current event loop time is up to date.
  
  =item AE::time
  
  Return the current time (not cached, always consults a hardware clock).
  
  =item AE::postpone { BLOCK }
  
  Exactly the same as C<AnyEvent:::postpone>.
  
  =item AE::log $level, $msg[, @args]
  
  Exactly the same as C<AnyEvent::log> (or C<AnyEvent::Log::log>).
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
AE

$fatpacked{"AbortController.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ABORTCONTROLLER';
  package AbortController;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use AbortSignal;
  
  push our @CARP_NOT, qw(AbortSignal);
  
  sub new ($) {
    return bless {
      signal => (bless {}, 'AbortSignal'),
    }, $_[0];
  } # new
  
  sub signal ($) { $_[0]->{signal} }
  
  sub abort ($) {
    $_[0]->{signal}->_signal_abort;
  } # abort
  
  1;
  
  =head1 LICENSE
  
  Copyright 2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
ABORTCONTROLLER

$fatpacked{"AbortSignal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ABORTSIGNAL';
  package AbortSignal;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use AbortSignal;
  use Promise::AbortError;
  
  push our @CARP_NOT, qw(Promise::AbortError);
  
  ## DOM: isa EventTarget
  ## DOM: onabort
  
  sub manakai_onabort ($;$) {
    if (@_ > 1) {
      $_[0]->{abort_cb} = $_[0]->{aborted} ? undef : $_[1];
    }
    return $_[0]->{abort_cb};
  } # manakai_onabort
  
  sub aborted ($) { $_[0]->{aborted} }
  
  sub manakai_error ($;$) {
    if (@_ > 1) {
      $_[0]->{error} = $_[1];
    }
    return $_[0]->{error};
  } # manakai_error
  
  sub _signal_abort ($) {
    my $signal = $_[0];
  
    return if $signal->{aborted};
    $signal->{aborted} = 1;
  
    ## Abort algorithms for Perl [DOMPERL]
    $signal->{error} = Promise::AbortError->new;
    my $cb = $signal->{abort_cb};
    if (defined $cb) {
      my $file = $signal->{error}->file_name;
      $file =~ s/[\x0D\x0A\x22]/_/g;
      my $code = sprintf q{#line %d "%s"
  $cb->();
  1}, $signal->{error}->line_number, $file;
      eval $code or warn "$@\n"; # XXX report exception
      delete $signal->{abort_cb};
    }
  } # _signal_abort
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/) {
      warn "$$: Reference to AbortSignal ($_[0]) is not discarded before global destruction\n";
    }
  } # DESTROY
  
  1;
  
  =head1 LICENSE
  
  Copyright 2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
ABORTSIGNAL

$fatpacked{"AnyEvent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT';
  =head1 NAME
  
  AnyEvent - the DBI of event loop programming
  
  EV, Event, Glib, Tk, UV, Perl, Event::Lib, Irssi, rxvt-unicode, IO::Async,
  Qt, FLTK and POE are various supported event loops/environments.
  
  =head1 SYNOPSIS
  
     use AnyEvent;
  
     # if you prefer function calls, look at the AE manpage for
     # an alternative API.
  
     # file handle or descriptor readable
     my $w = AnyEvent->io (fh => $fh, poll => "r", cb => sub { ...  });
  
     # one-shot or repeating timers
     my $w = AnyEvent->timer (after => $seconds, cb => sub { ...  });
     my $w = AnyEvent->timer (after => $seconds, interval => $seconds, cb => ...);
  
     print AnyEvent->now;  # prints current event loop time
     print AnyEvent->time; # think Time::HiRes::time or simply CORE::time.
  
     # POSIX signal
     my $w = AnyEvent->signal (signal => "TERM", cb => sub { ... });
  
     # child process exit
     my $w = AnyEvent->child (pid => $pid, cb => sub {
        my ($pid, $status) = @_;
        ...
     });
  
     # called when event loop idle (if applicable)
     my $w = AnyEvent->idle (cb => sub { ... });
  
     my $w = AnyEvent->condvar; # stores whether a condition was flagged
     $w->send; # wake up current and all future recv's
     $w->recv; # enters "main loop" till $condvar gets ->send
     # use a condvar in callback mode:
     $w->cb (sub { $_[0]->recv });
  
  =head1 INTRODUCTION/TUTORIAL
  
  This manpage is mainly a reference manual. If you are interested
  in a tutorial or some gentle introduction, have a look at the
  L<AnyEvent::Intro> manpage.
  
  =head1 SUPPORT
  
  An FAQ document is available as L<AnyEvent::FAQ>.
  
  There also is a mailinglist for discussing all things AnyEvent, and an IRC
  channel, too.
  
  See the AnyEvent project page at the B<Schmorpforge Ta-Sa Software
  Repository>, at L<http://anyevent.schmorp.de>, for more info.
  
  =head1 WHY YOU SHOULD USE THIS MODULE (OR NOT)
  
  Glib, POE, IO::Async, Event... CPAN offers event models by the dozen
  nowadays. So what is different about AnyEvent?
  
  Executive Summary: AnyEvent is I<compatible>, AnyEvent is I<free of
  policy> and AnyEvent is I<small and efficient>.
  
  First and foremost, I<AnyEvent is not an event model> itself, it only
  interfaces to whatever event model the main program happens to use, in a
  pragmatic way. For event models and certain classes of immortals alike,
  the statement "there can only be one" is a bitter reality: In general,
  only one event loop can be active at the same time in a process. AnyEvent
  cannot change this, but it can hide the differences between those event
  loops.
  
  The goal of AnyEvent is to offer module authors the ability to do event
  programming (waiting for I/O or timer events) without subscribing to a
  religion, a way of living, and most importantly: without forcing your
  module users into the same thing by forcing them to use the same event
  model you use.
  
  For modules like POE or IO::Async (which is a total misnomer as it is
  actually doing all I/O I<synchronously>...), using them in your module is
  like joining a cult: After you join, you are dependent on them and you
  cannot use anything else, as they are simply incompatible to everything
  that isn't them. What's worse, all the potential users of your
  module are I<also> forced to use the same event loop you use.
  
  AnyEvent is different: AnyEvent + POE works fine. AnyEvent + Glib works
  fine. AnyEvent + Tk works fine etc. etc. but none of these work together
  with the rest: POE + EV? No go. Tk + Event? No go. Again: if your module
  uses one of those, every user of your module has to use it, too. But if
  your module uses AnyEvent, it works transparently with all event models it
  supports (including stuff like IO::Async, as long as those use one of the
  supported event loops. It is easy to add new event loops to AnyEvent, too,
  so it is future-proof).
  
  In addition to being free of having to use I<the one and only true event
  model>, AnyEvent also is free of bloat and policy: with POE or similar
  modules, you get an enormous amount of code and strict rules you have to
  follow. AnyEvent, on the other hand, is lean and to the point, by only
  offering the functionality that is necessary, in as thin as a wrapper as
  technically possible.
  
  Of course, AnyEvent comes with a big (and fully optional!) toolbox
  of useful functionality, such as an asynchronous DNS resolver, 100%
  non-blocking connects (even with TLS/SSL, IPv6 and on broken platforms
  such as Windows) and lots of real-world knowledge and workarounds for
  platform bugs and differences.
  
  Now, if you I<do want> lots of policy (this can arguably be somewhat
  useful) and you want to force your users to use the one and only event
  model, you should I<not> use this module.
  
  =head1 DESCRIPTION
  
  L<AnyEvent> provides a uniform interface to various event loops. This
  allows module authors to use event loop functionality without forcing
  module users to use a specific event loop implementation (since more
  than one event loop cannot coexist peacefully).
  
  The interface itself is vaguely similar, but not identical to the L<Event>
  module.
  
  During the first call of any watcher-creation method, the module tries
  to detect the currently loaded event loop by probing whether one of the
  following modules is already loaded: L<EV>, L<AnyEvent::Loop>,
  L<Event>, L<Glib>, L<Tk>, L<Event::Lib>, L<Qt>, L<POE>. The first one
  found is used. If none are detected, the module tries to load the first
  four modules in the order given; but note that if L<EV> is not
  available, the pure-perl L<AnyEvent::Loop> should always work, so
  the other two are not normally tried.
  
  Because AnyEvent first checks for modules that are already loaded, loading
  an event model explicitly before first using AnyEvent will likely make
  that model the default. For example:
  
     use Tk;
     use AnyEvent;
  
     # .. AnyEvent will likely default to Tk
  
  The I<likely> means that, if any module loads another event model and
  starts using it, all bets are off - this case should be very rare though,
  as very few modules hardcode event loops without announcing this very
  loudly.
  
  The pure-perl implementation of AnyEvent is called C<AnyEvent::Loop>. Like
  other event modules you can load it explicitly and enjoy the high
  availability of that event loop :)
  
  =head1 WATCHERS
  
  AnyEvent has the central concept of a I<watcher>, which is an object that
  stores relevant data for each kind of event you are waiting for, such as
  the callback to call, the file handle to watch, etc.
  
  These watchers are normal Perl objects with normal Perl lifetime. After
  creating a watcher it will immediately "watch" for events and invoke the
  callback when the event occurs (of course, only when the event model
  is in control).
  
  Note that B<callbacks must not permanently change global variables>
  potentially in use by the event loop (such as C<$_> or C<$[>) and that B<<
  callbacks must not C<die> >>. The former is good programming practice in
  Perl and the latter stems from the fact that exception handling differs
  widely between event loops.
  
  To disable a watcher you have to destroy it (e.g. by setting the
  variable you store it in to C<undef> or otherwise deleting all references
  to it).
  
  All watchers are created by calling a method on the C<AnyEvent> class.
  
  Many watchers either are used with "recursion" (repeating timers for
  example), or need to refer to their watcher object in other ways.
  
  One way to achieve that is this pattern:
  
     my $w; $w = AnyEvent->type (arg => value ..., cb => sub {
        # you can use $w here, for example to undef it
        undef $w;
     });
  
  Note that C<my $w; $w => combination. This is necessary because in Perl,
  my variables are only visible after the statement in which they are
  declared.
  
  =head2 I/O WATCHERS
  
     $w = AnyEvent->io (
        fh   => <filehandle_or_fileno>,
        poll => <"r" or "w">,
        cb   => <callback>,
     );
  
  You can create an I/O watcher by calling the C<< AnyEvent->io >> method
  with the following mandatory key-value pairs as arguments:
  
  C<fh> is the Perl I<file handle> (or a naked file descriptor) to watch
  for events (AnyEvent might or might not keep a reference to this file
  handle). Note that only file handles pointing to things for which
  non-blocking operation makes sense are allowed. This includes sockets,
  most character devices, pipes, fifos and so on, but not for example files
  or block devices.
  
  C<poll> must be a string that is either C<r> or C<w>, which creates a
  watcher waiting for "r"eadable or "w"ritable events, respectively.
  
  C<cb> is the callback to invoke each time the file handle becomes ready.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to I/O watcher callbacks.
  
  The I/O watcher might use the underlying file descriptor or a copy of it.
  You must not close a file handle as long as any watcher is active on the
  underlying file descriptor.
  
  Some event loops issue spurious readiness notifications, so you should
  always use non-blocking calls when reading/writing from/to your file
  handles.
  
  Example: wait for readability of STDIN, then read a line and disable the
  watcher.
  
     my $w; $w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
        chomp (my $input = <STDIN>);
        warn "read: $input\n";
        undef $w;
     });
  
  =head2 TIME WATCHERS
  
     $w = AnyEvent->timer (after => <seconds>, cb => <callback>);
  
     $w = AnyEvent->timer (
        after    => <fractional_seconds>,
        interval => <fractional_seconds>,
        cb       => <callback>,
     );
  
  You can create a time watcher by calling the C<< AnyEvent->timer >>
  method with the following mandatory arguments:
  
  C<after> specifies after how many seconds (fractional values are
  supported) the callback should be invoked. C<cb> is the callback to invoke
  in that case.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to time watcher callbacks.
  
  The callback will normally be invoked only once. If you specify another
  parameter, C<interval>, as a strictly positive number (> 0), then the
  callback will be invoked regularly at that interval (in fractional
  seconds) after the first invocation. If C<interval> is specified with a
  false value, then it is treated as if it were not specified at all.
  
  The callback will be rescheduled before invoking the callback, but no
  attempt is made to avoid timer drift in most backends, so the interval is
  only approximate.
  
  Example: fire an event after 7.7 seconds.
  
     my $w = AnyEvent->timer (after => 7.7, cb => sub {
        warn "timeout\n";
     });
  
     # to cancel the timer:
     undef $w;
  
  Example 2: fire an event after 0.5 seconds, then roughly every second.
  
     my $w = AnyEvent->timer (after => 0.5, interval => 1, cb => sub {
        warn "timeout\n";
     });
  
  =head3 TIMING ISSUES
  
  There are two ways to handle timers: based on real time (relative, "fire
  in 10 seconds") and based on wallclock time (absolute, "fire at 12
  o'clock").
  
  While most event loops expect timers to specified in a relative way, they
  use absolute time internally. This makes a difference when your clock
  "jumps", for example, when ntp decides to set your clock backwards from
  the wrong date of 2014-01-01 to 2008-01-01, a watcher that is supposed to
  fire "after a second" might actually take six years to finally fire.
  
  AnyEvent cannot compensate for this. The only event loop that is conscious
  of these issues is L<EV>, which offers both relative (ev_timer, based
  on true relative time) and absolute (ev_periodic, based on wallclock time)
  timers.
  
  AnyEvent always prefers relative timers, if available, matching the
  AnyEvent API.
  
  AnyEvent has two additional methods that return the "current time":
  
  =over 4
  
  =item AnyEvent->time
  
  This returns the "current wallclock time" as a fractional number of
  seconds since the Epoch (the same thing as C<time> or C<Time::HiRes::time>
  return, and the result is guaranteed to be compatible with those).
  
  It progresses independently of any event loop processing, i.e. each call
  will check the system clock, which usually gets updated frequently.
  
  =item AnyEvent->now
  
  This also returns the "current wallclock time", but unlike C<time>, above,
  this value might change only once per event loop iteration, depending on
  the event loop (most return the same time as C<time>, above). This is the
  time that AnyEvent's timers get scheduled against.
  
  I<In almost all cases (in all cases if you don't care), this is the
  function to call when you want to know the current time.>
  
  This function is also often faster then C<< AnyEvent->time >>, and
  thus the preferred method if you want some timestamp (for example,
  L<AnyEvent::Handle> uses this to update its activity timeouts).
  
  The rest of this section is only of relevance if you try to be very exact
  with your timing; you can skip it without a bad conscience.
  
  For a practical example of when these times differ, consider L<Event::Lib>
  and L<EV> and the following set-up:
  
  The event loop is running and has just invoked one of your callbacks at
  time=500 (assume no other callbacks delay processing). In your callback,
  you wait a second by executing C<sleep 1> (blocking the process for a
  second) and then (at time=501) you create a relative timer that fires
  after three seconds.
  
  With L<Event::Lib>, C<< AnyEvent->time >> and C<< AnyEvent->now >> will
  both return C<501>, because that is the current time, and the timer will
  be scheduled to fire at time=504 (C<501> + C<3>).
  
  With L<EV>, C<< AnyEvent->time >> returns C<501> (as that is the current
  time), but C<< AnyEvent->now >> returns C<500>, as that is the time the
  last event processing phase started. With L<EV>, your timer gets scheduled
  to run at time=503 (C<500> + C<3>).
  
  In one sense, L<Event::Lib> is more exact, as it uses the current time
  regardless of any delays introduced by event processing. However, most
  callbacks do not expect large delays in processing, so this causes a
  higher drift (and a lot more system calls to get the current time).
  
  In another sense, L<EV> is more exact, as your timer will be scheduled at
  the same time, regardless of how long event processing actually took.
  
  In either case, if you care (and in most cases, you don't), then you
  can get whatever behaviour you want with any event loop, by taking the
  difference between C<< AnyEvent->time >> and C<< AnyEvent->now >> into
  account.
  
  =item AnyEvent->now_update
  
  Some event loops (such as L<EV> or L<AnyEvent::Loop>) cache the current
  time for each loop iteration (see the discussion of L<< AnyEvent->now >>,
  above).
  
  When a callback runs for a long time (or when the process sleeps), then
  this "current" time will differ substantially from the real time, which
  might affect timers and time-outs.
  
  When this is the case, you can call this method, which will update the
  event loop's idea of "current time".
  
  A typical example would be a script in a web server (e.g. C<mod_perl>) -
  when mod_perl executes the script, then the event loop will have the wrong
  idea about the "current time" (being potentially far in the past, when the
  script ran the last time). In that case you should arrange a call to C<<
  AnyEvent->now_update >> each time the web server process wakes up again
  (e.g. at the start of your script, or in a handler).
  
  Note that updating the time I<might> cause some events to be handled.
  
  =back
  
  =head2 SIGNAL WATCHERS
  
     $w = AnyEvent->signal (signal => <uppercase_signal_name>, cb => <callback>);
  
  You can watch for signals using a signal watcher, C<signal> is the signal
  I<name> in uppercase and without any C<SIG> prefix, C<cb> is the Perl
  callback to be invoked whenever a signal occurs.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to signal watcher callbacks.
  
  Multiple signal occurrences can be clumped together into one callback
  invocation, and callback invocation will be synchronous. Synchronous means
  that it might take a while until the signal gets handled by the process,
  but it is guaranteed not to interrupt any other callbacks.
  
  The main advantage of using these watchers is that you can share a signal
  between multiple watchers, and AnyEvent will ensure that signals will not
  interrupt your program at bad times.
  
  This watcher might use C<%SIG> (depending on the event loop used),
  so programs overwriting those signals directly will likely not work
  correctly.
  
  Example: exit on SIGINT
  
     my $w = AnyEvent->signal (signal => "INT", cb => sub { exit 1 });
  
  =head3 Restart Behaviour
  
  While restart behaviour is up to the event loop implementation, most will
  not restart syscalls (that includes L<Async::Interrupt> and AnyEvent's
  pure perl implementation).
  
  =head3 Safe/Unsafe Signals
  
  Perl signals can be either "safe" (synchronous to opcode handling)
  or "unsafe" (asynchronous) - the former might delay signal delivery
  indefinitely, the latter might corrupt your memory.
  
  AnyEvent signal handlers are, in addition, synchronous to the event loop,
  i.e. they will not interrupt your running perl program but will only be
  called as part of the normal event handling (just like timer, I/O etc.
  callbacks, too).
  
  =head3 Signal Races, Delays and Workarounds
  
  Many event loops (e.g. Glib, Tk, Qt, IO::Async) do not support
  attaching callbacks to signals in a generic way, which is a pity,
  as you cannot do race-free signal handling in perl, requiring
  C libraries for this. AnyEvent will try to do its best, which
  means in some cases, signals will be delayed. The maximum time
  a signal might be delayed is 10 seconds by default, but can
  be overriden via C<$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}> or
  C<$AnyEvent::MAX_SIGNAL_LATENCY> - see the L<ENVIRONMENT VARIABLES>
  section for details.
  
  All these problems can be avoided by installing the optional
  L<Async::Interrupt> module, which works with most event loops. It will not
  work with inherently broken event loops such as L<Event> or L<Event::Lib>
  (and not with L<POE> currently). For those, you just have to suffer the
  delays.
  
  =head2 CHILD PROCESS WATCHERS
  
     $w = AnyEvent->child (pid => <process id>, cb => <callback>);
  
  You can also watch for a child process exit and catch its exit status.
  
  The child process is specified by the C<pid> argument (on some backends,
  using C<0> watches for any child process exit, on others this will
  croak). The watcher will be triggered only when the child process has
  finished and an exit status is available, not on any trace events
  (stopped/continued).
  
  The callback will be called with the pid and exit status (as returned by
  waitpid), so unlike other watcher types, you I<can> rely on child watcher
  callback arguments.
  
  This watcher type works by installing a signal handler for C<SIGCHLD>,
  and since it cannot be shared, nothing else should use SIGCHLD or reap
  random child processes (waiting for specific child processes, e.g. inside
  C<system>, is just fine).
  
  There is a slight catch to child watchers, however: you usually start them
  I<after> the child process was created, and this means the process could
  have exited already (and no SIGCHLD will be sent anymore).
  
  Not all event models handle this correctly (neither POE nor IO::Async do,
  see their AnyEvent::Impl manpages for details), but even for event models
  that I<do> handle this correctly, they usually need to be loaded before
  the process exits (i.e. before you fork in the first place). AnyEvent's
  pure perl event loop handles all cases correctly regardless of when you
  start the watcher.
  
  This means you cannot create a child watcher as the very first
  thing in an AnyEvent program, you I<have> to create at least one
  watcher before you C<fork> the child (alternatively, you can call
  C<AnyEvent::detect>).
  
  As most event loops do not support waiting for child events, they will be
  emulated by AnyEvent in most cases, in which case the latency and race
  problems mentioned in the description of signal watchers apply.
  
  Example: fork a process and wait for it
  
     my $done = AnyEvent->condvar;
    
     # this forks and immediately calls exit in the child. this
     # normally has all sorts of bad consequences for your parent,
     # so take this as an example only. always fork and exec,
     # or call POSIX::_exit, in real code.
     my $pid = fork or exit 5;
    
     my $w = AnyEvent->child (
        pid => $pid,
        cb  => sub {
           my ($pid, $status) = @_;
           warn "pid $pid exited with status $status";
           $done->send;
        },
     );
    
     # do something else, then wait for process exit
     $done->recv;
  
  =head2 IDLE WATCHERS
  
     $w = AnyEvent->idle (cb => <callback>);
  
  This will repeatedly invoke the callback after the process becomes idle,
  until either the watcher is destroyed or new events have been detected.
  
  Idle watchers are useful when there is a need to do something, but it
  is not so important (or wise) to do it instantly. The callback will be
  invoked only when there is "nothing better to do", which is usually
  defined as "all outstanding events have been handled and no new events
  have been detected". That means that idle watchers ideally get invoked
  when the event loop has just polled for new events but none have been
  detected. Instead of blocking to wait for more events, the idle watchers
  will be invoked.
  
  Unfortunately, most event loops do not really support idle watchers (only
  EV, Event and Glib do it in a usable fashion) - for the rest, AnyEvent
  will simply call the callback "from time to time".
  
  Example: read lines from STDIN, but only process them when the
  program is otherwise idle:
  
     my @lines; # read data
     my $idle_w;
     my $io_w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
        push @lines, scalar <STDIN>;
  
        # start an idle watcher, if not already done
        $idle_w ||= AnyEvent->idle (cb => sub {
           # handle only one line, when there are lines left
           if (my $line = shift @lines) {
              print "handled when idle: $line";
           } else {
              # otherwise disable the idle watcher again
              undef $idle_w;
           }
        });
     });
  
  =head2 CONDITION VARIABLES
  
     $cv = AnyEvent->condvar;
  
     $cv->send (<list>);
     my @res = $cv->recv;
  
  If you are familiar with some event loops you will know that all of them
  require you to run some blocking "loop", "run" or similar function that
  will actively watch for new events and call your callbacks.
  
  AnyEvent is slightly different: it expects somebody else to run the event
  loop and will only block when necessary (usually when told by the user).
  
  The tool to do that is called a "condition variable", so called because
  they represent a condition that must become true.
  
  Now is probably a good time to look at the examples further below.
  
  Condition variables can be created by calling the C<< AnyEvent->condvar
  >> method, usually without arguments. The only argument pair allowed is
  C<cb>, which specifies a callback to be called when the condition variable
  becomes true, with the condition variable as the first argument (but not
  the results).
  
  After creation, the condition variable is "false" until it becomes "true"
  by calling the C<send> method (or calling the condition variable as if it
  were a callback, read about the caveats in the description for the C<<
  ->send >> method).
  
  Since condition variables are the most complex part of the AnyEvent API, here are
  some different mental models of what they are - pick the ones you can connect to:
  
  =over 4
  
  =item * Condition variables are like callbacks - you can call them (and pass them instead
  of callbacks). Unlike callbacks however, you can also wait for them to be called.
  
  =item * Condition variables are signals - one side can emit or send them,
  the other side can wait for them, or install a handler that is called when
  the signal fires.
  
  =item * Condition variables are like "Merge Points" - points in your program
  where you merge multiple independent results/control flows into one.
  
  =item * Condition variables represent a transaction - functions that start
  some kind of transaction can return them, leaving the caller the choice
  between waiting in a blocking fashion, or setting a callback.
  
  =item * Condition variables represent future values, or promises to deliver
  some result, long before the result is available.
  
  =back
  
  Condition variables are very useful to signal that something has finished,
  for example, if you write a module that does asynchronous http requests,
  then a condition variable would be the ideal candidate to signal the
  availability of results. The user can either act when the callback is
  called or can synchronously C<< ->recv >> for the results.
  
  You can also use them to simulate traditional event loops - for example,
  you can block your main program until an event occurs - for example, you
  could C<< ->recv >> in your main program until the user clicks the Quit
  button of your app, which would C<< ->send >> the "quit" event.
  
  Note that condition variables recurse into the event loop - if you have
  two pieces of code that call C<< ->recv >> in a round-robin fashion, you
  lose. Therefore, condition variables are good to export to your caller, but
  you should avoid making a blocking wait yourself, at least in callbacks,
  as this asks for trouble.
  
  Condition variables are represented by hash refs in perl, and the keys
  used by AnyEvent itself are all named C<_ae_XXX> to make subclassing
  easy (it is often useful to build your own transaction class on top of
  AnyEvent). To subclass, use C<AnyEvent::CondVar> as base class and call
  its C<new> method in your own C<new> method.
  
  There are two "sides" to a condition variable - the "producer side" which
  eventually calls C<< -> send >>, and the "consumer side", which waits
  for the send to occur.
  
  Example: wait for a timer.
  
     # condition: "wait till the timer is fired"
     my $timer_fired = AnyEvent->condvar;
  
     # create the timer - we could wait for, say
     # a handle becomign ready, or even an
     # AnyEvent::HTTP request to finish, but
     # in this case, we simply use a timer:
     my $w = AnyEvent->timer (
        after => 1,
        cb    => sub { $timer_fired->send },
     );
  
     # this "blocks" (while handling events) till the callback
     # calls ->send
     $timer_fired->recv;
  
  Example: wait for a timer, but take advantage of the fact that condition
  variables are also callable directly.
  
     my $done = AnyEvent->condvar;
     my $delay = AnyEvent->timer (after => 5, cb => $done);
     $done->recv;
  
  Example: Imagine an API that returns a condvar and doesn't support
  callbacks. This is how you make a synchronous call, for example from
  the main program:
  
     use AnyEvent::CouchDB;
  
     ...
  
     my @info = $couchdb->info->recv;
  
  And this is how you would just set a callback to be called whenever the
  results are available:
  
     $couchdb->info->cb (sub {
        my @info = $_[0]->recv;
     });
  
  =head3 METHODS FOR PRODUCERS
  
  These methods should only be used by the producing side, i.e. the
  code/module that eventually sends the signal. Note that it is also
  the producer side which creates the condvar in most cases, but it isn't
  uncommon for the consumer to create it as well.
  
  =over 4
  
  =item $cv->send (...)
  
  Flag the condition as ready - a running C<< ->recv >> and all further
  calls to C<recv> will (eventually) return after this method has been
  called. If nobody is waiting the send will be remembered.
  
  If a callback has been set on the condition variable, it is called
  immediately from within send.
  
  Any arguments passed to the C<send> call will be returned by all
  future C<< ->recv >> calls.
  
  Condition variables are overloaded so one can call them directly (as if
  they were a code reference). Calling them directly is the same as calling
  C<send>.
  
  =item $cv->croak ($error)
  
  Similar to send, but causes all calls to C<< ->recv >> to invoke
  C<Carp::croak> with the given error message/object/scalar.
  
  This can be used to signal any errors to the condition variable
  user/consumer. Doing it this way instead of calling C<croak> directly
  delays the error detection, but has the overwhelming advantage that it
  diagnoses the error at the place where the result is expected, and not
  deep in some event callback with no connection to the actual code causing
  the problem.
  
  =item $cv->begin ([group callback])
  
  =item $cv->end
  
  These two methods can be used to combine many transactions/events into
  one. For example, a function that pings many hosts in parallel might want
  to use a condition variable for the whole process.
  
  Every call to C<< ->begin >> will increment a counter, and every call to
  C<< ->end >> will decrement it.  If the counter reaches C<0> in C<< ->end
  >>, the (last) callback passed to C<begin> will be executed, passing the
  condvar as first argument. That callback is I<supposed> to call C<< ->send
  >>, but that is not required. If no group callback was set, C<send> will
  be called without any arguments.
  
  You can think of C<< $cv->send >> giving you an OR condition (one call
  sends), while C<< $cv->begin >> and C<< $cv->end >> giving you an AND
  condition (all C<begin> calls must be C<end>'ed before the condvar sends).
  
  Let's start with a simple example: you have two I/O watchers (for example,
  STDOUT and STDERR for a program), and you want to wait for both streams to
  close before activating a condvar:
  
     my $cv = AnyEvent->condvar;
  
     $cv->begin; # first watcher
     my $w1 = AnyEvent->io (fh => $fh1, cb => sub {
        defined sysread $fh1, my $buf, 4096
           or $cv->end;
     });
  
     $cv->begin; # second watcher
     my $w2 = AnyEvent->io (fh => $fh2, cb => sub {
        defined sysread $fh2, my $buf, 4096
           or $cv->end;
     });
  
     $cv->recv;
  
  This works because for every event source (EOF on file handle), there is
  one call to C<begin>, so the condvar waits for all calls to C<end> before
  sending.
  
  The ping example mentioned above is slightly more complicated, as the
  there are results to be passed back, and the number of tasks that are
  begun can potentially be zero:
  
     my $cv = AnyEvent->condvar;
  
     my %result;
     $cv->begin (sub { shift->send (\%result) });
  
     for my $host (@list_of_hosts) {
        $cv->begin;
        ping_host_then_call_callback $host, sub {
           $result{$host} = ...;
           $cv->end;
        };
     }
  
     $cv->end;
  
     ...
  
     my $results = $cv->recv;
  
  This code fragment supposedly pings a number of hosts and calls
  C<send> after results for all then have have been gathered - in any
  order. To achieve this, the code issues a call to C<begin> when it starts
  each ping request and calls C<end> when it has received some result for
  it. Since C<begin> and C<end> only maintain a counter, the order in which
  results arrive is not relevant.
  
  There is an additional bracketing call to C<begin> and C<end> outside the
  loop, which serves two important purposes: first, it sets the callback
  to be called once the counter reaches C<0>, and second, it ensures that
  C<send> is called even when C<no> hosts are being pinged (the loop
  doesn't execute once).
  
  This is the general pattern when you "fan out" into multiple (but
  potentially zero) subrequests: use an outer C<begin>/C<end> pair to set
  the callback and ensure C<end> is called at least once, and then, for each
  subrequest you start, call C<begin> and for each subrequest you finish,
  call C<end>.
  
  =back
  
  =head3 METHODS FOR CONSUMERS
  
  These methods should only be used by the consuming side, i.e. the
  code awaits the condition.
  
  =over 4
  
  =item $cv->recv
  
  Wait (blocking if necessary) until the C<< ->send >> or C<< ->croak
  >> methods have been called on C<$cv>, while servicing other watchers
  normally.
  
  You can only wait once on a condition - additional calls are valid but
  will return immediately.
  
  If an error condition has been set by calling C<< ->croak >>, then this
  function will call C<croak>.
  
  In list context, all parameters passed to C<send> will be returned,
  in scalar context only the first one will be returned.
  
  Note that doing a blocking wait in a callback is not supported by any
  event loop, that is, recursive invocation of a blocking C<< ->recv >> is
  not allowed and the C<recv> call will C<croak> if such a condition is
  detected. This requirement can be dropped by relying on L<Coro::AnyEvent>
  , which allows you to do a blocking C<< ->recv >> from any thread
  that doesn't run the event loop itself. L<Coro::AnyEvent> is loaded
  automatically when L<Coro> is used with L<AnyEvent>, so code does not need
  to do anything special to take advantage of that: any code that would
  normally block your program because it calls C<recv>, be executed in an
  C<async> thread instead without blocking other threads.
  
  Not all event models support a blocking wait - some die in that case
  (programs might want to do that to stay interactive), so I<if you are
  using this from a module, never require a blocking wait>. Instead, let the
  caller decide whether the call will block or not (for example, by coupling
  condition variables with some kind of request results and supporting
  callbacks so the caller knows that getting the result will not block,
  while still supporting blocking waits if the caller so desires).
  
  You can ensure that C<< ->recv >> never blocks by setting a callback and
  only calling C<< ->recv >> from within that callback (or at a later
  time). This will work even when the event loop does not support blocking
  waits otherwise.
  
  =item $bool = $cv->ready
  
  Returns true when the condition is "true", i.e. whether C<send> or
  C<croak> have been called.
  
  =item $cb = $cv->cb ($cb->($cv))
  
  This is a mutator function that returns the callback set (or C<undef> if
  not) and optionally replaces it before doing so.
  
  The callback will be called when the condition becomes "true", i.e. when
  C<send> or C<croak> are called, with the only argument being the
  condition variable itself. If the condition is already true, the
  callback is called immediately when it is set. Calling C<recv> inside
  the callback or at any later time is guaranteed not to block.
  
  Additionally, when the callback is invoked, it is also removed from the
  condvar (reset to C<undef>), so the condvar does not keep a reference to
  the callback after invocation.
  
  =back
  
  =head1 SUPPORTED EVENT LOOPS/BACKENDS
  
  The following backend classes are part of the AnyEvent distribution (every
  class has its own manpage):
  
  =over 4
  
  =item Backends that are autoprobed when no other event loop can be found.
  
  EV is the preferred backend when no other event loop seems to be in
  use. If EV is not installed, then AnyEvent will fall back to its own
  pure-perl implementation, which is available everywhere as it comes with
  AnyEvent itself.
  
     AnyEvent::Impl::EV        based on EV (interface to libev, best choice).
     AnyEvent::Impl::Perl      pure-perl AnyEvent::Loop, fast and portable.
  
  =item Backends that are transparently being picked up when they are used.
  
  These will be used if they are already loaded when the first watcher
  is created, in which case it is assumed that the application is using
  them. This means that AnyEvent will automatically pick the right backend
  when the main program loads an event module before anything starts to
  create watchers. Nothing special needs to be done by the main program.
  
     AnyEvent::Impl::Event     based on Event, very stable, few glitches.
     AnyEvent::Impl::Glib      based on Glib, slow but very stable.
     AnyEvent::Impl::Tk        based on Tk, very broken.
     AnyEvent::Impl::UV        based on UV, innovated square wheels.
     AnyEvent::Impl::EventLib  based on Event::Lib, leaks memory and worse.
     AnyEvent::Impl::POE       based on POE, very slow, some limitations.
     AnyEvent::Impl::Irssi     used when running within irssi.
     AnyEvent::Impl::IOAsync   based on IO::Async.
     AnyEvent::Impl::Cocoa     based on Cocoa::EventLoop.
     AnyEvent::Impl::FLTK      based on FLTK (fltk 2 binding).
  
  =item Backends with special needs.
  
  Qt requires the Qt::Application to be instantiated first, but will
  otherwise be picked up automatically. As long as the main program
  instantiates the application before any AnyEvent watchers are created,
  everything should just work.
  
     AnyEvent::Impl::Qt        based on Qt.
  
  =item Event loops that are indirectly supported via other backends.
  
  Some event loops can be supported via other modules:
  
  There is no direct support for WxWidgets (L<Wx>) or L<Prima>.
  
  B<WxWidgets> has no support for watching file handles. However, you can
  use WxWidgets through the POE adaptor, as POE has a Wx backend that simply
  polls 20 times per second, which was considered to be too horrible to even
  consider for AnyEvent.
  
  B<Prima> is not supported as nobody seems to be using it, but it has a POE
  backend, so it can be supported through POE.
  
  AnyEvent knows about both L<Prima> and L<Wx>, however, and will try to
  load L<POE> when detecting them, in the hope that POE will pick them up,
  in which case everything will be automatic.
  
  =item Known event loops outside the AnyEvent distribution
  
  The following event loops or programs support AnyEvent by providing their
  own AnyEvent backend. They will be picked up automatically.
  
     urxvt::anyevent           available to rxvt-unicode extensions
  
  =back
  
  =head1 GLOBAL VARIABLES AND FUNCTIONS
  
  These are not normally required to use AnyEvent, but can be useful to
  write AnyEvent extension modules.
  
  =over 4
  
  =item $AnyEvent::MODEL
  
  Contains C<undef> until the first watcher is being created, before the
  backend has been autodetected.
  
  Afterwards it contains the event model that is being used, which is the
  name of the Perl class implementing the model. This class is usually one
  of the C<AnyEvent::Impl::xxx> modules, but can be any other class in the
  case AnyEvent has been extended at runtime (e.g. in I<rxvt-unicode> it
  will be C<urxvt::anyevent>).
  
  =item AnyEvent::detect
  
  Returns C<$AnyEvent::MODEL>, forcing autodetection of the event model
  if necessary. You should only call this function right before you would
  have created an AnyEvent watcher anyway, that is, as late as possible at
  runtime, and not e.g. during initialisation of your module.
  
  The effect of calling this function is as if a watcher had been created
  (specifically, actions that happen "when the first watcher is created"
  happen when calling detetc as well).
  
  If you need to do some initialisation before AnyEvent watchers are
  created, use C<post_detect>.
  
  =item $guard = AnyEvent::post_detect { BLOCK }
  
  Arranges for the code block to be executed as soon as the event model is
  autodetected (or immediately if that has already happened).
  
  The block will be executed I<after> the actual backend has been detected
  (C<$AnyEvent::MODEL> is set), so it is possible to do some initialisation
  only when AnyEvent is actually initialised - see the sources of
  L<AnyEvent::AIO> to see how this is used.
  
  The most common usage is to create some global watchers, without forcing
  event module detection too early. For example, L<AnyEvent::AIO> creates
  and installs the global L<IO::AIO> watcher in a C<post_detect> block to
  avoid autodetecting the event module at load time.
  
  If called in scalar or list context, then it creates and returns an object
  that automatically removes the callback again when it is destroyed (or
  C<undef> when the hook was immediately executed). See L<AnyEvent::AIO> for
  a case where this is useful.
  
  Example: Create a watcher for the IO::AIO module and store it in
  C<$WATCHER>, but do so only do so after the event loop is initialised.
  
     our WATCHER;
  
     my $guard = AnyEvent::post_detect {
        $WATCHER = AnyEvent->io (fh => IO::AIO::poll_fileno, poll => 'r', cb => \&IO::AIO::poll_cb);
     };
  
     # the ||= is important in case post_detect immediately runs the block,
     # as to not clobber the newly-created watcher. assigning both watcher and
     # post_detect guard to the same variable has the advantage of users being
     # able to just C<undef $WATCHER> if the watcher causes them grief.
  
     $WATCHER ||= $guard;
  
  =item @AnyEvent::post_detect
  
  This is a lower level interface then C<AnyEvent::post_detect> (the
  function). This variable is mainly useful for modules that can do
  something useful when AnyEvent is used and thus want to know when it
  is initialised, but do not need to even load it by default. This array
  provides the means to hook into AnyEvent passively, without loading it.
  
  Here is how it works: If there are any code references in this array (you
  can C<push> to it before or after loading AnyEvent), then they will be
  called directly after the event loop has been chosen.
  
  You should check C<$AnyEvent::MODEL> before adding to this array, though:
  if it is defined then the event loop has already been detected, and the
  array will be ignored.
  
  Best use C<AnyEvent::post_detect { BLOCK }> when your application allows
  it, as it takes care of these details.
  
  Example: To load Coro::AnyEvent whenever Coro and AnyEvent are used
  together, you could put this into Coro (this is the actual code used by
  Coro to accomplish this):
  
     if (defined $AnyEvent::MODEL) {
        # AnyEvent already initialised, so load Coro::AnyEvent
        require Coro::AnyEvent;
     } else {
        # AnyEvent not yet initialised, so make sure to load Coro::AnyEvent
        # as soon as it is
        push @AnyEvent::post_detect, sub { require Coro::AnyEvent };
     }
  
  =item AnyEvent::postpone { BLOCK }
  
  Arranges for the block to be executed as soon as possible, but not before
  the call itself returns. In practise, the block will be executed just
  before the event loop polls for new events, or shortly afterwards.
  
  This function never returns anything (to make the C<return postpone { ...
  }> idiom more useful.
  
  To understand the usefulness of this function, consider a function that
  asynchronously does something for you and returns some transaction
  object or guard to let you cancel the operation. For example,
  C<AnyEvent::Socket::tcp_connect>:
  
     # start a connection attempt unless one is active
     $self->{connect_guard} ||= AnyEvent::Socket::tcp_connect "www.example.net", 80, sub {
        delete $self->{connect_guard};
        ...
     };
  
  Imagine that this function could instantly call the callback, for
  example, because it detects an obvious error such as a negative port
  number. Invoking the callback before the function returns causes problems
  however: the callback will be called and will try to delete the guard
  object. But since the function hasn't returned yet, there is nothing to
  delete. When the function eventually returns it will assign the guard
  object to C<< $self->{connect_guard} >>, where it will likely never be
  deleted, so the program thinks it is still trying to connect.
  
  This is where C<AnyEvent::postpone> should be used. Instead of calling the
  callback directly on error:
  
     $cb->(undef), return # signal error to callback, BAD!
        if $some_error_condition;
  
  It should use C<postpone>:
  
     AnyEvent::postpone { $cb->(undef) }, return # signal error to callback, later
        if $some_error_condition;
  
  =item AnyEvent::log $level, $msg[, @args]
  
  Log the given C<$msg> at the given C<$level>.
  
  If L<AnyEvent::Log> is not loaded then this function makes a simple test
  to see whether the message will be logged. If the test succeeds it will
  load AnyEvent::Log and call C<AnyEvent::Log::log> - consequently, look at
  the L<AnyEvent::Log> documentation for details.
  
  If the test fails it will simply return. Right now this happens when a
  numerical loglevel is used and it is larger than the level specified via
  C<$ENV{PERL_ANYEVENT_VERBOSE}>.
  
  If you want to sprinkle loads of logging calls around your code, consider
  creating a logger callback with the C<AnyEvent::Log::logger> function,
  which can reduce typing, codesize and can reduce the logging overhead
  enourmously.
  
  =item AnyEvent::fh_block $filehandle
  
  =item AnyEvent::fh_unblock $filehandle
  
  Sets blocking or non-blocking behaviour for the given filehandle.
  
  =back
  
  =head1 WHAT TO DO IN A MODULE
  
  As a module author, you should C<use AnyEvent> and call AnyEvent methods
  freely, but you should not load a specific event module or rely on it.
  
  Be careful when you create watchers in the module body - AnyEvent will
  decide which event module to use as soon as the first method is called, so
  by calling AnyEvent in your module body you force the user of your module
  to load the event module first.
  
  Never call C<< ->recv >> on a condition variable unless you I<know> that
  the C<< ->send >> method has been called on it already. This is
  because it will stall the whole program, and the whole point of using
  events is to stay interactive.
  
  It is fine, however, to call C<< ->recv >> when the user of your module
  requests it (i.e. if you create a http request object ad have a method
  called C<results> that returns the results, it may call C<< ->recv >>
  freely, as the user of your module knows what she is doing. Always).
  
  =head1 WHAT TO DO IN THE MAIN PROGRAM
  
  There will always be a single main program - the only place that should
  dictate which event model to use.
  
  If the program is not event-based, it need not do anything special, even
  when it depends on a module that uses an AnyEvent. If the program itself
  uses AnyEvent, but does not care which event loop is used, all it needs
  to do is C<use AnyEvent>. In either case, AnyEvent will choose the best
  available loop implementation.
  
  If the main program relies on a specific event model - for example, in
  Gtk2 programs you have to rely on the Glib module - you should load the
  event module before loading AnyEvent or any module that uses it: generally
  speaking, you should load it as early as possible. The reason is that
  modules might create watchers when they are loaded, and AnyEvent will
  decide on the event model to use as soon as it creates watchers, and it
  might choose the wrong one unless you load the correct one yourself.
  
  You can chose to use a pure-perl implementation by loading the
  C<AnyEvent::Loop> module, which gives you similar behaviour
  everywhere, but letting AnyEvent chose the model is generally better.
  
  =head2 MAINLOOP EMULATION
  
  Sometimes (often for short test scripts, or even standalone programs who
  only want to use AnyEvent), you do not want to run a specific event loop.
  
  In that case, you can use a condition variable like this:
  
     AnyEvent->condvar->recv;
  
  This has the effect of entering the event loop and looping forever.
  
  Note that usually your program has some exit condition, in which case
  it is better to use the "traditional" approach of storing a condition
  variable somewhere, waiting for it, and sending it when the program should
  exit cleanly.
  
  
  =head1 OTHER MODULES
  
  The following is a non-exhaustive list of additional modules that use
  AnyEvent as a client and can therefore be mixed easily with other
  AnyEvent modules and other event loops in the same program. Some of the
  modules come as part of AnyEvent, the others are available via CPAN (see
  L<http://search.cpan.org/search?m=module&q=anyevent%3A%3A*> for
  a longer non-exhaustive list), and the list is heavily biased towards
  modules of the AnyEvent author himself :)
  
  =over 4
  
  =item L<AnyEvent::Util> (part of the AnyEvent distribution)
  
  Contains various utility functions that replace often-used blocking
  functions such as C<inet_aton> with event/callback-based versions.
  
  =item L<AnyEvent::Socket> (part of the AnyEvent distribution)
  
  Provides various utility functions for (internet protocol) sockets,
  addresses and name resolution. Also functions to create non-blocking tcp
  connections or tcp servers, with IPv6 and SRV record support and more.
  
  =item L<AnyEvent::Handle> (part of the AnyEvent distribution)
  
  Provide read and write buffers, manages watchers for reads and writes,
  supports raw and formatted I/O, I/O queued and fully transparent and
  non-blocking SSL/TLS (via L<AnyEvent::TLS>).
  
  =item L<AnyEvent::DNS> (part of the AnyEvent distribution)
  
  Provides rich asynchronous DNS resolver capabilities.
  
  =item L<AnyEvent::HTTP>, L<AnyEvent::IRC>, L<AnyEvent::XMPP>, L<AnyEvent::GPSD>, L<AnyEvent::IGS>, L<AnyEvent::FCP>
  
  Implement event-based interfaces to the protocols of the same name (for
  the curious, IGS is the International Go Server and FCP is the Freenet
  Client Protocol).
  
  =item L<AnyEvent::AIO> (part of the AnyEvent distribution)
  
  Truly asynchronous (as opposed to non-blocking) I/O, should be in the
  toolbox of every event programmer. AnyEvent::AIO transparently fuses
  L<IO::AIO> and AnyEvent together, giving AnyEvent access to event-based
  file I/O, and much more.
  
  =item L<AnyEvent::Fork>, L<AnyEvent::Fork::RPC>, L<AnyEvent::Fork::Pool>, L<AnyEvent::Fork::Remote>
  
  These let you safely fork new subprocesses, either locally or
  remotely (e.g.v ia ssh), using some RPC protocol or not, without
  the limitations normally imposed by fork (AnyEvent works fine for
  example). Dynamically-resized worker pools are obviously included as well.
  
  And they are quite tiny and fast as well - "abusing" L<AnyEvent::Fork>
  just to exec external programs can easily beat using C<fork> and C<exec>
  (or even C<system>) in most programs.
  
  =item L<AnyEvent::Filesys::Notify>
  
  AnyEvent is good for non-blocking stuff, but it can't detect file or
  path changes (e.g. "watch this directory for new files", "watch this
  file for changes"). The L<AnyEvent::Filesys::Notify> module promises to
  do just that in a portbale fashion, supporting inotify on GNU/Linux and
  some weird, without doubt broken, stuff on OS X to monitor files. It can
  fall back to blocking scans at regular intervals transparently on other
  platforms, so it's about as portable as it gets.
  
  (I haven't used it myself, but it seems the biggest problem with it is
  it quite bad performance).
  
  =item L<AnyEvent::DBI>
  
  Executes L<DBI> requests asynchronously in a proxy process for you,
  notifying you in an event-based way when the operation is finished.
  
  =item L<AnyEvent::FastPing>
  
  The fastest ping in the west.
  
  =item L<Coro>
  
  Has special support for AnyEvent via L<Coro::AnyEvent>, which allows you
  to simply invert the flow control - don't call us, we will call you:
  
     async {
        Coro::AnyEvent::sleep 5; # creates a 5s timer and waits for it
        print "5 seconds later!\n";
  
        Coro::AnyEvent::readable *STDIN; # uses an I/O watcher
        my $line = <STDIN>; # works for ttys
  
        AnyEvent::HTTP::http_get "url", Coro::rouse_cb;
        my ($body, $hdr) = Coro::rouse_wait;
     };
  
  =back
  
  =cut
  
  package AnyEvent;
  
  BEGIN {
     require "AnyEvent/constants.pm";
     &AnyEvent::common_sense;
  }
  
  use Carp ();
  
  our $VERSION = 7.17;
  our $MODEL;
  our @ISA;
  our @REGISTRY;
  our $VERBOSE;
  our %PROTOCOL; # (ipv4|ipv6) => (1|2), higher numbers are preferred
  our $MAX_SIGNAL_LATENCY = $ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY} || 10; # executes after the BEGIN block below (tainting!)
  
  BEGIN {
     eval "sub TAINT (){" . (${^TAINT}*1) . "}";
  
     delete @ENV{grep /^PERL_ANYEVENT_/, keys %ENV}
        if ${^TAINT};
  
     $ENV{"PERL_ANYEVENT_$_"} = $ENV{"AE_$_"}
        for grep s/^AE_// && !exists $ENV{"PERL_ANYEVENT_$_"}, keys %ENV;
  
     @ENV{grep /^PERL_ANYEVENT_/, keys %ENV} = ()
        if ${^TAINT};
  
     # $ENV{PERL_ANYEVENT_xxx} now valid
  
     $VERBOSE = length $ENV{PERL_ANYEVENT_VERBOSE} ? $ENV{PERL_ANYEVENT_VERBOSE}*1 : 4;
  
     my $idx;
     $PROTOCOL{$_} = ++$idx
        for reverse split /\s*,\s*/,
               $ENV{PERL_ANYEVENT_PROTOCOLS} || "ipv4,ipv6";
  }
  
  our @post_detect;
  
  sub post_detect(&) {
     my ($cb) = @_;
  
     push @post_detect, $cb;
  
     defined wantarray
        ? bless \$cb, "AnyEvent::Util::postdetect"
        : ()
  }
  
  sub AnyEvent::Util::postdetect::DESTROY {
     @post_detect = grep $_ != ${$_[0]}, @post_detect;
  }
  
  our $POSTPONE_W;
  our @POSTPONE;
  
  sub _postpone_exec {
     undef $POSTPONE_W;
  
     &{ shift @POSTPONE }
        while @POSTPONE;
  }
  
  sub postpone(&) {
     push @POSTPONE, shift;
  
     $POSTPONE_W ||= AE::timer (0, 0, \&_postpone_exec);
  
     ()
  }
  
  sub log($$;@) {
     # only load the big bloated module when we actually are about to log something
     if ($_[0] <= ($VERBOSE || 1)) { # also catches non-numeric levels(!) and fatal
        local ($!, $@);
        require AnyEvent::Log; # among other things, sets $VERBOSE to 9
        # AnyEvent::Log overwrites this function
        goto &log;
     }
  
     0 # not logged
  }
  
  sub _logger($;$) {
     my ($level, $renabled) = @_;
  
     $$renabled = $level <= $VERBOSE;
  
     my $logger = [(caller)[0], $level, $renabled];
  
     $AnyEvent::Log::LOGGER{$logger+0} = $logger;
  
  #   return unless defined wantarray;
  # 
  #   require AnyEvent::Util;
  #   my $guard = AnyEvent::Util::guard (sub {
  #      # "clean up"
  #      delete $LOGGER{$logger+0};
  #   });
  # 
  #   sub {
  #      return 0 unless $$renabled;
  # 
  #      $guard if 0; # keep guard alive, but don't cause runtime overhead
  #      require AnyEvent::Log unless $AnyEvent::Log::VERSION;
  #      package AnyEvent::Log;
  #      _log ($logger->[0], $level, @_) # logger->[0] has been converted at load time
  #   }
  }
  
  if (length $ENV{PERL_ANYEVENT_LOG}) {
     require AnyEvent::Log; # AnyEvent::Log does the thing for us
  }
  
  BEGIN {
     *_fh_nonblocking = AnyEvent::WIN32
        ? sub($$) {
            ioctl $_[0], 0x8004667e, pack "L", $_[1]; # FIONBIO
          }
        : sub($$) {
            fcntl $_[0], AnyEvent::F_SETFL, $_[1] ? AnyEvent::O_NONBLOCK : 0;
          }
     ;
  }
  
  sub fh_block($) {
     _fh_nonblocking shift, 0
  }
  
  sub fh_unblock($) {
     _fh_nonblocking shift, 1
  }
  
  our @models = (
     [EV::                   => AnyEvent::Impl::EV::],
     [AnyEvent::Loop::       => AnyEvent::Impl::Perl::],
     # everything below here will not (normally) be autoprobed
     # as the pure perl backend should work everywhere
     # and is usually faster
     [Irssi::                => AnyEvent::Impl::Irssi::],    # Irssi has a bogus "Event" package, so msut be near the top
     [Event::                => AnyEvent::Impl::Event::],    # slow, stable
     [Glib::                 => AnyEvent::Impl::Glib::],     # becomes extremely slow with many watchers
     # everything below here should not be autoloaded
     [Event::Lib::           => AnyEvent::Impl::EventLib::], # too buggy
     [Tk::                   => AnyEvent::Impl::Tk::],       # crashes with many handles
     [UV::                   => AnyEvent::Impl::UV::],       # switched from libev, added back all bugs imaginable
     [Qt::                   => AnyEvent::Impl::Qt::],       # requires special main program
     [POE::Kernel::          => AnyEvent::Impl::POE::],      # lasciate ogni speranza
     [Wx::                   => AnyEvent::Impl::POE::],
     [Prima::                => AnyEvent::Impl::POE::],
     [IO::Async::Loop::      => AnyEvent::Impl::IOAsync::],  # a bitch to autodetect
     [Cocoa::EventLoop::     => AnyEvent::Impl::Cocoa::],
     [FLTK::                 => AnyEvent::Impl::FLTK::],
  );
  
  our @isa_hook;
  
  sub _isa_set {
     my @pkg = ("AnyEvent", (map $_->[0], grep defined, @isa_hook), $MODEL);
  
     @{"$pkg[$_-1]::ISA"} = $pkg[$_]
        for 1 .. $#pkg;
  
     grep $_ && $_->[1], @isa_hook
        and AE::_reset ();
  }
  
  # used for hooking AnyEvent::Strict and AnyEvent::Debug::Wrap into the class hierarchy
  sub _isa_hook($$;$) {
     my ($i, $pkg, $reset_ae) = @_;
  
     $isa_hook[$i] = $pkg ? [$pkg, $reset_ae] : undef;
  
     _isa_set;
  }
  
  # all autoloaded methods reserve the complete glob, not just the method slot.
  # due to bugs in perls method cache implementation.
  our @methods = qw(io timer time now now_update signal child idle condvar);
  
  sub detect() {
     return $MODEL if $MODEL; # some programs keep references to detect
  
     # IO::Async::Loop::AnyEvent is extremely evil, refuse to work with it
     # the author knows about the problems and what it does to AnyEvent as a whole
     # (and the ability of others to use AnyEvent), but simply wants to abuse AnyEvent
     # anyway.
     AnyEvent::log fatal => "IO::Async::Loop::AnyEvent detected - that module is broken by\n"
                          . "design, abuses internals and breaks AnyEvent - will not continue."
        if exists $INC{"IO/Async/Loop/AnyEvent.pm"};
  
     local $!; # for good measure
     local $SIG{__DIE__}; # we use eval
  
     # free some memory
     *detect = sub () { $MODEL };
     # undef &func doesn't correctly update the method cache. grmbl.
     # so we delete the whole glob. grmbl.
     # otoh, perl doesn't let me undef an active usb, but it lets me free
     # a glob with an active sub. hrm. i hope it works, but perl is
     # usually buggy in this department. sigh.
     delete @{"AnyEvent::"}{@methods};
     undef @methods;
  
     if ($ENV{PERL_ANYEVENT_MODEL} =~ /^([a-zA-Z0-9:]+)$/) {
        my $model = $1;
        $model = "AnyEvent::Impl::$model" unless $model =~ s/::$//;
        if (eval "require $model") {
           AnyEvent::log 7 => "Loaded model '$model' (forced by \$ENV{PERL_ANYEVENT_MODEL}), using it.";
           $MODEL = $model;
        } else {
           AnyEvent::log 4 => "Unable to load model '$model' (from \$ENV{PERL_ANYEVENT_MODEL}):\n$@";
        }
     }
  
     # check for already loaded models
     unless ($MODEL) {
        for (@REGISTRY, @models) {
           my ($package, $model) = @$_;
           if (${"$package\::VERSION"} > 0) {
              if (eval "require $model") {
                 AnyEvent::log 7 => "Autodetected model '$model', using it.";
                 $MODEL = $model;
                 last;
              } else {
                 AnyEvent::log 8 => "Detected event loop $package, but cannot load '$model', skipping: $@";
              }
           }
        }
  
        unless ($MODEL) {
           # try to autoload a model
           for (@REGISTRY, @models) {
              my ($package, $model) = @$_;
              if (
                 eval "require $package"
                 and ${"$package\::VERSION"} > 0
                 and eval "require $model"
              ) {
                 AnyEvent::log 7 => "Autoloaded model '$model', using it.";
                 $MODEL = $model;
                 last;
              }
           }
  
           $MODEL
             or AnyEvent::log fatal => "Backend autodetection failed - did you properly install AnyEvent?";
        }
     }
  
     # free memory only needed for probing
     undef @models;
     undef @REGISTRY;
  
     push @{"$MODEL\::ISA"}, "AnyEvent::Base";
  
     # now nuke some methods that are overridden by the backend.
     # SUPER usage is not allowed in these.
     for (qw(time signal child idle)) {
        undef &{"AnyEvent::Base::$_"}
           if defined &{"$MODEL\::$_"};
     }
  
     _isa_set;
  
     # we're officially open!
  
     if ($ENV{PERL_ANYEVENT_STRICT}) {
        require AnyEvent::Strict;
     }
  
     if ($ENV{PERL_ANYEVENT_DEBUG_WRAP}) {
        require AnyEvent::Debug;
        AnyEvent::Debug::wrap ($ENV{PERL_ANYEVENT_DEBUG_WRAP});
     }
  
     if (length $ENV{PERL_ANYEVENT_DEBUG_SHELL}) {
        require AnyEvent::Socket;
        require AnyEvent::Debug;
  
        my $shell = $ENV{PERL_ANYEVENT_DEBUG_SHELL};
        $shell =~ s/\$\$/$$/g;
  
        my ($host, $service) = AnyEvent::Socket::parse_hostport ($shell);
        $AnyEvent::Debug::SHELL = AnyEvent::Debug::shell ($host, $service);
     }
  
     # now the anyevent environment is set up as the user told us to, so
     # call the actual user code - post detects
  
     (shift @post_detect)->() while @post_detect;
     undef @post_detect;
  
     *post_detect = sub(&) {
        shift->();
  
        undef
     };
  
     $MODEL
  }
  
  for my $name (@methods) {
     *$name = sub {
        detect;
        # we use goto because
        # a) it makes the thunk more transparent
        # b) it allows us to delete the thunk later
        goto &{ UNIVERSAL::can AnyEvent => "SUPER::$name" }
     };
  }
  
  # utility function to dup a filehandle. this is used by many backends
  # to support binding more than one watcher per filehandle (they usually
  # allow only one watcher per fd, so we dup it to get a different one).
  sub _dupfh($$;$$) {
     my ($poll, $fh, $r, $w) = @_;
  
     # cygwin requires the fh mode to be matching, unix doesn't
     my ($rw, $mode) = $poll eq "r" ? ($r, "<&") : ($w, ">&");
  
     open my $fh2, $mode, $fh
        or die "AnyEvent->io: cannot dup() filehandle in mode '$poll': $!,";
  
     # we assume CLOEXEC is already set by perl in all important cases
  
     ($fh2, $rw)
  }
  
  =head1 SIMPLIFIED AE API
  
  Starting with version 5.0, AnyEvent officially supports a second, much
  simpler, API that is designed to reduce the calling, typing and memory
  overhead by using function call syntax and a fixed number of parameters.
  
  See the L<AE> manpage for details.
  
  =cut
  
  package AE;
  
  our $VERSION = $AnyEvent::VERSION;
  
  sub _reset() {
     eval q{
        # fall back to the main API by default - backends and AnyEvent::Base
        # implementations can overwrite these.
  
        sub io($$$) {
           AnyEvent->io (fh => $_[0], poll => $_[1] ? "w" : "r", cb => $_[2])
        }
  
        sub timer($$$) {
           AnyEvent->timer (after => $_[0], interval => $_[1], cb => $_[2])
        }
  
        sub signal($$) {
           AnyEvent->signal (signal => $_[0], cb => $_[1])
        }
  
        sub child($$) {
           AnyEvent->child (pid => $_[0], cb => $_[1])
        }
  
        sub idle($) {
           AnyEvent->idle (cb => $_[0]);
        }
  
        sub cv(;&) {
           AnyEvent->condvar (@_ ? (cb => $_[0]) : ())
        }
  
        sub now() {
           AnyEvent->now
        }
  
        sub now_update() {
           AnyEvent->now_update
        }
  
        sub time() {
           AnyEvent->time
        }
  
        *postpone = \&AnyEvent::postpone;
        *log      = \&AnyEvent::log;
     };
     die if $@;
  }
  
  BEGIN { _reset }
  
  package AnyEvent::Base;
  
  # default implementations for many methods
  
  sub time {
     eval q{ # poor man's autoloading {}
        # probe for availability of Time::HiRes
        if (eval "use Time::HiRes (); Time::HiRes::time (); 1") {
           *time     = sub { Time::HiRes::time () };
           *AE::time = \&    Time::HiRes::time     ;
           *now      = \&time;
           AnyEvent::log 8 => "using Time::HiRes for sub-second timing accuracy.";
           # if (eval "use POSIX (); (POSIX::times())...
        } else {
           *time     = sub   { CORE::time };
           *AE::time = sub (){ CORE::time };
           *now      = \&time;
           AnyEvent::log 3 => "Using built-in time(), no sub-second resolution!";
        }
     };
     die if $@;
  
     &time
  }
  
  *now = \&time;
  sub now_update { }
  
  sub _poll {
     Carp::croak "$AnyEvent::MODEL does not support blocking waits. Caught";
  }
  
  # default implementation for ->condvar
  # in fact, the default should not be overwritten
  
  sub condvar {
     eval q{ # poor man's autoloading {}
        *condvar = sub {
           bless { @_ == 3 ? (_ae_cb => $_[2]) : () }, "AnyEvent::CondVar"
        };
  
        *AE::cv = sub (;&) {
           bless { @_ ? (_ae_cb => shift) : () }, "AnyEvent::CondVar"
        };
     };
     die if $@;
  
     &condvar
  }
  
  # default implementation for ->signal
  
  our $HAVE_ASYNC_INTERRUPT;
  
  sub _have_async_interrupt() {
     $HAVE_ASYNC_INTERRUPT = 1*(!$ENV{PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT}
                                && eval "use Async::Interrupt 1.02 (); 1")
        unless defined $HAVE_ASYNC_INTERRUPT;
  
     $HAVE_ASYNC_INTERRUPT
  }
  
  our ($SIGPIPE_R, $SIGPIPE_W, %SIG_CB, %SIG_EV, $SIG_IO);
  our (%SIG_ASY, %SIG_ASY_W);
  our ($SIG_COUNT, $SIG_TW);
  
  # install a dummy wakeup watcher to reduce signal catching latency
  # used by Impls
  sub _sig_add() {
     unless ($SIG_COUNT++) {
        # try to align timer on a full-second boundary, if possible
        my $NOW = AE::now;
  
        $SIG_TW = AE::timer
           $MAX_SIGNAL_LATENCY - ($NOW - int $NOW),
           $MAX_SIGNAL_LATENCY,
           sub { } # just for the PERL_ASYNC_CHECK
        ;
     }
  }
  
  sub _sig_del {
     undef $SIG_TW
        unless --$SIG_COUNT;
  }
  
  our $_sig_name_init; $_sig_name_init = sub {
     eval q{ # poor man's autoloading {}
        undef $_sig_name_init;
  
        if (_have_async_interrupt) {
           *sig2num  = \&Async::Interrupt::sig2num;
           *sig2name = \&Async::Interrupt::sig2name;
        } else {
           require Config;
  
           my %signame2num;
           @signame2num{ split ' ', $Config::Config{sig_name} }
                          = split ' ', $Config::Config{sig_num};
  
           my @signum2name;
           @signum2name[values %signame2num] = keys %signame2num;
  
           *sig2num = sub($) {
              $_[0] > 0 ? shift : $signame2num{+shift}
           };
           *sig2name = sub ($) {
              $_[0] > 0 ? $signum2name[+shift] : shift
           };
        }
     };
     die if $@;
  };
  
  sub sig2num ($) { &$_sig_name_init; &sig2num  }
  sub sig2name($) { &$_sig_name_init; &sig2name }
  
  sub signal {
     eval q{ # poor man's autoloading {}
        # probe for availability of Async::Interrupt 
        if (_have_async_interrupt) {
           AnyEvent::log 8 => "Using Async::Interrupt for race-free signal handling.";
  
           $SIGPIPE_R = new Async::Interrupt::EventPipe;
           $SIG_IO = AE::io $SIGPIPE_R->fileno, 0, \&_signal_exec;
  
        } else {
           AnyEvent::log 8 => "Using emulated perl signal handling with latency timer.";
  
           if (AnyEvent::WIN32) {
              require AnyEvent::Util;
  
              ($SIGPIPE_R, $SIGPIPE_W) = AnyEvent::Util::portable_pipe ();
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_R, 1) if $SIGPIPE_R;
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_W, 1) if $SIGPIPE_W; # just in case
           } else {
              pipe $SIGPIPE_R, $SIGPIPE_W;
              fcntl $SIGPIPE_R, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_R;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_W; # just in case
  
              # not strictly required, as $^F is normally 2, but let's make sure...
              fcntl $SIGPIPE_R, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
           }
  
           $SIGPIPE_R
              or Carp::croak "AnyEvent: unable to create a signal reporting pipe: $!\n";
  
           $SIG_IO = AE::io $SIGPIPE_R, 0, \&_signal_exec;
        }
  
        *signal = $HAVE_ASYNC_INTERRUPT
           ? sub {
                my (undef, %arg) = @_;
  
                # async::interrupt
                my $signal = sig2num $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG_ASY{$signal} ||= new Async::Interrupt
                   cb             => sub { undef $SIG_EV{$signal} },
                   signal         => $signal,
                   pipe           => [$SIGPIPE_R->filenos],
                   pipe_autodrain => 0,
                ;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
           : sub {
                my (undef, %arg) = @_;
  
                # pure perl
                my $signal = sig2name $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG{$signal} ||= sub {
                   local $!;
                   syswrite $SIGPIPE_W, "\x00", 1 unless %SIG_EV;
                   undef $SIG_EV{$signal};
                };
  
                # can't do signal processing without introducing races in pure perl,
                # so limit the signal latency.
                _sig_add;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
        ;
  
        *AnyEvent::Base::signal::DESTROY = sub {
           my ($signal, $cb) = @{$_[0]};
  
           _sig_del;
  
           delete $SIG_CB{$signal}{$cb};
  
           $HAVE_ASYNC_INTERRUPT
              ? delete $SIG_ASY{$signal}
              : # delete doesn't work with older perls - they then
                # print weird messages, or just unconditionally exit
                # instead of getting the default action.
                undef $SIG{$signal}
              unless keys %{ $SIG_CB{$signal} };
        };
  
        *_signal_exec = sub {
           $HAVE_ASYNC_INTERRUPT
              ? $SIGPIPE_R->drain
              : sysread $SIGPIPE_R, (my $dummy), 9;
  
           while (%SIG_EV) {
              for (keys %SIG_EV) {
                 delete $SIG_EV{$_};
                 &$_ for values %{ $SIG_CB{$_} || {} };
              }
           }
        };
     };
     die if $@;
  
     &signal
  }
  
  # default implementation for ->child
  
  our %PID_CB;
  our $CHLD_W;
  our $CHLD_DELAY_W;
  
  # used by many Impl's
  sub _emit_childstatus($$) {
     my (undef, $rpid, $rstatus) = @_;
  
     $_->($rpid, $rstatus)
        for values %{ $PID_CB{$rpid} || {} },
            values %{ $PID_CB{0}     || {} };
  }
  
  sub child {
     eval q{ # poor man's autoloading {}
        *_sigchld = sub {
           my $pid;
  
           AnyEvent->_emit_childstatus ($pid, $?)
              while ($pid = waitpid -1, WNOHANG) > 0;
        };
  
        *child = sub {
           my (undef, %arg) = @_;
  
           my $pid = $arg{pid};
           my $cb  = $arg{cb};
  
           $PID_CB{$pid}{$cb+0} = $cb;
  
           unless ($CHLD_W) {
              $CHLD_W = AE::signal CHLD => \&_sigchld;
              # child could be a zombie already, so make at least one round
              &_sigchld;
           }
  
           bless [$pid, $cb+0], "AnyEvent::Base::child"
        };
  
        *AnyEvent::Base::child::DESTROY = sub {
           my ($pid, $icb) = @{$_[0]};
  
           delete $PID_CB{$pid}{$icb};
           delete $PID_CB{$pid} unless keys %{ $PID_CB{$pid} };
  
           undef $CHLD_W unless keys %PID_CB;
        };
     };
     die if $@;
  
     &child
  }
  
  # idle emulation is done by simply using a timer, regardless
  # of whether the process is idle or not, and not letting
  # the callback use more than 50% of the time.
  sub idle {
     eval q{ # poor man's autoloading {}
        *idle = sub {
           my (undef, %arg) = @_;
  
           my ($cb, $w, $rcb) = $arg{cb};
  
           $rcb = sub {
              if ($cb) {
                 $w = AE::time;
                 &$cb;
                 $w = AE::time - $w;
  
                 # never use more then 50% of the time for the idle watcher,
                 # within some limits
                 $w = 0.0001 if $w < 0.0001;
                 $w = 5      if $w > 5;
  
                 $w = AE::timer $w, 0, $rcb;
              } else {
                 # clean up...
                 undef $w;
                 undef $rcb;
              }
           };
  
           $w = AE::timer 0.05, 0, $rcb;
  
           bless \\$cb, "AnyEvent::Base::idle"
        };
  
        *AnyEvent::Base::idle::DESTROY = sub {
           undef $${$_[0]};
        };
     };
     die if $@;
  
     &idle
  }
  
  package AnyEvent::CondVar;
  
  our @ISA = AnyEvent::CondVar::Base::;
  
  # only to be used for subclassing
  sub new {
     my $class = shift;
     bless AnyEvent->condvar (@_), $class
  }
  
  package AnyEvent::CondVar::Base;
  
  #use overload
  #   '&{}'    => sub { my $self = shift; sub { $self->send (@_) } },
  #   fallback => 1;
  
  # save 300+ kilobytes by dirtily hardcoding overloading
  ${"AnyEvent::CondVar::Base::OVERLOAD"}{dummy}++; # Register with magic by touching.
  *{'AnyEvent::CondVar::Base::()'}   = sub { }; # "Make it findable via fetchmethod."
  *{'AnyEvent::CondVar::Base::(&{}'} = sub { my $self = shift; sub { $self->send (@_) } }; # &{}
  ${'AnyEvent::CondVar::Base::()'}   = 1; # fallback
  
  our $WAITING;
  
  sub _send {
     # nop
  }
  
  sub _wait {
     AnyEvent->_poll until $_[0]{_ae_sent};
  }
  
  sub send {
     my $cv = shift;
     $cv->{_ae_sent} = [@_];
     (delete $cv->{_ae_cb})->($cv) if $cv->{_ae_cb};
     $cv->_send;
  }
  
  sub croak {
     $_[0]{_ae_croak} = $_[1];
     $_[0]->send;
  }
  
  sub ready {
     $_[0]{_ae_sent}
  }
  
  sub recv {
     unless ($_[0]{_ae_sent}) {
        $WAITING
           and Carp::croak "AnyEvent::CondVar: recursive blocking wait attempted";
  
        local $WAITING = 1;
        $_[0]->_wait;
     }
  
     $_[0]{_ae_croak}
        and Carp::croak $_[0]{_ae_croak};
  
     wantarray
        ? @{ $_[0]{_ae_sent} }
        : $_[0]{_ae_sent}[0]
  }
  
  sub cb {
     my $cv = shift;
  
     @_
        and $cv->{_ae_cb} = shift
        and $cv->{_ae_sent}
        and (delete $cv->{_ae_cb})->($cv);
  
     $cv->{_ae_cb}
  }
  
  sub begin {
     ++$_[0]{_ae_counter};
     $_[0]{_ae_end_cb} = $_[1] if @_ > 1;
  }
  
  sub end {
     return if --$_[0]{_ae_counter};
     &{ $_[0]{_ae_end_cb} || sub { $_[0]->send } };
  }
  
  # undocumented/compatibility with pre-3.4
  *broadcast = \&send;
  *wait      = \&recv;
  
  =head1 ERROR AND EXCEPTION HANDLING
  
  In general, AnyEvent does not do any error handling - it relies on the
  caller to do that if required. The L<AnyEvent::Strict> module (see also
  the C<PERL_ANYEVENT_STRICT> environment variable, below) provides strict
  checking of all AnyEvent methods, however, which is highly useful during
  development.
  
  As for exception handling (i.e. runtime errors and exceptions thrown while
  executing a callback), this is not only highly event-loop specific, but
  also not in any way wrapped by this module, as this is the job of the main
  program.
  
  The pure perl event loop simply re-throws the exception (usually
  within C<< condvar->recv >>), the L<Event> and L<EV> modules call C<<
  $Event/EV::DIED->() >>, L<Glib> uses C<< install_exception_handler >> and
  so on.
  
  =head1 ENVIRONMENT VARIABLES
  
  AnyEvent supports a number of environment variables that tune the
  runtime behaviour. They are usually evaluated when AnyEvent is
  loaded, initialised, or a submodule that uses them is loaded. Many of
  them also cause AnyEvent to load additional modules - for example,
  C<PERL_ANYEVENT_DEBUG_WRAP> causes the L<AnyEvent::Debug> module to be
  loaded.
  
  All the environment variables documented here start with
  C<PERL_ANYEVENT_>, which is what AnyEvent considers its own
  namespace. Other modules are encouraged (but by no means required) to use
  C<PERL_ANYEVENT_SUBMODULE> if they have registered the AnyEvent::Submodule
  namespace on CPAN, for any submodule. For example, L<AnyEvent::HTTP> could
  be expected to use C<PERL_ANYEVENT_HTTP_PROXY> (it should not access env
  variables starting with C<AE_>, see below).
  
  All variables can also be set via the C<AE_> prefix, that is, instead
  of setting C<PERL_ANYEVENT_VERBOSE> you can also set C<AE_VERBOSE>. In
  case there is a clash btween anyevent and another program that uses
  C<AE_something> you can set the corresponding C<PERL_ANYEVENT_something>
  variable to the empty string, as those variables take precedence.
  
  When AnyEvent is first loaded, it copies all C<AE_xxx> env variables
  to their C<PERL_ANYEVENT_xxx> counterpart unless that variable already
  exists. If taint mode is on, then AnyEvent will remove I<all> environment
  variables starting with C<PERL_ANYEVENT_> from C<%ENV> (or replace them
  with C<undef> or the empty string, if the corresaponding C<AE_> variable
  is set).
  
  The exact algorithm is currently:
  
     1. if taint mode enabled, delete all PERL_ANYEVENT_xyz variables from %ENV
     2. copy over AE_xyz to PERL_ANYEVENT_xyz unless the latter alraedy exists
     3. if taint mode enabled, set all PERL_ANYEVENT_xyz variables to undef.
  
  This ensures that child processes will not see the C<AE_> variables.
  
  The following environment variables are currently known to AnyEvent:
  
  =over 4
  
  =item C<PERL_ANYEVENT_VERBOSE>
  
  By default, AnyEvent will log messages with loglevel C<4> (C<error>) or
  higher (see L<AnyEvent::Log>). You can set this environment variable to a
  numerical loglevel to make AnyEvent more (or less) talkative.
  
  If you want to do more than just set the global logging level
  you should have a look at C<PERL_ANYEVENT_LOG>, which allows much more
  complex specifications.
  
  When set to C<0> (C<off>), then no messages whatsoever will be logged with
  everything else at defaults.
  
  When set to C<5> or higher (C<warn>), AnyEvent warns about unexpected
  conditions, such as not being able to load the event model specified by
  C<PERL_ANYEVENT_MODEL>, or a guard callback throwing an exception - this
  is the minimum recommended level for use during development.
  
  When set to C<7> or higher (info), AnyEvent reports which event model it
  chooses.
  
  When set to C<8> or higher (debug), then AnyEvent will report extra
  information on which optional modules it loads and how it implements
  certain features.
  
  =item C<PERL_ANYEVENT_LOG>
  
  Accepts rather complex logging specifications. For example, you could log
  all C<debug> messages of some module to stderr, warnings and above to
  stderr, and errors and above to syslog, with:
  
     PERL_ANYEVENT_LOG=Some::Module=debug,+log:filter=warn,+%syslog:%syslog=error,syslog
  
  For the rather extensive details, see L<AnyEvent::Log>.
  
  This variable is evaluated when AnyEvent (or L<AnyEvent::Log>) is loaded,
  so will take effect even before AnyEvent has initialised itself.
  
  Note that specifying this environment variable causes the L<AnyEvent::Log>
  module to be loaded, while C<PERL_ANYEVENT_VERBOSE> does not, so only
  using the latter saves a few hundred kB of memory unless a module
  explicitly needs the extra features of AnyEvent::Log.
  
  =item C<PERL_ANYEVENT_STRICT>
  
  AnyEvent does not do much argument checking by default, as thorough
  argument checking is very costly. Setting this variable to a true value
  will cause AnyEvent to load C<AnyEvent::Strict> and then to thoroughly
  check the arguments passed to most method calls. If it finds any problems,
  it will croak.
  
  In other words, enables "strict" mode.
  
  Unlike C<use strict> (or its modern cousin, C<< use L<common::sense>
  >>, it is definitely recommended to keep it off in production. Keeping
  C<PERL_ANYEVENT_STRICT=1> in your environment while developing programs
  can be very useful, however.
  
  =item C<PERL_ANYEVENT_DEBUG_SHELL>
  
  If this env variable is nonempty, then its contents will be interpreted by
  C<AnyEvent::Socket::parse_hostport> and C<AnyEvent::Debug::shell> (after
  replacing every occurance of C<$$> by the process pid). The shell object
  is saved in C<$AnyEvent::Debug::SHELL>.
  
  This happens when the first watcher is created.
  
  For example, to bind a debug shell on a unix domain socket in
  F<< /tmp/debug<pid>.sock >>, you could use this:
  
     PERL_ANYEVENT_DEBUG_SHELL=/tmp/debug\$\$.sock perlprog
     # connect with e.g.: socat readline /tmp/debug123.sock
  
  Or to bind to tcp port 4545 on localhost:
  
     PERL_ANYEVENT_DEBUG_SHELL=127.0.0.1:4545 perlprog
     # connect with e.g.: telnet localhost 4545
  
  Note that creating sockets in F</tmp> or on localhost is very unsafe on
  multiuser systems.
  
  =item C<PERL_ANYEVENT_DEBUG_WRAP>
  
  Can be set to C<0>, C<1> or C<2> and enables wrapping of all watchers for
  debugging purposes. See C<AnyEvent::Debug::wrap> for details.
  
  =item C<PERL_ANYEVENT_MODEL>
  
  This can be used to specify the event model to be used by AnyEvent, before
  auto detection and -probing kicks in.
  
  It normally is a string consisting entirely of ASCII letters (e.g. C<EV>
  or C<IOAsync>). The string C<AnyEvent::Impl::> gets prepended and the
  resulting module name is loaded and - if the load was successful - used as
  event model backend. If it fails to load then AnyEvent will proceed with
  auto detection and -probing.
  
  If the string ends with C<::> instead (e.g. C<AnyEvent::Impl::EV::>) then
  nothing gets prepended and the module name is used as-is (hint: C<::> at
  the end of a string designates a module name and quotes it appropriately).
  
  For example, to force the pure perl model (L<AnyEvent::Loop::Perl>) you
  could start your program like this:
  
     PERL_ANYEVENT_MODEL=Perl perl ...
  
  =item C<PERL_ANYEVENT_IO_MODEL>
  
  The current file I/O model - see L<AnyEvent::IO> for more info.
  
  At the moment, only C<Perl> (small, pure-perl, synchronous) and
  C<IOAIO> (truly asynchronous) are supported. The default is C<IOAIO> if
  L<AnyEvent::AIO> can be loaded, otherwise it is C<Perl>.
  
  =item C<PERL_ANYEVENT_PROTOCOLS>
  
  Used by both L<AnyEvent::DNS> and L<AnyEvent::Socket> to determine preferences
  for IPv4 or IPv6. The default is unspecified (and might change, or be the result
  of auto probing).
  
  Must be set to a comma-separated list of protocols or address families,
  current supported: C<ipv4> and C<ipv6>. Only protocols mentioned will be
  used, and preference will be given to protocols mentioned earlier in the
  list.
  
  This variable can effectively be used for denial-of-service attacks
  against local programs (e.g. when setuid), although the impact is likely
  small, as the program has to handle connection and other failures anyways.
  
  Examples: C<PERL_ANYEVENT_PROTOCOLS=ipv4,ipv6> - prefer IPv4 over IPv6,
  but support both and try to use both.  C<PERL_ANYEVENT_PROTOCOLS=ipv4>
  - only support IPv4, never try to resolve or contact IPv6
  addresses. C<PERL_ANYEVENT_PROTOCOLS=ipv6,ipv4> support either IPv4 or
  IPv6, but prefer IPv6 over IPv4.
  
  =item C<PERL_ANYEVENT_HOSTS>
  
  This variable, if specified, overrides the F</etc/hosts> file used by
  L<AnyEvent::Socket>C<::resolve_sockaddr>, i.e. hosts aliases will be read
  from that file instead.
  
  =item C<PERL_ANYEVENT_EDNS0>
  
  Used by L<AnyEvent::DNS> to decide whether to use the EDNS0 extension for
  DNS. This extension is generally useful to reduce DNS traffic, especially
  when DNSSEC is involved, but some (broken) firewalls drop such DNS
  packets, which is why it is off by default.
  
  Setting this variable to C<1> will cause L<AnyEvent::DNS> to announce
  EDNS0 in its DNS requests.
  
  =item C<PERL_ANYEVENT_MAX_FORKS>
  
  The maximum number of child processes that C<AnyEvent::Util::fork_call>
  will create in parallel.
  
  =item C<PERL_ANYEVENT_MAX_OUTSTANDING_DNS>
  
  The default value for the C<max_outstanding> parameter for the default DNS
  resolver - this is the maximum number of parallel DNS requests that are
  sent to the DNS server.
  
  =item C<PERL_ANYEVENT_MAX_SIGNAL_LATENCY>
  
  Perl has inherently racy signal handling (you can basically choose between
  losing signals and memory corruption) - pure perl event loops (including
  C<AnyEvent::Loop>, when C<Async::Interrupt> isn't available) therefore
  have to poll regularly to avoid losing signals.
  
  Some event loops are racy, but don't poll regularly, and some event loops
  are written in C but are still racy. For those event loops, AnyEvent
  installs a timer that regularly wakes up the event loop.
  
  By default, the interval for this timer is C<10> seconds, but you can
  override this delay with this environment variable (or by setting
  the C<$AnyEvent::MAX_SIGNAL_LATENCY> variable before creating signal
  watchers).
  
  Lower values increase CPU (and energy) usage, higher values can introduce
  long delays when reaping children or waiting for signals.
  
  The L<AnyEvent::Async> module, if available, will be used to avoid this
  polling (with most event loops).
  
  =item C<PERL_ANYEVENT_RESOLV_CONF>
  
  The absolute path to a F<resolv.conf>-style file to use instead of
  F</etc/resolv.conf> (or the OS-specific configuration) in the default
  resolver, or the empty string to select the default configuration.
  
  =item C<PERL_ANYEVENT_CA_FILE>, C<PERL_ANYEVENT_CA_PATH>.
  
  When neither C<ca_file> nor C<ca_path> was specified during
  L<AnyEvent::TLS> context creation, and either of these environment
  variables are nonempty, they will be used to specify CA certificate
  locations instead of a system-dependent default.
  
  =item C<PERL_ANYEVENT_AVOID_GUARD> and C<PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT>
  
  When these are set to C<1>, then the respective modules are not
  loaded. Mostly good for testing AnyEvent itself.
  
  =back
  
  =head1 SUPPLYING YOUR OWN EVENT MODEL INTERFACE
  
  This is an advanced topic that you do not normally need to use AnyEvent in
  a module. This section is only of use to event loop authors who want to
  provide AnyEvent compatibility.
  
  If you need to support another event library which isn't directly
  supported by AnyEvent, you can supply your own interface to it by
  pushing, before the first watcher gets created, the package name of
  the event module and the package name of the interface to use onto
  C<@AnyEvent::REGISTRY>. You can do that before and even without loading
  AnyEvent, so it is reasonably cheap.
  
  Example:
  
     push @AnyEvent::REGISTRY, [urxvt => urxvt::anyevent::];
  
  This tells AnyEvent to (literally) use the C<urxvt::anyevent::>
  package/class when it finds the C<urxvt> package/module is already loaded.
  
  When AnyEvent is loaded and asked to find a suitable event model, it
  will first check for the presence of urxvt by trying to C<use> the
  C<urxvt::anyevent> module.
  
  The class should provide implementations for all watcher types. See
  L<AnyEvent::Impl::EV> (source code), L<AnyEvent::Impl::Glib> (Source code)
  and so on for actual examples. Use C<perldoc -m AnyEvent::Impl::Glib> to
  see the sources.
  
  If you don't provide C<signal> and C<child> watchers than AnyEvent will
  provide suitable (hopefully) replacements.
  
  The above example isn't fictitious, the I<rxvt-unicode> (a.k.a. urxvt)
  terminal emulator uses the above line as-is. An interface isn't included
  in AnyEvent because it doesn't make sense outside the embedded interpreter
  inside I<rxvt-unicode>, and it is updated and maintained as part of the
  I<rxvt-unicode> distribution.
  
  I<rxvt-unicode> also cheats a bit by not providing blocking access to
  condition variables: code blocking while waiting for a condition will
  C<die>. This still works with most modules/usages, and blocking calls must
  not be done in an interactive application, so it makes sense.
  
  =head1 EXAMPLE PROGRAM
  
  The following program uses an I/O watcher to read data from STDIN, a timer
  to display a message once per second, and a condition variable to quit the
  program when the user enters quit:
  
     use AnyEvent;
  
     my $cv = AnyEvent->condvar;
  
     my $io_watcher = AnyEvent->io (
        fh   => \*STDIN,
        poll => 'r',
        cb   => sub {
           warn "io event <$_[0]>\n";   # will always output <r>
           chomp (my $input = <STDIN>); # read a line
           warn "read: $input\n";       # output what has been read
           $cv->send if $input =~ /^q/i; # quit program if /^q/i
        },
     );
  
     my $time_watcher = AnyEvent->timer (after => 1, interval => 1, cb => sub {
        warn "timeout\n"; # print 'timeout' at most every second
     });
  
     $cv->recv; # wait until user enters /^q/i
  
  =head1 REAL-WORLD EXAMPLE
  
  Consider the L<Net::FCP> module. It features (among others) the following
  API calls, which are to freenet what HTTP GET requests are to http:
  
     my $data = $fcp->client_get ($url); # blocks
  
     my $transaction = $fcp->txn_client_get ($url); # does not block
     $transaction->cb ( sub { ... } ); # set optional result callback
     my $data = $transaction->result; # possibly blocks
  
  The C<client_get> method works like C<LWP::Simple::get>: it requests the
  given URL and waits till the data has arrived. It is defined to be:
  
     sub client_get { $_[0]->txn_client_get ($_[1])->result }
  
  And in fact is automatically generated. This is the blocking API of
  L<Net::FCP>, and it works as simple as in any other, similar, module.
  
  More complicated is C<txn_client_get>: It only creates a transaction
  (completion, result, ...) object and initiates the transaction.
  
     my $txn = bless { }, Net::FCP::Txn::;
  
  It also creates a condition variable that is used to signal the completion
  of the request:
  
     $txn->{finished} = AnyAvent->condvar;
  
  It then creates a socket in non-blocking mode.
  
     socket $txn->{fh}, ...;
     fcntl $txn->{fh}, F_SETFL, O_NONBLOCK;
     connect $txn->{fh}, ...
        and !$!{EWOULDBLOCK}
        and !$!{EINPROGRESS}
        and Carp::croak "unable to connect: $!\n";
  
  Then it creates a write-watcher which gets called whenever an error occurs
  or the connection succeeds:
  
     $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'w', cb => sub { $txn->fh_ready_w });
  
  And returns this transaction object. The C<fh_ready_w> callback gets
  called as soon as the event loop detects that the socket is ready for
  writing.
  
  The C<fh_ready_w> method makes the socket blocking again, writes the
  request data and replaces the watcher by a read watcher (waiting for reply
  data). The actual code is more complicated, but that doesn't matter for
  this example:
  
     fcntl $txn->{fh}, F_SETFL, 0;
     syswrite $txn->{fh}, $txn->{request}
        or die "connection or write error";
     $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'r', cb => sub { $txn->fh_ready_r });
  
  Again, C<fh_ready_r> waits till all data has arrived, and then stores the
  result and signals any possible waiters that the request has finished:
  
     sysread $txn->{fh}, $txn->{buf}, length $txn->{$buf};
  
     if (end-of-file or data complete) {
       $txn->{result} = $txn->{buf};
       $txn->{finished}->send;
       $txb->{cb}->($txn) of $txn->{cb}; # also call callback
     }
  
  The C<result> method, finally, just waits for the finished signal (if the
  request was already finished, it doesn't wait, of course, and returns the
  data:
  
     $txn->{finished}->recv;
     return $txn->{result};
  
  The actual code goes further and collects all errors (C<die>s, exceptions)
  that occurred during request processing. The C<result> method detects
  whether an exception as thrown (it is stored inside the $txn object)
  and just throws the exception, which means connection errors and other
  problems get reported to the code that tries to use the result, not in a
  random callback.
  
  All of this enables the following usage styles:
  
  1. Blocking:
  
     my $data = $fcp->client_get ($url);
  
  2. Blocking, but running in parallel:
  
     my @datas = map $_->result,
                    map $fcp->txn_client_get ($_),
                       @urls;
  
  Both blocking examples work without the module user having to know
  anything about events.
  
  3a. Event-based in a main program, using any supported event module:
  
     use EV;
  
     $fcp->txn_client_get ($url)->cb (sub {
        my $txn = shift;
        my $data = $txn->result;
        ...
     });
  
     EV::run;
  
  3b. The module user could use AnyEvent, too:
  
     use AnyEvent;
  
     my $quit = AnyEvent->condvar;
  
     $fcp->txn_client_get ($url)->cb (sub {
        ...
        $quit->send;
     });
  
     $quit->recv;
  
  
  =head1 BENCHMARKS
  
  To give you an idea of the performance and overheads that AnyEvent adds
  over the event loops themselves and to give you an impression of the speed
  of various event loops I prepared some benchmarks.
  
  =head2 BENCHMARKING ANYEVENT OVERHEAD
  
  Here is a benchmark of various supported event models used natively and
  through AnyEvent. The benchmark creates a lot of timers (with a zero
  timeout) and I/O watchers (watching STDOUT, a pty, to become writable,
  which it is), lets them fire exactly once and destroys them again.
  
  Source code for this benchmark is found as F<eg/bench> in the AnyEvent
  distribution. It uses the L<AE> interface, which makes a real difference
  for the EV and Perl backends only.
  
  =head3 Explanation of the columns
  
  I<watcher> is the number of event watchers created/destroyed. Since
  different event models feature vastly different performances, each event
  loop was given a number of watchers so that overall runtime is acceptable
  and similar between tested event loop (and keep them from crashing): Glib
  would probably take thousands of years if asked to process the same number
  of watchers as EV in this benchmark.
  
  I<bytes> is the number of bytes (as measured by the resident set size,
  RSS) consumed by each watcher. This method of measuring captures both C
  and Perl-based overheads.
  
  I<create> is the time, in microseconds (millionths of seconds), that it
  takes to create a single watcher. The callback is a closure shared between
  all watchers, to avoid adding memory overhead. That means closure creation
  and memory usage is not included in the figures.
  
  I<invoke> is the time, in microseconds, used to invoke a simple
  callback. The callback simply counts down a Perl variable and after it was
  invoked "watcher" times, it would C<< ->send >> a condvar once to
  signal the end of this phase.
  
  I<destroy> is the time, in microseconds, that it takes to destroy a single
  watcher.
  
  =head3 Results
  
            name watchers bytes create invoke destroy comment
           EV/EV   100000   223   0.47   0.43    0.27 EV native interface
          EV/Any   100000   223   0.48   0.42    0.26 EV + AnyEvent watchers
    Coro::EV/Any   100000   223   0.47   0.42    0.26 coroutines + Coro::Signal
        Perl/Any   100000   431   2.70   0.74    0.92 pure perl implementation
     Event/Event    16000   516  31.16  31.84    0.82 Event native interface
       Event/Any    16000  1203  42.61  34.79    1.80 Event + AnyEvent watchers
     IOAsync/Any    16000  1911  41.92  27.45   16.81 via IO::Async::Loop::IO_Poll
     IOAsync/Any    16000  1726  40.69  26.37   15.25 via IO::Async::Loop::Epoll
        Glib/Any    16000  1118  89.00  12.57   51.17 quadratic behaviour
          Tk/Any     2000  1346  20.96  10.75    8.00 SEGV with >> 2000 watchers
         POE/Any     2000  6951 108.97 795.32   14.24 via POE::Loop::Event
         POE/Any     2000  6648  94.79 774.40  575.51 via POE::Loop::Select
  
  =head3 Discussion
  
  The benchmark does I<not> measure scalability of the event loop very
  well. For example, a select-based event loop (such as the pure perl one)
  can never compete with an event loop that uses epoll when the number of
  file descriptors grows high. In this benchmark, all events become ready at
  the same time, so select/poll-based implementations get an unnatural speed
  boost.
  
  Also, note that the number of watchers usually has a nonlinear effect on
  overall speed, that is, creating twice as many watchers doesn't take twice
  the time - usually it takes longer. This puts event loops tested with a
  higher number of watchers at a disadvantage.
  
  To put the range of results into perspective, consider that on the
  benchmark machine, handling an event takes roughly 1600 CPU cycles with
  EV, 3100 CPU cycles with AnyEvent's pure perl loop and almost 3000000 CPU
  cycles with POE.
  
  C<EV> is the sole leader regarding speed and memory use, which are both
  maximal/minimal, respectively. When using the L<AE> API there is zero
  overhead (when going through the AnyEvent API create is about 5-6 times
  slower, with other times being equal, so still uses far less memory than
  any other event loop and is still faster than Event natively).
  
  The pure perl implementation is hit in a few sweet spots (both the
  constant timeout and the use of a single fd hit optimisations in the perl
  interpreter and the backend itself). Nevertheless this shows that it
  adds very little overhead in itself. Like any select-based backend its
  performance becomes really bad with lots of file descriptors (and few of
  them active), of course, but this was not subject of this benchmark.
  
  The C<Event> module has a relatively high setup and callback invocation
  cost, but overall scores in on the third place.
  
  C<IO::Async> performs admirably well, about on par with C<Event>, even
  when using its pure perl backend.
  
  C<Glib>'s memory usage is quite a bit higher, but it features a
  faster callback invocation and overall ends up in the same class as
  C<Event>. However, Glib scales extremely badly, doubling the number of
  watchers increases the processing time by more than a factor of four,
  making it completely unusable when using larger numbers of watchers
  (note that only a single file descriptor was used in the benchmark, so
  inefficiencies of C<poll> do not account for this).
  
  The C<Tk> adaptor works relatively well. The fact that it crashes with
  more than 2000 watchers is a big setback, however, as correctness takes
  precedence over speed. Nevertheless, its performance is surprising, as the
  file descriptor is dup()ed for each watcher. This shows that the dup()
  employed by some adaptors is not a big performance issue (it does incur a
  hidden memory cost inside the kernel which is not reflected in the figures
  above).
  
  C<POE>, regardless of underlying event loop (whether using its pure perl
  select-based backend or the Event module, the POE-EV backend couldn't
  be tested because it wasn't working) shows abysmal performance and
  memory usage with AnyEvent: Watchers use almost 30 times as much memory
  as EV watchers, and 10 times as much memory as Event (the high memory
  requirements are caused by requiring a session for each watcher). Watcher
  invocation speed is almost 900 times slower than with AnyEvent's pure perl
  implementation.
  
  The design of the POE adaptor class in AnyEvent can not really account
  for the performance issues, though, as session creation overhead is
  small compared to execution of the state machine, which is coded pretty
  optimally within L<AnyEvent::Impl::POE> (and while everybody agrees that
  using multiple sessions is not a good approach, especially regarding
  memory usage, even the author of POE could not come up with a faster
  design).
  
  =head3 Summary
  
  =over 4
  
  =item * Using EV through AnyEvent is faster than any other event loop
  (even when used without AnyEvent), but most event loops have acceptable
  performance with or without AnyEvent.
  
  =item * The overhead AnyEvent adds is usually much smaller than the overhead of
  the actual event loop, only with extremely fast event loops such as EV
  does AnyEvent add significant overhead.
  
  =item * You should avoid POE like the plague if you want performance or
  reasonable memory usage.
  
  =back
  
  =head2 BENCHMARKING THE LARGE SERVER CASE
  
  This benchmark actually benchmarks the event loop itself. It works by
  creating a number of "servers": each server consists of a socket pair, a
  timeout watcher that gets reset on activity (but never fires), and an I/O
  watcher waiting for input on one side of the socket. Each time the socket
  watcher reads a byte it will write that byte to a random other "server".
  
  The effect is that there will be a lot of I/O watchers, only part of which
  are active at any one point (so there is a constant number of active
  fds for each loop iteration, but which fds these are is random). The
  timeout is reset each time something is read because that reflects how
  most timeouts work (and puts extra pressure on the event loops).
  
  In this benchmark, we use 10000 socket pairs (20000 sockets), of which 100
  (1%) are active. This mirrors the activity of large servers with many
  connections, most of which are idle at any one point in time.
  
  Source code for this benchmark is found as F<eg/bench2> in the AnyEvent
  distribution. It uses the L<AE> interface, which makes a real difference
  for the EV and Perl backends only.
  
  =head3 Explanation of the columns
  
  I<sockets> is the number of sockets, and twice the number of "servers" (as
  each server has a read and write socket end).
  
  I<create> is the time it takes to create a socket pair (which is
  nontrivial) and two watchers: an I/O watcher and a timeout watcher.
  
  I<request>, the most important value, is the time it takes to handle a
  single "request", that is, reading the token from the pipe and forwarding
  it to another server. This includes deleting the old timeout and creating
  a new one that moves the timeout into the future.
  
  =head3 Results
  
       name sockets create  request 
         EV   20000  62.66     7.99 
       Perl   20000  68.32    32.64 
    IOAsync   20000 174.06   101.15 epoll
    IOAsync   20000 174.67   610.84 poll
      Event   20000 202.69   242.91 
       Glib   20000 557.01  1689.52 
        POE   20000 341.54 12086.32 uses POE::Loop::Event
  
  =head3 Discussion
  
  This benchmark I<does> measure scalability and overall performance of the
  particular event loop.
  
  EV is again fastest. Since it is using epoll on my system, the setup time
  is relatively high, though.
  
  Perl surprisingly comes second. It is much faster than the C-based event
  loops Event and Glib.
  
  IO::Async performs very well when using its epoll backend, and still quite
  good compared to Glib when using its pure perl backend.
  
  Event suffers from high setup time as well (look at its code and you will
  understand why). Callback invocation also has a high overhead compared to
  the C<< $_->() for .. >>-style loop that the Perl event loop uses. Event
  uses select or poll in basically all documented configurations.
  
  Glib is hit hard by its quadratic behaviour w.r.t. many watchers. It
  clearly fails to perform with many filehandles or in busy servers.
  
  POE is still completely out of the picture, taking over 1000 times as long
  as EV, and over 100 times as long as the Perl implementation, even though
  it uses a C-based event loop in this case.
  
  =head3 Summary
  
  =over 4
  
  =item * The pure perl implementation performs extremely well.
  
  =item * Avoid Glib or POE in large projects where performance matters.
  
  =back
  
  =head2 BENCHMARKING SMALL SERVERS
  
  While event loops should scale (and select-based ones do not...) even to
  large servers, most programs we (or I :) actually write have only a few
  I/O watchers.
  
  In this benchmark, I use the same benchmark program as in the large server
  case, but it uses only eight "servers", of which three are active at any
  one time. This should reflect performance for a small server relatively
  well.
  
  The columns are identical to the previous table.
  
  =head3 Results
  
      name sockets create request 
        EV      16  20.00    6.54 
      Perl      16  25.75   12.62 
     Event      16  81.27   35.86 
      Glib      16  32.63   15.48 
       POE      16 261.87  276.28 uses POE::Loop::Event
  
  =head3 Discussion
  
  The benchmark tries to test the performance of a typical small
  server. While knowing how various event loops perform is interesting, keep
  in mind that their overhead in this case is usually not as important, due
  to the small absolute number of watchers (that is, you need efficiency and
  speed most when you have lots of watchers, not when you only have a few of
  them).
  
  EV is again fastest.
  
  Perl again comes second. It is noticeably faster than the C-based event
  loops Event and Glib, although the difference is too small to really
  matter.
  
  POE also performs much better in this case, but is is still far behind the
  others.
  
  =head3 Summary
  
  =over 4
  
  =item * C-based event loops perform very well with small number of
  watchers, as the management overhead dominates.
  
  =back
  
  =head2 THE IO::Lambda BENCHMARK
  
  Recently I was told about the benchmark in the IO::Lambda manpage, which
  could be misinterpreted to make AnyEvent look bad. In fact, the benchmark
  simply compares IO::Lambda with POE, and IO::Lambda looks better (which
  shouldn't come as a surprise to anybody). As such, the benchmark is
  fine, and mostly shows that the AnyEvent backend from IO::Lambda isn't
  very optimal. But how would AnyEvent compare when used without the extra
  baggage? To explore this, I wrote the equivalent benchmark for AnyEvent.
  
  The benchmark itself creates an echo-server, and then, for 500 times,
  connects to the echo server, sends a line, waits for the reply, and then
  creates the next connection. This is a rather bad benchmark, as it doesn't
  test the efficiency of the framework or much non-blocking I/O, but it is a
  benchmark nevertheless.
  
     name                    runtime
     Lambda/select           0.330 sec
        + optimized          0.122 sec
     Lambda/AnyEvent         0.327 sec
        + optimized          0.138 sec
     Raw sockets/select      0.077 sec
     POE/select, components  0.662 sec
     POE/select, raw sockets 0.226 sec
     POE/select, optimized   0.404 sec
  
     AnyEvent/select/nb      0.085 sec
     AnyEvent/EV/nb          0.068 sec
        +state machine       0.134 sec
  
  The benchmark is also a bit unfair (my fault): the IO::Lambda/POE
  benchmarks actually make blocking connects and use 100% blocking I/O,
  defeating the purpose of an event-based solution. All of the newly
  written AnyEvent benchmarks use 100% non-blocking connects (using
  AnyEvent::Socket::tcp_connect and the asynchronous pure perl DNS
  resolver), so AnyEvent is at a disadvantage here, as non-blocking connects
  generally require a lot more bookkeeping and event handling than blocking
  connects (which involve a single syscall only).
  
  The last AnyEvent benchmark additionally uses L<AnyEvent::Handle>, which
  offers similar expressive power as POE and IO::Lambda, using conventional
  Perl syntax. This means that both the echo server and the client are 100%
  non-blocking, further placing it at a disadvantage.
  
  As you can see, the AnyEvent + EV combination even beats the
  hand-optimised "raw sockets benchmark", while AnyEvent + its pure perl
  backend easily beats IO::Lambda and POE.
  
  And even the 100% non-blocking version written using the high-level (and
  slow :) L<AnyEvent::Handle> abstraction beats both POE and IO::Lambda
  higher level ("unoptimised") abstractions by a large margin, even though
  it does all of DNS, tcp-connect and socket I/O in a non-blocking way.
  
  The two AnyEvent benchmarks programs can be found as F<eg/ae0.pl> and
  F<eg/ae2.pl> in the AnyEvent distribution, the remaining benchmarks are
  part of the IO::Lambda distribution and were used without any changes.
  
  
  =head1 SIGNALS
  
  AnyEvent currently installs handlers for these signals:
  
  =over 4
  
  =item SIGCHLD
  
  A handler for C<SIGCHLD> is installed by AnyEvent's child watcher
  emulation for event loops that do not support them natively. Also, some
  event loops install a similar handler.
  
  Additionally, when AnyEvent is loaded and SIGCHLD is set to IGNORE, then
  AnyEvent will reset it to default, to avoid losing child exit statuses.
  
  =item SIGPIPE
  
  A no-op handler is installed for C<SIGPIPE> when C<$SIG{PIPE}> is C<undef>
  when AnyEvent gets loaded.
  
  The rationale for this is that AnyEvent users usually do not really depend
  on SIGPIPE delivery (which is purely an optimisation for shell use, or
  badly-written programs), but C<SIGPIPE> can cause spurious and rare
  program exits as a lot of people do not expect C<SIGPIPE> when writing to
  some random socket.
  
  The rationale for installing a no-op handler as opposed to ignoring it is
  that this way, the handler will be restored to defaults on exec.
  
  Feel free to install your own handler, or reset it to defaults.
  
  =back
  
  =cut
  
  undef $SIG{CHLD}
     if $SIG{CHLD} eq 'IGNORE';
  
  $SIG{PIPE} = sub { }
     unless defined $SIG{PIPE};
  
  =head1 RECOMMENDED/OPTIONAL MODULES
  
  One of AnyEvent's main goals is to be 100% Pure-Perl(tm): only perl (and
  its built-in modules) are required to use it.
  
  That does not mean that AnyEvent won't take advantage of some additional
  modules if they are installed.
  
  This section explains which additional modules will be used, and how they
  affect AnyEvent's operation.
  
  =over 4
  
  =item L<Async::Interrupt>
  
  This slightly arcane module is used to implement fast signal handling: To
  my knowledge, there is no way to do completely race-free and quick
  signal handling in pure perl. To ensure that signals still get
  delivered, AnyEvent will start an interval timer to wake up perl (and
  catch the signals) with some delay (default is 10 seconds, look for
  C<$AnyEvent::MAX_SIGNAL_LATENCY>).
  
  If this module is available, then it will be used to implement signal
  catching, which means that signals will not be delayed, and the event loop
  will not be interrupted regularly, which is more efficient (and good for
  battery life on laptops).
  
  This affects not just the pure-perl event loop, but also other event loops
  that have no signal handling on their own (e.g. Glib, Tk, Qt).
  
  Some event loops (POE, Event, Event::Lib) offer signal watchers natively,
  and either employ their own workarounds (POE) or use AnyEvent's workaround
  (using C<$AnyEvent::MAX_SIGNAL_LATENCY>). Installing L<Async::Interrupt>
  does nothing for those backends.
  
  =item L<EV>
  
  This module isn't really "optional", as it is simply one of the backend
  event loops that AnyEvent can use. However, it is simply the best event
  loop available in terms of features, speed and stability: It supports
  the AnyEvent API optimally, implements all the watcher types in XS, does
  automatic timer adjustments even when no monotonic clock is available,
  can take avdantage of advanced kernel interfaces such as C<epoll> and
  C<kqueue>, and is the fastest backend I<by far>. You can even embed
  L<Glib>/L<Gtk2> in it (or vice versa, see L<EV::Glib> and L<Glib::EV>).
  
  If you only use backends that rely on another event loop (e.g. C<Tk>),
  then this module will do nothing for you.
  
  =item L<Guard>
  
  The guard module, when used, will be used to implement
  C<AnyEvent::Util::guard>. This speeds up guards considerably (and uses a
  lot less memory), but otherwise doesn't affect guard operation much. It is
  purely used for performance.
  
  =item L<JSON> and L<JSON::XS>
  
  One of these modules is required when you want to read or write JSON data
  via L<AnyEvent::Handle>. L<JSON> is also written in pure-perl, but can take
  advantage of the ultra-high-speed L<JSON::XS> module when it is installed.
  
  =item L<Net::SSLeay>
  
  Implementing TLS/SSL in Perl is certainly interesting, but not very
  worthwhile: If this module is installed, then L<AnyEvent::Handle> (with
  the help of L<AnyEvent::TLS>), gains the ability to do TLS/SSL.
  
  =item L<Time::HiRes>
  
  This module is part of perl since release 5.008. It will be used when the
  chosen event library does not come with a timing source of its own. The
  pure-perl event loop (L<AnyEvent::Loop>) will additionally load it to
  try to use a monotonic clock for timing stability.
  
  =item L<AnyEvent::AIO> (and L<IO::AIO>)
  
  The default implementation of L<AnyEvent::IO> is to do I/O synchronously,
  stopping programs while they access the disk, which is fine for a lot of
  programs.
  
  Installing AnyEvent::AIO (and its IO::AIO dependency) makes it switch to
  a true asynchronous implementation, so event processing can continue even
  while waiting for disk I/O.
  
  =back
  
  
  =head1 FORK
  
  Most event libraries are not fork-safe. The ones who are usually are
  because they rely on inefficient but fork-safe C<select> or C<poll> calls
  - higher performance APIs such as BSD's kqueue or the dreaded Linux epoll
  are usually badly thought-out hacks that are incompatible with fork in
  one way or another. Only L<EV> is fully fork-aware and ensures that you
  continue event-processing in both parent and child (or both, if you know
  what you are doing).
  
  This means that, in general, you cannot fork and do event processing in
  the child if the event library was initialised before the fork (which
  usually happens when the first AnyEvent watcher is created, or the library
  is loaded).
  
  If you have to fork, you must either do so I<before> creating your first
  watcher OR you must not use AnyEvent at all in the child OR you must do
  something completely out of the scope of AnyEvent (see below).
  
  The problem of doing event processing in the parent I<and> the child
  is much more complicated: even for backends that I<are> fork-aware or
  fork-safe, their behaviour is not usually what you want: fork clones all
  watchers, that means all timers, I/O watchers etc. are active in both
  parent and child, which is almost never what you want. Using C<exec>
  to start worker children from some kind of manage prrocess is usually
  preferred, because it is much easier and cleaner, at the expense of having
  to have another binary.
  
  In addition to logical problems with fork, there are also implementation
  problems. For example, on POSIX systems, you cannot fork at all in Perl
  code if a thread (I am talking of pthreads here) was ever created in the
  process, and this is just the tip of the iceberg. In general, using fork
  from Perl is difficult, and attempting to use fork without an exec to
  implement some kind of parallel processing is almost certainly doomed.
  
  To safely fork and exec, you should use a module such as
  L<Proc::FastSpawn> that let's you safely fork and exec new processes.
  
  If you want to do multiprocessing using processes, you can
  look at the L<AnyEvent::Fork> module (and some related modules
  such as L<AnyEvent::Fork::RPC>, L<AnyEvent::Fork::Pool> and
  L<AnyEvent::Fork::Remote>). This module allows you to safely create
  subprocesses without any limitations - you can use X11 toolkits or
  AnyEvent in the children created by L<AnyEvent::Fork> safely and without
  any special precautions.
  
  
  =head1 SECURITY CONSIDERATIONS
  
  AnyEvent can be forced to load any event model via
  $ENV{PERL_ANYEVENT_MODEL}. While this cannot (to my knowledge) be used to
  execute arbitrary code or directly gain access, it can easily be used to
  make the program hang or malfunction in subtle ways, as AnyEvent watchers
  will not be active when the program uses a different event model than
  specified in the variable.
  
  You can make AnyEvent completely ignore this variable by deleting it
  before the first watcher gets created, e.g. with a C<BEGIN> block:
  
     BEGIN { delete $ENV{PERL_ANYEVENT_MODEL} }
    
     use AnyEvent;
  
  Similar considerations apply to $ENV{PERL_ANYEVENT_VERBOSE}, as that can
  be used to probe what backend is used and gain other information (which is
  probably even less useful to an attacker than PERL_ANYEVENT_MODEL), and
  $ENV{PERL_ANYEVENT_STRICT}.
  
  Note that AnyEvent will remove I<all> environment variables starting with
  C<PERL_ANYEVENT_> from C<%ENV> when it is loaded while taint mode is
  enabled.
  
  
  =head1 BUGS
  
  Perl 5.8 has numerous memleaks that sometimes hit this module and are hard
  to work around. If you suffer from memleaks, first upgrade to Perl 5.10
  and check wether the leaks still show up. (Perl 5.10.0 has other annoying
  memleaks, such as leaking on C<map> and C<grep> but it is usually not as
  pronounced).
  
  
  =head1 SEE ALSO
  
  Tutorial/Introduction: L<AnyEvent::Intro>.
  
  FAQ: L<AnyEvent::FAQ>.
  
  Utility functions: L<AnyEvent::Util> (misc. grab-bag), L<AnyEvent::Log>
  (simply logging).
  
  Development/Debugging: L<AnyEvent::Strict> (stricter checking),
  L<AnyEvent::Debug> (interactive shell, watcher tracing).
  
  Supported event modules: L<AnyEvent::Loop>, L<EV>, L<EV::Glib>,
  L<Glib::EV>, L<Event>, L<Glib::Event>, L<Glib>, L<Tk>, L<Event::Lib>,
  L<Qt>, L<POE>, L<FLTK>, L<Cocoa::EventLoop>, L<UV>.
  
  Implementations: L<AnyEvent::Impl::EV>, L<AnyEvent::Impl::Event>,
  L<AnyEvent::Impl::Glib>, L<AnyEvent::Impl::Tk>, L<AnyEvent::Impl::Perl>,
  L<AnyEvent::Impl::EventLib>, L<AnyEvent::Impl::Qt>,
  L<AnyEvent::Impl::POE>, L<AnyEvent::Impl::IOAsync>, L<AnyEvent::Impl::Irssi>,
  L<AnyEvent::Impl::FLTK>, L<AnyEvent::Impl::Cocoa>, L<AnyEvent::Impl::UV>.
  
  Non-blocking handles, pipes, stream sockets, TCP clients and
  servers: L<AnyEvent::Handle>, L<AnyEvent::Socket>, L<AnyEvent::TLS>.
  
  Asynchronous File I/O: L<AnyEvent::IO>.
  
  Asynchronous DNS: L<AnyEvent::DNS>.
  
  Thread support: L<Coro>, L<Coro::AnyEvent>, L<Coro::EV>, L<Coro::Event>.
  
  Nontrivial usage examples: L<AnyEvent::GPSD>, L<AnyEvent::IRC>,
  L<AnyEvent::HTTP>.
  
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT

$fatpacked{"AnyEvent/DNS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DNS';
  =head1 NAME
  
  AnyEvent::DNS - fully asynchronous DNS resolution
  
  =head1 SYNOPSIS
  
     use AnyEvent::DNS;
     
     my $cv = AnyEvent->condvar;
     AnyEvent::DNS::a "www.google.de", $cv;
     # ... later
     my @addrs = $cv->recv;
  
  =head1 DESCRIPTION
  
  This module offers both a number of DNS convenience functions as well
  as a fully asynchronous and high-performance pure-perl stub resolver.
  
  The stub resolver supports DNS over IPv4 and IPv6, UDP and TCP, optional
  EDNS0 support for up to 4kiB datagrams and automatically falls back to
  virtual circuit mode for large responses.
  
  =head2 CONVENIENCE FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::DNS;
  
  use Carp ();
  use Socket qw(AF_INET SOCK_DGRAM SOCK_STREAM);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(AF_INET6);
  
  our $VERSION = $AnyEvent::VERSION;
  our @DNS_FALLBACK; # some public dns servers as fallback
  
  {
     my $prep = sub {
        $_ = $_->[rand @$_] for @_;
        push @_, splice @_, rand $_, 1 for reverse 1..@_; # shuffle
        $_ = pack "H*", $_ for @_;
        \@_
     };
  
     my $ipv4 = $prep->(
        ["08080808", "08080404"], # 8.8.8.8, 8.8.4.4 - google public dns
        ["01010101", "01000001"], # 1.1.1.1, 1.0.0.1 - cloudflare public dns
        ["50505050", "50505151"], # 80.80.80.80, 80.80.81.81 - freenom.world
  ##      ["d1f40003", "d1f30004"], # v209.244.0.3/4 - resolver1/2.level3.net - status unknown
  ##      ["04020201", "04020203", "04020204", "04020205", "04020206"], # v4.2.2.1/3/4/5/6 - vnsc-pri.sys.gtei.net - effectively public
  ##      ["cdd22ad2", "4044c8c8"], # 205.210.42.205, 64.68.200.200 - cache1/2.dnsresolvers.com - verified public
  #      ["8d010101"], # 141.1.1.1 - cable&wireless, now vodafone - status unknown
  # 84.200.69.80      # dns.watch
  # 84.200.70.40      # dns.watch
  # 37.235.1.174      # freedns.zone
  # 37.235.1.177      # freedns.zone
  # 213.73.91.35      # dnscache.berlin.ccc.de
  # 194.150.168.168   # dns.as250.net; Berlin/Frankfurt
  # 85.214.20.141     # FoeBud (digitalcourage.de)
  # 77.109.148.136    # privacyfoundation.ch
  # 77.109.148.137    # privacyfoundation.ch
  # 91.239.100.100    # anycast.censurfridns.dk
  # 89.233.43.71      # ns1.censurfridns.dk
  # 204.152.184.76    # f.6to4-servers.net, ISC, USA
     );
  
     my $ipv6 = $prep->(
        ["20014860486000000000000000008888", "20014860486000000000000000008844"], # 2001:4860:4860::8888/8844 - google ipv6
        ["26064700470000000000000000001111", "26064700470000000000000000001001"], # 2606:4700:4700::1111/1001 - cloudflare dns
     );
  
     undef $ipv4 unless $AnyEvent::PROTOCOL{ipv4};
     undef $ipv6 unless $AnyEvent::PROTOCOL{ipv6};
  
     ($ipv6, $ipv4) = ($ipv4, $ipv6)
        if $AnyEvent::PROTOCOL{ipv6} > $AnyEvent::PROTOCOL{ipv4};
  
     @DNS_FALLBACK = (@$ipv4, @$ipv6);
  }
  
  =item AnyEvent::DNS::a $domain, $cb->(@addrs)
  
  Tries to resolve the given domain to IPv4 address(es).
  
  =item AnyEvent::DNS::aaaa $domain, $cb->(@addrs)
  
  Tries to resolve the given domain to IPv6 address(es).
  
  =item AnyEvent::DNS::mx $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain into a sorted (lower preference value
  first) list of domain names.
  
  =item AnyEvent::DNS::ns $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain name into a list of name servers.
  
  =item AnyEvent::DNS::txt $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain name into a list of text records. Only
  the first text string per record will be returned. If you want all
  strings, you need to call the resolver manually:
  
     resolver->resolve ($domain => "txt", sub {
        for my $record (@_) {
           my (undef, undef, undef, @txt) = @$record;
           # strings now in @txt
        }
     });
  
  =item AnyEvent::DNS::srv $service, $proto, $domain, $cb->(@srv_rr)
  
  Tries to resolve the given service, protocol and domain name into a list
  of service records.
  
  Each C<$srv_rr> is an array reference with the following contents:
  C<[$priority, $weight, $transport, $target]>.
  
  They will be sorted with lowest priority first, then randomly
  distributed by weight as per RFC 2782.
  
  Example:
  
     AnyEvent::DNS::srv "sip", "udp", "schmorp.de", sub { ...
     # @_ = ( [10, 10, 5060, "sip1.schmorp.de" ] )
  
  =item AnyEvent::DNS::any $domain, $cb->(@rrs)
  
  Tries to resolve the given domain and passes all resource records found
  to the callback. Note that this uses a DNS C<ANY> query, which, as of RFC
  8482, are officially deprecated.
  
  =item AnyEvent::DNS::ptr $domain, $cb->(@hostnames)
  
  Tries to make a PTR lookup on the given domain. See C<reverse_lookup>
  and C<reverse_verify> if you want to resolve an IP address to a hostname
  instead.
  
  =item AnyEvent::DNS::reverse_lookup $ipv4_or_6, $cb->(@hostnames)
  
  Tries to reverse-resolve the given IPv4 or IPv6 address (in textual form)
  into its hostname(s). Handles V4MAPPED and V4COMPAT IPv6 addresses
  transparently.
  
  =item AnyEvent::DNS::reverse_verify $ipv4_or_6, $cb->(@hostnames)
  
  The same as C<reverse_lookup>, but does forward-lookups to verify that
  the resolved hostnames indeed point to the address, which makes spoofing
  harder.
  
  If you want to resolve an address into a hostname, this is the preferred
  method: The DNS records could still change, but at least this function
  verified that the hostname, at one point in the past, pointed at the IP
  address you originally resolved.
  
  Example:
  
     AnyEvent::DNS::reverse_verify "2001:500:2f::f", sub { print shift };
     # => f.root-servers.net
  
  =cut
  
  sub MAX_PKT() { 4096 } # max packet size we advertise and accept
  
  sub DOMAIN_PORT() { 53 } # if this changes drop me a note
  
  sub resolver ();
  
  sub a($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "a", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub aaaa($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "aaaa", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub mx($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "mx", sub {
        $cb->(map $_->[5], sort { $a->[4] <=> $b->[4] } @_);
     });
  }
  
  sub ns($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "ns", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub txt($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "txt", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub srv($$$$) {
     my ($service, $proto, $domain, $cb) = @_;
  
     # todo, ask for any and check glue records
     resolver->resolve ("_$service._$proto.$domain" => "srv", sub {
        my @res;
  
        # classify by priority
        my %pri;
        push @{ $pri{$_->[4]} }, [ @$_[4,5,6,7] ]
           for @_;
  
        # order by priority
        for my $pri (sort { $a <=> $b } keys %pri) {
           # order by weight
           my @rr = sort { $a->[1] <=> $b->[1] } @{ delete $pri{$pri} };
  
           my $sum; $sum += $_->[1] for @rr;
  
           while (@rr) {
              my $w = int rand $sum + 1;
              for (0 .. $#rr) {
                 if (($w -= $rr[$_][1]) <= 0) {
                    $sum -= $rr[$_][1];
                    push @res, splice @rr, $_, 1, ();
                    last;
                 }
              }
           }
        }
  
        $cb->(@res);
     });
  }
  
  sub ptr($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "ptr", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub any($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "*", $cb);
  }
  
  # convert textual ip address into reverse lookup form
  sub _munge_ptr($) {
     my $ipn = $_[0]
        or return;
  
     my $ptr;
  
     my $af = AnyEvent::Socket::address_family ($ipn);
  
     if ($af == AF_INET6) {
        $ipn = substr $ipn, 0, 16; # anticipate future expansion
  
        # handle v4mapped and v4compat
        if ($ipn =~ s/^\x00{10}(?:\xff\xff|\x00\x00)//) {
           $af = AF_INET;
        } else {
           $ptr = join ".", (reverse split //, unpack "H32", $ipn), "ip6.arpa.";
        }
     }
  
     if ($af == AF_INET) {
        $ptr = join ".", (reverse unpack "C4", $ipn), "in-addr.arpa.";
     }
  
     $ptr
  }
  
  sub reverse_lookup($$) {
     my ($ip, $cb) = @_;
  
     $ip = _munge_ptr AnyEvent::Socket::parse_address ($ip)
        or return $cb->();
  
     resolver->resolve ($ip => "ptr", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub reverse_verify($$) {
     my ($ip, $cb) = @_;
     
     my $ipn = AnyEvent::Socket::parse_address ($ip)
        or return $cb->();
  
     my $af = AnyEvent::Socket::address_family ($ipn);
  
     my @res;
     my $cnt;
  
     my $ptr = _munge_ptr $ipn
        or return $cb->();
  
     $ip = AnyEvent::Socket::format_address ($ipn); # normalise into the same form
  
     ptr $ptr, sub {
        for my $name (@_) {
           ++$cnt;
           
           # () around AF_INET to work around bug in 5.8
           resolver->resolve ("$name." => ($af == (AF_INET) ? "a" : "aaaa"), sub {
              for (@_) {
                 push @res, $name
                    if $_->[4] eq $ip;
              }
              $cb->(@res) unless --$cnt;
           });
        }
  
        $cb->() unless $cnt;
     };
  }
  
  #################################################################################
  
  =back
  
  =head2 LOW-LEVEL DNS EN-/DECODING FUNCTIONS
  
  =over 4
  
  =item $AnyEvent::DNS::EDNS0
  
  This variable decides whether dns_pack automatically enables EDNS0
  support. By default, this is disabled (C<0>), unless overridden by
  C<$ENV{PERL_ANYEVENT_EDNS0}>, but when set to C<1>, AnyEvent::DNS will use
  EDNS0 in all requests.
  
  =cut
  
  our $EDNS0 = $ENV{PERL_ANYEVENT_EDNS0}*1; # set to 1 to enable (partial) edns0
  
  our %opcode_id = (
     query  => 0,
     iquery => 1,
     status => 2,
     notify => 4,
     update => 5,
     map +($_ => $_), 3, 6..15
  );
  
  our %opcode_str = reverse %opcode_id;
  
  our %rcode_id = (
     noerror  =>  0,
     formerr  =>  1,
     servfail =>  2,
     nxdomain =>  3,
     notimp   =>  4,
     refused  =>  5,
     yxdomain =>  6, # Name Exists when it should not     [RFC 2136]
     yxrrset  =>  7, # RR Set Exists when it should not   [RFC 2136]
     nxrrset  =>  8, # RR Set that should exist does not  [RFC 2136]
     notauth  =>  9, # Server Not Authoritative for zone  [RFC 2136]
     notzone  => 10, # Name not contained in zone         [RFC 2136]
  # EDNS0  16    BADVERS   Bad OPT Version                    [RFC 2671]
  # EDNS0  16    BADSIG    TSIG Signature Failure             [RFC 2845]
  # EDNS0  17    BADKEY    Key not recognized                 [RFC 2845]
  # EDNS0  18    BADTIME   Signature out of time window       [RFC 2845]
  # EDNS0  19    BADMODE   Bad TKEY Mode                      [RFC 2930]
  # EDNS0  20    BADNAME   Duplicate key name                 [RFC 2930]
  # EDNS0  21    BADALG    Algorithm not supported            [RFC 2930]
     map +($_ => $_), 11..15
  );
  
  our %rcode_str = reverse %rcode_id;
  
  our %type_id = (
     a     =>   1,
     ns    =>   2,
     md    =>   3,
     mf    =>   4,
     cname =>   5,
     soa   =>   6,
     mb    =>   7,
     mg    =>   8,
     mr    =>   9,
     null  =>  10,
     wks   =>  11,
     ptr   =>  12,
     hinfo =>  13,
     minfo =>  14,
     mx    =>  15,
     txt   =>  16,
     sig   =>  24,
     key   =>  25,
     gpos  =>  27, # rfc1712
     aaaa  =>  28,
     loc   =>  29, # rfc1876
     srv   =>  33,
     naptr =>  35, # rfc2915
     dname =>  39, # rfc2672
     opt   =>  41,
     ds    =>  43, # rfc4034
     sshfp =>  44, # rfc4255
     rrsig =>  46, # rfc4034
     nsec  =>  47, # rfc4034
     dnskey=>  48, # rfc4034
     smimea=>  53, # rfc8162
     cds   =>  59, # rfc7344
     cdnskey=> 60, # rfc7344
     openpgpkey=> 61, # rfc7926
     csync =>  62, # rfc7929
     spf   =>  99,
     tkey  => 249,
     tsig  => 250,
     ixfr  => 251,
     axfr  => 252,
     mailb => 253,
     "*"   => 255,
     uri   => 256,
     caa   => 257, # rfc6844
  );
  
  our %type_str = reverse %type_id;
  
  our %class_id = (
     in   =>   1,
     ch   =>   3,
     hs   =>   4,
     none => 254,
     "*"  => 255,
  );
  
  our %class_str = reverse %class_id;
  
  sub _enc_name($) {
     pack "(C/a*)*", (split /\./, shift), ""
  }
  
  if ($] < 5.008) {
     # special slower 5.6 version
     *_enc_name = sub ($) {
        join "", map +(pack "C/a*", $_), (split /\./, shift), ""
     };
  }
  
  sub _enc_qd() {
     (_enc_name $_->[0]) . pack "nn",
       ($_->[1] > 0 ? $_->[1] : $type_id {$_->[1]}),
       ($_->[3] > 0 ? $_->[2] : $class_id{$_->[2] || "in"})
  }
  
  sub _enc_rr() {
     die "encoding of resource records is not supported";
  }
  
  =item $pkt = AnyEvent::DNS::dns_pack $dns
  
  Packs a perl data structure into a DNS packet. Reading RFC 1035 is strongly
  recommended, then everything will be totally clear. Or maybe not.
  
  Resource records are not yet encodable.
  
  Examples:
  
     # very simple request, using lots of default values:
     { rd => 1, qd => [ [ "host.domain", "a"] ] }
    
     # more complex example, showing how flags etc. are named:
    
     {
        id => 10000,
        op => "query",
        rc => "nxdomain",
    
        # flags
        qr => 1,
        aa => 0,
        tc => 0,
        rd => 0,
        ra => 0,
        ad => 0,
        cd => 0,
    
        qd => [@rr], # query section
        an => [@rr], # answer section
        ns => [@rr], # authority section
        ar => [@rr], # additional records section
     }
  
  =cut
  
  sub dns_pack($) {
     my ($req) = @_;
  
     pack "nn nnnn a* a* a* a* a*",
        $req->{id},
  
        ! !$req->{qr}   * 0x8000
        + $opcode_id{$req->{op}} * 0x0800
        + ! !$req->{aa} * 0x0400
        + ! !$req->{tc} * 0x0200
        + ! !$req->{rd} * 0x0100
        + ! !$req->{ra} * 0x0080
        + ! !$req->{ad} * 0x0020
        + ! !$req->{cd} * 0x0010
        + $rcode_id{$req->{rc}} * 0x0001,
  
        scalar @{ $req->{qd} || [] },
        scalar @{ $req->{an} || [] },
        scalar @{ $req->{ns} || [] },
        $EDNS0 + scalar @{ $req->{ar} || [] }, # EDNS0 option included here
  
        (join "", map _enc_qd, @{ $req->{qd} || [] }),
        (join "", map _enc_rr, @{ $req->{an} || [] }),
        (join "", map _enc_rr, @{ $req->{ns} || [] }),
        (join "", map _enc_rr, @{ $req->{ar} || [] }),
  
        ($EDNS0 ? pack "C nnNn", 0, 41, MAX_PKT, 0, 0 : "") # EDNS0 option
  }
  
  our $ofs;
  our $pkt;
  
  # bitches
  sub _dec_name {
     my @res;
     my $redir;
     my $ptr = $ofs;
     my $cnt;
  
     while () {
        return undef if ++$cnt >= 256; # to avoid DoS attacks
  
        my $len = ord substr $pkt, $ptr++, 1;
  
        if ($len >= 0xc0) {
           $ptr++;
           $ofs = $ptr if $ptr > $ofs;
           $ptr = (unpack "n", substr $pkt, $ptr - 2, 2) & 0x3fff;
        } elsif ($len) {
           push @res, substr $pkt, $ptr, $len;
           $ptr += $len;
        } else {
           $ofs = $ptr if $ptr > $ofs;
           return join ".", @res;
        }
     }
  }
  
  sub _dec_qd {
     my $qname = _dec_name;
     my ($qt, $qc) = unpack "nn", substr $pkt, $ofs; $ofs += 4;
     [$qname, $type_str{$qt} || $qt, $class_str{$qc} || $qc]
  }
  
  our %dec_rr = (
       1 => sub { join ".", unpack "C4", $_ }, # a
       2 => sub { local $ofs = $ofs - length; _dec_name }, # ns
       5 => sub { local $ofs = $ofs - length; _dec_name }, # cname
       6 => sub { 
               local $ofs = $ofs - length;
               my $mname = _dec_name;
               my $rname = _dec_name;
               ($mname, $rname, unpack "NNNNN", substr $pkt, $ofs)
            }, # soa
      11 => sub { ((join ".", unpack "C4", $_), unpack "C a*", substr $_, 4) }, # wks
      12 => sub { local $ofs = $ofs - length; _dec_name }, # ptr
      13 => sub { unpack "C/a* C/a*", $_ }, # hinfo
      15 => sub { local $ofs = $ofs + 2 - length; ((unpack "n", $_), _dec_name) }, # mx
      16 => sub { unpack "(C/a*)*", $_ }, # txt
      28 => sub { AnyEvent::Socket::format_ipv6 ($_) }, # aaaa
      33 => sub { local $ofs = $ofs + 6 - length; ((unpack "nnn", $_), _dec_name) }, # srv
      35 => sub { # naptr
         # requires perl 5.10, sorry
         my ($order, $preference, $flags, $service, $regexp, $offset) = unpack "nn C/a* C/a* C/a* .", $_;
         local $ofs = $ofs + $offset - length;
         ($order, $preference, $flags, $service, $regexp, _dec_name)
      },
      39 => sub { local $ofs = $ofs - length; _dec_name }, # dname
      99 => sub { unpack "(C/a*)*", $_ }, # spf
     257 => sub { unpack "CC/a*a*", $_ }, # caa
  );
  
  sub _dec_rr {
     my $name = _dec_name;
  
     my ($rt, $rc, $ttl, $rdlen) = unpack "nn N n", substr $pkt, $ofs; $ofs += 10;
     local $_ = substr $pkt, $ofs, $rdlen; $ofs += $rdlen;
  
     [
        $name,
        $type_str{$rt}  || $rt,
        $class_str{$rc} || $rc,
        $ttl,
        ($dec_rr{$rt} || sub { $_ })->(),
     ]
  }
  
  =item $dns = AnyEvent::DNS::dns_unpack $pkt
  
  Unpacks a DNS packet into a perl data structure.
  
  Examples:
  
     # an unsuccessful reply
     {
       'qd' => [
                 [ 'ruth.plan9.de.mach.uni-karlsruhe.de', '*', 'in' ]
               ],
       'rc' => 'nxdomain',
       'ar' => [],
       'ns' => [
                 [
                   'uni-karlsruhe.de',
                   'soa',
                   'in',
                   600,
                   'netserv.rz.uni-karlsruhe.de',
                   'hostmaster.rz.uni-karlsruhe.de',
                   2008052201, 10800, 1800, 2592000, 86400
                 ]
               ],
       'tc' => '',
       'ra' => 1,
       'qr' => 1,
       'id' => 45915,
       'aa' => '',
       'an' => [],
       'rd' => 1,
       'op' => 'query',
       '__' => '<original dns packet>',
     }
     
     # a successful reply
     
     {
       'qd' => [ [ 'www.google.de', 'a', 'in' ] ],
       'rc' => 0,
       'ar' => [
                 [ 'a.l.google.com', 'a', 'in', 3600, '209.85.139.9' ],
                 [ 'b.l.google.com', 'a', 'in', 3600, '64.233.179.9' ],
                 [ 'c.l.google.com', 'a', 'in', 3600, '64.233.161.9' ],
               ],
       'ns' => [
                 [ 'l.google.com', 'ns', 'in', 3600, 'a.l.google.com' ],
                 [ 'l.google.com', 'ns', 'in', 3600, 'b.l.google.com' ],
               ],
       'tc' => '',
       'ra' => 1,
       'qr' => 1,
       'id' => 64265,
       'aa' => '',
       'an' => [
                 [ 'www.google.de', 'cname', 'in', 3600, 'www.google.com' ],
                 [ 'www.google.com', 'cname', 'in', 3600, 'www.l.google.com' ],
                 [ 'www.l.google.com', 'a', 'in', 3600, '66.249.93.104' ],
                 [ 'www.l.google.com', 'a', 'in', 3600, '66.249.93.147' ],
               ],
       'rd' => 1,
       'op' => 0,
       '__' => '<original dns packet>',
     }
  
  =cut
  
  sub dns_unpack($) {
     local $pkt = shift;
     my ($id, $flags, $qd, $an, $ns, $ar)
        = unpack "nn nnnn A*", $pkt;
  
     local $ofs = 6 * 2;
  
     {
        __ => $pkt,
        id => $id,
        qr => ! ! ($flags & 0x8000),
        aa => ! ! ($flags & 0x0400),
        tc => ! ! ($flags & 0x0200),
        rd => ! ! ($flags & 0x0100),
        ra => ! ! ($flags & 0x0080),
        ad => ! ! ($flags & 0x0020),
        cd => ! ! ($flags & 0x0010),
        op => $opcode_str{($flags & 0x001e) >> 11},
        rc => $rcode_str{($flags & 0x000f)},
  
        qd => [map _dec_qd, 1 .. $qd],
        an => [map _dec_rr, 1 .. $an],
        ns => [map _dec_rr, 1 .. $ns],
        ar => [map _dec_rr, 1 .. $ar],
     }
  }
  
  #############################################################################
  
  =back
  
  =head3 Extending DNS Encoder and Decoder
  
  This section describes an I<experimental> method to extend the DNS encoder
  and decoder with new opcode, rcode, class and type strings, as well as
  resource record decoders.
  
  Since this is experimental, it can change, as anything can change, but
  this interface is expe ctedc to be relatively stable and was stable during
  the whole existance of C<AnyEvent::DNS> so far.
  
  Note that, since changing the decoder or encoder might break existing
  code, you should either be sure to control for this, or only temporarily
  change these values, e.g. like so:
  
     my $decoded = do {
        local $AnyEvent::DNS::opcode_str{7} = "yxrrset";
        AnyEvent::DNS::dns_unpack $mypkt
     };
  
  =over 4
  
  =item %AnyEvent::DNS::opcode_id, %AnyEvent::DNS::opcode_str
  
  Two hashes that map lowercase opcode strings to numerical id's (For the
  encoder), or vice versa (for the decoder). Example: add a new opcode
  string C<notzone>.
  
     $AnyEvent::DNS::opcode_id{notzone} = 10;
     $AnyEvent::DNS::opcode_str{10} = 'notzone';
  
  =item %AnyEvent::DNS::rcode_id, %AnyEvent::DNS::rcode_str
  
  Same as above, for for rcode values.
  
  =item %AnyEvent::DNS::class_id, %AnyEvent::DNS::class_str
  
  Same as above, but for resource record class names/values.
  
  =item %AnyEvent::DNS::type_id, %AnyEvent::DNS::type_str
  
  Same as above, but for resource record type names/values.
  
  =item %AnyEvent::DNS::dec_rr
  
  This hash maps resource record type values to code references. When
  decoding, they are called with C<$_> set to the undecoded data portion and
  C<$ofs> being the current byte offset. of the record. You should have a
  look at the existing implementations to understand how it works in detail,
  but here are two examples:
  
  Decode an A record. A records are simply four bytes with one byte per
  address component, so the decoder simply unpacks them and joins them with
  dots in between:
  
     $AnyEvent::DNS::dec_rr{1} = sub { join ".", unpack "C4", $_ };
  
  Decode a CNAME record, which contains a potentially compressed domain
  name.
  
     package AnyEvent::DNS; # for %dec_rr, $ofsd and &_dec_name
     $dec_rr{5} = sub { local $ofs = $ofs - length; _dec_name };
  
  =back
  
  =head2 THE AnyEvent::DNS RESOLVER CLASS
  
  This is the class which does the actual protocol work.
  
  =over 4
  
  =cut
  
  use Carp ();
  use Scalar::Util ();
  use Socket ();
  
  our $NOW;
  
  =item AnyEvent::DNS::resolver
  
  This function creates and returns a resolver that is ready to use and
  should mimic the default resolver for your system as good as possible. It
  is used by AnyEvent itself as well.
  
  It only ever creates one resolver and returns this one on subsequent calls
  - see C<$AnyEvent::DNS::RESOLVER>, below, for details.
  
  Unless you have special needs, prefer this function over creating your own
  resolver object.
  
  The resolver is created with the following parameters:
  
     untaint          enabled
     max_outstanding  $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS} (default 10)
  
  C<os_config> will be used for OS-specific configuration, unless
  C<$ENV{PERL_ANYEVENT_RESOLV_CONF}> is specified, in which case that file
  gets parsed.
  
  =item $AnyEvent::DNS::RESOLVER
  
  This variable stores the default resolver returned by
  C<AnyEvent::DNS::resolver>, or C<undef> when the default resolver hasn't
  been instantiated yet.
  
  One can provide a custom resolver (e.g. one with caching functionality)
  by storing it in this variable, causing all subsequent resolves done via
  C<AnyEvent::DNS::resolver> to be done via the custom one.
  
  =cut
  
  our $RESOLVER;
  
  sub resolver() {
     $RESOLVER || do {
        $RESOLVER = new AnyEvent::DNS
           untaint         => 1,
           max_outstanding => $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}*1 || 10,
        ;
  
        $ENV{PERL_ANYEVENT_RESOLV_CONF}
           ? $RESOLVER->_load_resolv_conf_file ($ENV{PERL_ANYEVENT_RESOLV_CONF})
           : $RESOLVER->os_config;
  
        $RESOLVER
     }
  }
  
  =item $resolver = new AnyEvent::DNS key => value...
  
  Creates and returns a new resolver.
  
  The following options are supported:
  
  =over 4
  
  =item server => [...]
  
  A list of server addresses (default: C<v127.0.0.1> or C<::1>) in network
  format (i.e. as returned by C<AnyEvent::Socket::parse_address> - both IPv4
  and IPv6 are supported).
  
  =item timeout => [...]
  
  A list of timeouts to use (also determines the number of retries). To make
  three retries with individual time-outs of 2, 5 and 5 seconds, use C<[2,
  5, 5]>, which is also the default.
  
  =item search => [...]
  
  The default search list of suffixes to append to a domain name (default: none).
  
  =item ndots => $integer
  
  The number of dots (default: C<1>) that a name must have so that the resolver
  tries to resolve the name without any suffixes first.
  
  =item max_outstanding => $integer
  
  Most name servers do not handle many parallel requests very well. This
  option limits the number of outstanding requests to C<$integer>
  (default: C<10>), that means if you request more than this many requests,
  then the additional requests will be queued until some other requests have
  been resolved.
  
  =item reuse => $seconds
  
  The number of seconds (default: C<300>) that a query id cannot be re-used
  after a timeout. If there was no time-out then query ids can be reused
  immediately.
  
  =item untaint => $boolean
  
  When true, then the resolver will automatically untaint results, and might
  also ignore certain environment variables.
  
  =back
  
  =cut
  
  sub new {
     my ($class, %arg) = @_;
  
     my $self = bless {
        server  => [],
        timeout => [2, 5, 5],
        search  => [],
        ndots   => 1,
        max_outstanding => 10,
        reuse   => 300,
        %arg,
        inhibit => 0,
        reuse_q => [],
     }, $class;
  
     # search should default to gethostname's domain
     # but perl lacks a good posix module
  
     # try to create an ipv4 and an ipv6 socket
     # only fail when we cannot create either
     my $got_socket;
  
     Scalar::Util::weaken (my $wself = $self);
  
     if (socket my $fh4, AF_INET , Socket::SOCK_DGRAM(), 0) {
        ++$got_socket;
  
        AnyEvent::fh_unblock $fh4;
        $self->{fh4} = $fh4;
        $self->{rw4} = AE::io $fh4, 0, sub {
           if (my $peer = recv $fh4, my $pkt, MAX_PKT, 0) {
              $wself->_recv ($pkt, $peer);
           }
        };
     }
  
     if (AF_INET6 && socket my $fh6, AF_INET6, Socket::SOCK_DGRAM(), 0) {
        ++$got_socket;
  
        $self->{fh6} = $fh6;
        AnyEvent::fh_unblock $fh6;
        $self->{rw6} = AE::io $fh6, 0, sub {
           if (my $peer = recv $fh6, my $pkt, MAX_PKT, 0) {
              $wself->_recv ($pkt, $peer);
           }
        };
     }
  
     $got_socket
        or Carp::croak "unable to create either an IPv4 or an IPv6 socket";
  
     $self->_compile;
  
     $self
  }
  
  # called to start asynchronous configuration
  sub _config_begin {
     ++$_[0]{inhibit};
  }
  
  # called when done with async config
  sub _config_done {
     --$_[0]{inhibit};
     $_[0]->_compile;
     $_[0]->_scheduler;
  }
  
  =item $resolver->parse_resolv_conf ($string)
  
  Parses the given string as if it were a F<resolv.conf> file. The following
  directives are supported (but not necessarily implemented).
  
  C<#>- and C<;>-style comments, C<nameserver>, C<domain>, C<search>, C<sortlist>,
  C<options> (C<timeout>, C<attempts>, C<ndots>).
  
  Everything else is silently ignored.
  
  =cut
  
  sub parse_resolv_conf {
     my ($self, $resolvconf) = @_;
  
     $self->{server} = [];
     $self->{search} = [];
  
     my $attempts;
  
     for (split /\n/, $resolvconf) {
        s/\s*[;#].*$//; # not quite legal, but many people insist
  
        if (/^\s*nameserver\s+(\S+)\s*$/i) {
           my $ip = $1;
           if (my $ipn = AnyEvent::Socket::parse_address ($ip)) {
              push @{ $self->{server} }, $ipn;
           } else {
              AE::log 5 => "nameserver $ip invalid and ignored, while parsing resolver config.";
           }
        } elsif (/^\s*domain\s+(\S*)\s*$/i) {
           $self->{search} = [$1];
        } elsif (/^\s*search\s+(.*?)\s*$/i) {
           $self->{search} = [split /\s+/, $1];
        } elsif (/^\s*sortlist\s+(.*?)\s*$/i) {
           # ignored, NYI
        } elsif (/^\s*options\s+(.*?)\s*$/i) {
           for (split /\s+/, $1) {
              if (/^timeout:(\d+)$/) {
                 $self->{timeout} = [$1];
              } elsif (/^attempts:(\d+)$/) {
                 $attempts = $1;
              } elsif (/^ndots:(\d+)$/) {
                 $self->{ndots} = $1;
              } else {
                 # debug, rotate, no-check-names, inet6
              }
           }
        } else {
           # silently skip stuff we don't understand
        }
     }
  
     $self->{timeout} = [($self->{timeout}[0]) x $attempts]
        if $attempts;
  
     $self->_compile;
  }
  
  sub _load_resolv_conf_file {
     my ($self, $resolv_conf) = @_;
  
     $self->_config_begin;
  
     require AnyEvent::IO;
     AnyEvent::IO::aio_load ($resolv_conf, sub {
        if (my ($contents) = @_) {
           $self->parse_resolv_conf ($contents);
        } else {
           AE::log 4 => "$resolv_conf: $!";
        }
  
        $self->_config_done;
     });
  }
  
  =item $resolver->os_config
  
  Tries so load and parse F</etc/resolv.conf> on portable operating
  systems. Tries various egregious hacks on windows to force the DNS servers
  and searchlist out of the system.
  
  This method must be called at most once before trying to resolve anything.
  
  =cut
  
  sub os_config {
     my ($self) = @_;
  
     $self->_config_begin;
  
     $self->{server} = [];
     $self->{search} = [];
  
     if ((AnyEvent::WIN32 || $^O =~ /cygwin/i)) {
        # TODO: this blocks the program, but should not, but I
        # am too lazy to implement and test it. need to boot windows. ugh.
  
        #no strict 'refs';
  
        # there are many options to find the current nameservers etc. on windows
        # all of them don't work consistently:
        # - the registry thing needs separate code on win32 native vs. cygwin
        # - the registry layout differs between windows versions
        # - calling windows api functions doesn't work on cygwin
        # - ipconfig uses locale-specific messages
  
        # we use Net::DNS::Resolver first, and if it fails, will fall back to
        # ipconfig parsing.
        unless (eval {
           # Net::DNS::Resolver uses a LOT of ram (~10mb), but what can we do :/
           # (this seems mostly to be due to Win32::API).
           require Net::DNS::Resolver;
           my $r = Net::DNS::Resolver->new;
  
           $r->nameservers
              or die;
  
           for my $s ($r->nameservers) {
              if (my $ipn = AnyEvent::Socket::parse_address ($s)) {
                 push @{ $self->{server} }, $ipn;
              }
           }
           $self->{search} = [$r->searchlist];
  
           1
        }) {
           # we use ipconfig parsing because, despite all its brokenness,
           # it seems quite stable in practise.
           # unfortunately it wants a console window.
           # for good measure, we append a fallback nameserver to our list.
  
           if (open my $fh, "ipconfig /all |") {
              # parsing strategy: we go through the output and look for
              # :-lines with DNS in them. everything in those is regarded as
              # either a nameserver (if it parses as an ip address), or a suffix
              # (all else).
  
              my $dns;
              local $_;
              while (<$fh>) {
                 if (s/^\s.*\bdns\b.*://i) {
                    $dns = 1;
                 } elsif (/^\S/ || /^\s[^:]{16,}: /) {
                    $dns = 0;
                 }
                 if ($dns && /^\s*(\S+)\s*$/) {
                    my $s = $1;
                    $s =~ s/%\d+(?!\S)//; # get rid of ipv6 scope id
                    if (my $ipn = AnyEvent::Socket::parse_address ($s)) {
                       push @{ $self->{server} }, $ipn;
                    } else {
                       push @{ $self->{search} }, $s;
                    }
                 }
              }
           }
        }
  
        # always add the fallback servers on windows
        push @{ $self->{server} }, @DNS_FALLBACK;
  
        $self->_config_done;
     } else {
        # try /etc/resolv.conf everywhere else
  
        require AnyEvent::IO;
        AnyEvent::IO::aio_stat ("/etc/resolv.conf", sub {
           $self->_load_resolv_conf_file ("/etc/resolv.conf")
              if @_;
           $self->_config_done;
        });
     }
  }
  
  =item $resolver->timeout ($timeout, ...)
  
  Sets the timeout values. See the C<timeout> constructor argument (and
  note that this method expects the timeout values themselves, not an
  array-reference).
  
  =cut
  
  sub timeout {
     my ($self, @timeout) = @_;
  
     $self->{timeout} = \@timeout;
     $self->_compile;
  }
  
  =item $resolver->max_outstanding ($nrequests)
  
  Sets the maximum number of outstanding requests to C<$nrequests>. See the
  C<max_outstanding> constructor argument.
  
  =cut
  
  sub max_outstanding {
     my ($self, $max) = @_;
  
     $self->{max_outstanding} = $max;
     $self->_compile;
  }
  
  sub _compile {
     my $self = shift;
  
     my %search; $self->{search} = [grep 0 < length, grep !$search{$_}++, @{ $self->{search} }];
     my %server; $self->{server} = [grep 0 < length, grep !$server{$_}++, @{ $self->{server} }];
  
     unless (@{ $self->{server} }) {
        # use 127.0.0.1/::1 by default, add public nameservers as fallback
        my $default = $AnyEvent::PROTOCOL{ipv6} > $AnyEvent::PROTOCOL{ipv4}
                      ? "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1" : "\x7f\x00\x00\x01";
        $self->{server} = [$default, @DNS_FALLBACK];
     }
  
     my @retry;
  
     for my $timeout (@{ $self->{timeout} }) {
        for my $server (@{ $self->{server} }) {
           push @retry, [$server, $timeout];
        }
     }
  
     $self->{retry} = \@retry;
  }
  
  sub _feed {
     my ($self, $res) = @_;
  
     ($res) = $res =~ /^(.*)$/s
        if AnyEvent::TAINT && $self->{untaint};
  
     $res = dns_unpack $res
        or return;
  
     my $id = $self->{id}{$res->{id}};
  
     return unless ref $id;
  
     $NOW = time;
     $id->[1]->($res);
  }
  
  sub _recv {
     my ($self, $pkt, $peer) = @_;
  
     # we ignore errors (often one gets port unreachable, but there is
     # no good way to take advantage of that.
  
     my ($port, $host) = AnyEvent::Socket::unpack_sockaddr ($peer);
  
     return unless $port == DOMAIN_PORT && grep $_ eq $host, @{ $self->{server} };
  
     $self->_feed ($pkt);
  }
  
  sub _free_id {
     my ($self, $id, $timeout) = @_;
  
     if ($timeout) {
        # we need to block the id for a while
        $self->{id}{$id} = 1;
        push @{ $self->{reuse_q} }, [$NOW + $self->{reuse}, $id];
     } else {
        # we can quickly recycle the id
        delete $self->{id}{$id};
     }
  
     --$self->{outstanding};
     $self->_scheduler;
  }
  
  # execute a single request, involves sending it with timeouts to multiple servers
  sub _exec {
     my ($self, $req) = @_;
  
     my $retry; # of retries
     my $do_retry;
  
     $do_retry = sub {
        my $retry_cfg = $self->{retry}[$retry++]
           or do {
              # failure
              $self->_free_id ($req->[2], $retry > 1);
              undef $do_retry; return $req->[1]->();
           };
  
        my ($server, $timeout) = @$retry_cfg;
        
        $self->{id}{$req->[2]} = [(AE::timer $timeout, 0, sub {
           $NOW = time;
  
           # timeout, try next
           &$do_retry if $do_retry;
        }), sub {
           my ($res) = @_;
  
           if ($res->{tc}) {
              # success, but truncated, so use tcp
              AnyEvent::Socket::tcp_connect (AnyEvent::Socket::format_address ($server), DOMAIN_PORT, sub {
                 return unless $do_retry; # some other request could have invalidated us already
  
                 my ($fh) = @_
                    or return &$do_retry;
  
                 require AnyEvent::Handle;
  
                 my $handle; $handle = new AnyEvent::Handle
                    fh       => $fh,
                    timeout  => $timeout,
                    on_error => sub {
                       undef $handle;
                       return unless $do_retry; # some other request could have invalidated us already
                       # failure, try next
                       &$do_retry;
                    };
  
                 $handle->push_write (pack "n/a*", $req->[0]);
                 $handle->push_read (chunk => 2, sub {
                    $handle->unshift_read (chunk => (unpack "n", $_[1]), sub {
                       undef $handle;
                       $self->_feed ($_[1]);
                    });
                 });
  
              }, sub { $timeout });
  
           } else {
              # success
              $self->_free_id ($req->[2], $retry > 1);
              undef $do_retry; return $req->[1]->($res);
           }
        }];
        
        my $sa = AnyEvent::Socket::pack_sockaddr (DOMAIN_PORT, $server);
  
        my $fh = AF_INET == AnyEvent::Socket::sockaddr_family ($sa)
                 ? $self->{fh4} : $self->{fh6}
           or return &$do_retry;
  
        send $fh, $req->[0], 0, $sa;
     };
  
     &$do_retry;
  }
  
  sub _scheduler {
     my ($self) = @_;
  
     return if $self->{inhibit};
  
     #no strict 'refs';
  
     $NOW = time;
  
     # first clear id reuse queue
     delete $self->{id}{ (shift @{ $self->{reuse_q} })->[1] }
        while @{ $self->{reuse_q} } && $self->{reuse_q}[0][0] <= $NOW;
  
     while ($self->{outstanding} < $self->{max_outstanding}) {
  
        if (@{ $self->{reuse_q} } >= 30000) {
           # we ran out of ID's, wait a bit
           $self->{reuse_to} ||= AE::timer $self->{reuse_q}[0][0] - $NOW, 0, sub {
              delete $self->{reuse_to};
              $self->_scheduler;
           };
           last;
        }
  
        if (my $req = shift @{ $self->{queue} }) {
           # found a request in the queue, execute it
           while () {
              $req->[2] = int rand 65536;
              last unless exists $self->{id}{$req->[2]};
           }
  
           ++$self->{outstanding};
           $self->{id}{$req->[2]} = 1;
           substr $req->[0], 0, 2, pack "n", $req->[2];
  
           $self->_exec ($req);
  
        } elsif (my $cb = shift @{ $self->{wait} }) {
           # found a wait_for_slot callback
           $cb->($self);
  
        } else {
           # nothing to do, just exit
           last;
        }
     }
  }
  
  =item $resolver->request ($req, $cb->($res))
  
  This is the main low-level workhorse for sending DNS requests.
  
  This function sends a single request (a hash-ref formated as specified
  for C<dns_pack>) to the configured nameservers in turn until it gets a
  response. It handles timeouts, retries and automatically falls back to
  virtual circuit mode (TCP) when it receives a truncated reply. It does not
  handle anything else, such as the domain searchlist or relative names -
  use C<< ->resolve >> for that.
  
  Calls the callback with the decoded response packet if a reply was
  received, or no arguments in case none of the servers answered.
  
  =cut
  
  sub request($$) {
     my ($self, $req, $cb) = @_;
  
     # _enc_name barfs on names that are too long, which is often outside
     # program control, so check for too long names here.
     for (@{ $req->{qd} }) {
        return AE::postpone sub { $cb->(undef) }
           if 255 < length $_->[0];
     }
  
     push @{ $self->{queue} }, [dns_pack $req, $cb];
     $self->_scheduler;
  }
  
  =item $resolver->resolve ($qname, $qtype, %options, $cb->(@rr))
  
  Queries the DNS for the given domain name C<$qname> of type C<$qtype>.
  
  A C<$qtype> is either a numerical query type (e.g. C<1> for A records) or
  a lowercase name (you have to look at the source to see which aliases are
  supported, but all types from RFC 1035, C<aaaa>, C<srv>, C<spf> and a few
  more are known to this module). A C<$qtype> of "*" is supported and means
  "any" record type.
  
  The callback will be invoked with a list of matching result records or
  none on any error or if the name could not be found.
  
  CNAME chains (although illegal) are followed up to a length of 10.
  
  The callback will be invoked with arraryefs of the form C<[$name,
  $type, $class, $ttl, @data>], where C<$name> is the domain name,
  C<$type> a type string or number, C<$class> a class name, C<$ttl> is the
  remaining time-to-live and C<@data> is resource-record-dependent data, in
  seconds. For C<a> records, this will be the textual IPv4 addresses, for
  C<ns> or C<cname> records this will be a domain name, for C<txt> records
  these are all the strings and so on.
  
  All types mentioned in RFC 1035, C<aaaa>, C<srv>, C<naptr> and C<spf> are
  decoded. All resource records not known to this module will have the raw
  C<rdata> field as fifth array element.
  
  Note that this resolver is just a stub resolver: it requires a name server
  supporting recursive queries, will not do any recursive queries itself and
  is not secure when used against an untrusted name server.
  
  The following options are supported:
  
  =over 4
  
  =item search => [$suffix...]
  
  Use the given search list (which might be empty), by appending each one
  in turn to the C<$qname>. If this option is missing then the configured
  C<ndots> and C<search> values define its value (depending on C<ndots>, the
  empty suffix will be prepended or appended to that C<search> value). If
  the C<$qname> ends in a dot, then the searchlist will be ignored.
  
  =item accept => [$type...]
  
  Lists the acceptable result types: only result types in this set will be
  accepted and returned. The default includes the C<$qtype> and nothing
  else. If this list includes C<cname>, then CNAME-chains will not be
  followed (because you asked for the CNAME record).
  
  =item class => "class"
  
  Specify the query class ("in" for internet, "ch" for chaosnet and "hs" for
  hesiod are the only ones making sense). The default is "in", of course.
  
  =back
  
  Examples:
  
     # full example, you can paste this into perl:
     use Data::Dumper;
     use AnyEvent::DNS;
     AnyEvent::DNS::resolver->resolve (
        "google.com", "*", my $cv = AnyEvent->condvar);
     warn Dumper [$cv->recv];
  
     # shortened result:
     # [
     #   [ 'google.com', 'soa', 'in', 3600, 'ns1.google.com', 'dns-admin.google.com',
     #     2008052701, 7200, 1800, 1209600, 300 ],
     #   [
     #     'google.com', 'txt', 'in', 3600,
     #     'v=spf1 include:_netblocks.google.com ~all'
     #   ],
     #   [ 'google.com', 'a', 'in', 3600, '64.233.187.99' ],
     #   [ 'google.com', 'mx', 'in', 3600, 10, 'smtp2.google.com' ],
     #   [ 'google.com', 'ns', 'in', 3600, 'ns2.google.com' ],
     # ]
  
     # resolve a records:
     $res->resolve ("ruth.plan9.de", "a", sub { warn Dumper [@_] });
  
     # result:
     # [
     #   [ 'ruth.schmorp.de', 'a', 'in', 86400, '129.13.162.95' ]
     # ]
  
     # resolve any records, but return only a and aaaa records:
     $res->resolve ("test1.laendle", "*",
        accept => ["a", "aaaa"],
        sub {
           warn Dumper [@_];
        }
     );
  
     # result:
     # [
     #   [ 'test1.laendle', 'a', 'in', 86400, '10.0.0.255' ],
     #   [ 'test1.laendle', 'aaaa', 'in', 60, '3ffe:1900:4545:0002:0240:0000:0000:f7e1' ]
     # ]
  
  =cut
  
  sub resolve($%) {
     my $cb = pop;
     my ($self, $qname, $qtype, %opt) = @_;
  
     $self->wait_for_slot (sub {
        my $self = shift;
  
        my @search = $qname =~ s/\.$//
           ? ""
           : $opt{search}
             ? @{ $opt{search} }
             : ($qname =~ y/.//) >= $self->{ndots}
               ? ("", @{ $self->{search} })
               : (@{ $self->{search} }, "");
  
        my $class = $opt{class} || "in";
  
        my %atype = $opt{accept}
           ? map +($_ => 1), @{ $opt{accept} }
           : ($qtype => 1);
  
        # advance in searchlist
        my ($do_search, $do_req);
        
        $do_search = sub {
           @search
              or (undef $do_search), (undef $do_req), return $cb->();
  
           (my $name = lc "$qname." . shift @search) =~ s/\.$//;
           my $depth = 10;
  
           # advance in cname-chain
           $do_req = sub {
              $self->request ({
                 rd => 1,
                 qd => [[$name, $qtype, $class]],
              }, sub {
                 my ($res) = @_
                    or return $do_search->();
  
                 my $cname;
  
                 while () {
                    # results found?
                    my @rr = grep $name eq lc $_->[0] && ($atype{"*"} || $atype{$_->[1]}), @{ $res->{an} };
  
                    (undef $do_search), (undef $do_req), return $cb->(@rr)
                       if @rr;
  
                    # see if there is a cname we can follow
                    my @rr = grep $name eq lc $_->[0] && $_->[1] eq "cname", @{ $res->{an} };
  
                    if (@rr) {
                       $depth--
                          or return $do_search->(); # cname chain too long
  
                       $cname = 1;
                       $name = lc $rr[0][4];
  
                    } elsif ($cname) {
                       # follow the cname
                       return $do_req->();
  
                    } else {
                       # no, not found anything
                       return $do_search->();
                    }
                  }
              });
           };
  
           $do_req->();
        };
  
        $do_search->();
     });
  }
  
  =item $resolver->wait_for_slot ($cb->($resolver))
  
  Wait until a free request slot is available and call the callback with the
  resolver object.
  
  A request slot is used each time a request is actually sent to the
  nameservers: There are never more than C<max_outstanding> of them.
  
  Although you can submit more requests (they will simply be queued until
  a request slot becomes available), sometimes, usually for rate-limiting
  purposes, it is useful to instead wait for a slot before generating the
  request (or simply to know when the request load is low enough so one can
  submit requests again).
  
  This is what this method does: The callback will be called when submitting
  a DNS request will not result in that request being queued. The callback
  may or may not generate any requests in response.
  
  Note that the callback will only be invoked when the request queue is
  empty, so this does not play well if somebody else keeps the request queue
  full at all times.
  
  =cut
  
  sub wait_for_slot {
     my ($self, $cb) = @_;
  
     push @{ $self->{wait} }, $cb;
     $self->_scheduler;
  }
  
  use AnyEvent::Socket (); # circular dependency, so do not import anything and do it at the end
  
  =back
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
ANYEVENT_DNS

$fatpacked{"AnyEvent/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DEBUG';
  =head1 NAME
  
  AnyEvent::Debug - debugging utilities for AnyEvent
  
  =head1 SYNOPSIS
  
     use AnyEvent::Debug;
  
     # create an interactive shell into the program
     my $shell = AnyEvent::Debug::shell "unix/", "/home/schmorp/myshell";
     # then on the shell: "socat readline /home/schmorp/myshell"
  
  =head1 DESCRIPTION
  
  This module provides functionality hopefully useful for debugging.
  
  At the moment, "only" an interactive shell is implemented. This shell
  allows you to interactively "telnet into" your program and execute Perl
  code, e.g. to look at global variables.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::Debug;
  
  use B ();
  use Carp ();
  use Errno ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  use AnyEvent::Socket ();
  use AnyEvent::Log ();
  
  our $TRACE = 1; # trace status
  
  our ($TRACE_LOGGER, $TRACE_ENABLED);
  
  # cache often-used strings, purely to save memory, at the expense of speed
  our %STRCACHE;
  
  =item $shell = AnyEvent::Debug::shell $host, $service
  
  This function binds on the given host and service port and returns a
  shell object, which determines the lifetime of the shell. Any number
  of connections are accepted on the port, and they will give you a very
  primitive shell that simply executes every line you enter.
  
  All commands will be executed "blockingly" with the socket C<select>ed for
  output. For a less "blocking" interface see L<Coro::Debug>.
  
  The commands will be executed in the C<AnyEvent::Debug::shell> package,
  which currently has "help" and a few other commands, and can be freely
  modified by all shells. Code is evaluated under C<use strict 'subs'>.
  
  Every shell has a logging context (C<$LOGGER>) that is attached to
  C<$AnyEvent::Log::COLLECT>), which is especially useful to gether debug
  and trace messages.
  
  As a general programming guide, consider the beneficial aspects of
  using more global (C<our>) variables than local ones (C<my>) in package
  scope: Earlier all my modules tended to hide internal variables inside
  C<my> variables, so users couldn't accidentally access them. Having
  interactive access to your programs changed that: having internal
  variables still in the global scope means you can debug them easier.
  
  As no authentication is done, in most cases it is best not to use a TCP
  port, but a unix domain socket, whcih can be put wherever you can access
  it, but not others:
  
     our $SHELL = AnyEvent::Debug::shell "unix/", "/home/schmorp/shell";
  
  Then you can use a tool to connect to the shell, such as the ever
  versatile C<socat>, which in addition can give you readline support:
  
     socat readline /home/schmorp/shell
     # or:
     cd /home/schmorp; socat readline unix:shell
  
  Socat can even give you a persistent history:
  
     socat readline,history=.anyevent-history unix:shell
  
  Binding on C<127.0.0.1> (or C<::1>) might be a less secure but sitll not
  totally insecure (on single-user machines) alternative to let you use
  other tools, such as telnet:
  
     our $SHELL = AnyEvent::Debug::shell "127.1", "1357";
  
  And then:
  
     telnet localhost 1357
  
  =cut
  
  sub shell($$) {
     local $TRACE = 0;
  
     AnyEvent::Socket::tcp_server $_[0], $_[1], sub {
        my ($fh, $host, $port) = @_;
  
        syswrite $fh, "Welcome, $host:$port, use 'help' for more info!\015\012> ";
        my $rbuf;
  
        my $logger = new AnyEvent::Log::Ctx
           log_cb => sub {
              syswrite $fh, shift;
              0
           };
  
        my $logger_guard = AnyEvent::Util::guard {
           $AnyEvent::Log::COLLECT->detach ($logger);
        };
        $AnyEvent::Log::COLLECT->attach ($logger);
  
        local $TRACE = 0;
        my $rw; $rw = AE::io $fh, 0, sub {
           my $len = sysread $fh, $rbuf, 1024, length $rbuf;
  
           $logger_guard if 0; # reference it
  
           if (defined $len ? $len == 0 : ($! != Errno::EAGAIN && $! != Errno::EWOULDBLOCK)) {
              undef $rw;
           } else {
              while ($rbuf =~ s/^(.*)\015?\012//) {
                 my $line = $1;
  
                 AnyEvent::fh_block $fh;
  
                 if ($line =~ /^\s*exit\b/) {
                    syswrite $fh, "sorry, no... if you want to execute exit, try CORE::exit.\015\012";
                 } elsif ($line =~ /^\s*coro\b\s*(.*)/) {
                    my $arg = $1;
                    if (eval { require Coro; require Coro::Debug }) {
                       if ($arg =~ /\S/) {
                          Coro::async (sub {
                             select $fh;
                             Coro::Debug::command ($arg);
                             local $| = 1; # older Coro versions do not flush
                             syswrite $fh, "> ";
                          });
                          return;
                       } else {
                          undef $rw;
                          syswrite $fh, "switching to Coro::Debug...\015\012";
                          Coro::async (sub { Coro::Debug::session ($fh) });
                          return;
                       }
                    } else {
                       syswrite $fh, "Coro not available.\015\012";
                    }
  
                 } else {
                    package AnyEvent::Debug::shell;
  
                    no strict 'vars';
                    local $LOGGER = $logger;
                    my $old_stdout = select $fh;
                    local $| = 1;
  
                    my @res = eval $line;
  
                    select $old_stdout;
                    syswrite $fh, "$@" if $@;
                    syswrite $fh, "\015\012";
  
                    if (@res > 1) {
                       syswrite $fh, "$_: $res[$_]\015\012" for 0 .. $#res;
                    } elsif (@res == 1) {
                       syswrite $fh, "$res[0]\015\012";
                    }
                 }
  
                 syswrite $fh, "> ";
                 AnyEvent::fh_unblock $fh;
              }
           }
        };
     }
  }
  
  {
     package AnyEvent::Debug::shell;
  
     our $LOGGER;
  
     sub help() {
        <<EOF
  help         this command
  wr [level]   sets wrap level to level (or toggles if missing)
  v [level]    sets verbosity (or toggles between 0 and 9 if missing)
  wl 'regex'   print wrapped watchers matching the regex (or all if missing)
  i id,...     prints the watcher with the given ids in more detail
  t            enable tracing for newly created watchers (enabled by default)
  ut           disable tracing for newly created watchers
  t  id,...    enable tracing for the given watcher (enabled by default)
  ut id,...    disable tracing for the given watcher
  w id,...     converts the watcher ids to watcher objects (for scripting)
  coro xxx     run xxx as Coro::Debug shell command, if available
  coro         switch to Coro::Debug shell, if available
  EOF
     }
  
     sub wl(;$) {
        my $re = @_ ? qr<$_[0]>i : qr<.>;
  
        my %res;
  
        while (my ($k, $v) = each %AnyEvent::Debug::Wrapped) {
           my $s = "$v";
           $res{$s} = $k . (exists $v->{error} ? "*" : " ")
              if $s =~ $re;
        }
  
        join "", map "$res{$_} $_\n", sort keys %res
     }
  
     sub w {
        map {
           $AnyEvent::Debug::Wrapped{$_} || do {
              print "$_: no such wrapped watcher.\n";
              ()
           }
        } @_
     }
  
     sub i {
        join "",
           map $_->id . " $_\n" . $_->verbose . "\n",
              &w
     }
  
     sub wr {
        AnyEvent::Debug::wrap (@_);
  
        "wrap level now $AnyEvent::Debug::WRAP_LEVEL"
     }
  
     sub t {
        if (@_) {
           @_ = &w;
           $_->trace (1)
              for @_;
           "tracing enabled for @_."
        } else {
           $AnyEvent::Debug::TRACE = 1;
           "tracing for newly created watchers is now enabled."
        }
     }
  
     sub u {
        if (@_) {
           @_ = &w;
           $_->trace (0)
              for @_;
           "tracing disabled for @_."
        } else {
           $AnyEvent::Debug::TRACE = 0;
           "tracing for newly created watchers is now disabled."
        }
     }
  
     sub v {
        $LOGGER->level (@_ ? $_[0] : $LOGGER->[1] ? 0 : 9);
  
        "verbose logging is now " . ($LOGGER->[1] ? "enabled" : "disabled") . "."
     }
  }
  
  =item AnyEvent::Debug::wrap [$level]
  
  Sets the instrumenting/wrapping level of all watchers that are being
  created after this call. If no C<$level> has been specified, then it
  toggles between C<0> and C<1>.
  
  The default wrap level is C<0>, or whatever
  C<$ENV{PERL_ANYEVENT_DEBUG_WRAP}> specifies.
  
  A level of C<0> disables wrapping, i.e. AnyEvent works normally, and in
  its most efficient mode.
  
  A level of C<1> or higher enables wrapping, which replaces all watchers
  by AnyEvent::Debug::Wrapped objects, stores the location where a
  watcher was created and wraps the callback to log all invocations at
  "trace" loglevel if tracing is enabled fore the watcher. The initial
  state of tracing when creating a watcher is taken from the global
  variable C<$AnyEvent:Debug::TRACE>. The default value of that variable
  is C<1>, but it can make sense to set it to C<0> and then do C<< local
  $AnyEvent::Debug::TRACE = 1 >> in a block where you create "interesting"
  watchers. Tracing can also be enabled and disabled later by calling the
  watcher's C<trace> method.
  
  The wrapper will also count how many times the callback was invoked and
  will record up to ten runtime errors with corresponding backtraces. It
  will also log runtime errors at "error" loglevel.
  
  To see the trace messages, you can invoke your program with
  C<PERL_ANYEVENT_VERBOSE=9>, or you can use AnyEvent::Log to divert
  the trace messages in any way you like (the EXAMPLES section in
  L<AnyEvent::Log> has some examples).
  
  A level of C<2> does everything that level C<1> does, but also stores a
  full backtrace of the location the watcher was created, which slows down
  watcher creation considerably.
  
  Every wrapped watcher will be linked into C<%AnyEvent::Debug::Wrapped>,
  with its address as key. The C<wl> command in the debug shell can be used
  to list watchers.
  
  Instrumenting can increase the size of each watcher multiple times, and,
  especially when backtraces are involved, also slows down watcher creation
  a lot.
  
  Also, enabling and disabling instrumentation will not recover the full
  performance that you had before wrapping (the AE::xxx functions will stay
  slower, for example).
  
  If you are developing your program, also consider using AnyEvent::Strict
  to check for common mistakes.
  
  =cut
  
  our $WRAP_LEVEL;
  our $TRACE_CUR;
  our $POST_DETECT;
  
  sub wrap(;$) {
     my $PREV_LEVEL = $WRAP_LEVEL;
     $WRAP_LEVEL = @_ ? 0+shift : $WRAP_LEVEL ? 0 : 1;
  
     if ($AnyEvent::MODEL) {
        if ($WRAP_LEVEL && !$PREV_LEVEL) {
           $TRACE_LOGGER = AnyEvent::Log::logger trace => \$TRACE_ENABLED;
           AnyEvent::_isa_hook 0 => "AnyEvent::Debug::Wrap", 1;
           AnyEvent::Debug::Wrap::_reset ();
        } elsif (!$WRAP_LEVEL && $PREV_LEVEL) {
           AnyEvent::_isa_hook 0 => undef;
        }
     } else {
        $POST_DETECT ||= AnyEvent::post_detect {
           undef $POST_DETECT;
           return unless $WRAP_LEVEL;
  
           (my $level, $WRAP_LEVEL) = ($WRAP_LEVEL, undef);
  
           require AnyEvent::Strict unless $AnyEvent::Strict::VERSION;
  
           AnyEvent::post_detect { # make sure we run after AnyEvent::Strict
              wrap ($level);
           };
        };
     }
  }
  
  =item AnyEvent::Debug::path2mod $path
  
  Tries to replace a path (e.g. the file name returned by caller)
  by a module name. Returns the path unchanged if it fails.
  
  Example:
  
     print AnyEvent::Debug::path2mod "/usr/lib/perl5/AnyEvent/Debug.pm";
     # might print "AnyEvent::Debug"
  
  =cut
  
  sub path2mod($) {
     keys %INC; # reset iterator
  
     while (my ($k, $v) = each %INC) {
        if ($_[0] eq $v) {
           $k =~ s%/%::%g if $k =~ s/\.pm$//;
           return $k;
        }
     }
  
     my $path = shift;
  
     $path =~ s%^\./%%;
  
     $path
  }
  
  =item AnyEvent::Debug::cb2str $cb
  
  Using various gambits, tries to convert a callback (e.g. a code reference)
  into a more useful string.
  
  Very useful if you debug a program and have some callback, but you want to
  know where in the program the callback is actually defined.
  
  =cut
  
  sub cb2str($) {
     my $cb = shift;
  
     "CODE" eq ref $cb
        or return "$cb";
  
     eval {
        my $cv = B::svref_2object ($cb);
  
        my $gv = $cv->GV
           or return "$cb";
  
        my $name = $gv->NAME;
  
        return (AnyEvent::Debug::path2mod $gv->FILE) . ":" . $gv->LINE
           if $name eq "__ANON__";
  
        $gv->STASH->NAME . "::" . $name;
     } || "$cb"
  }
  
  sub sv2str($) {
     if (ref $_[0]) {
        if (ref $_[0] eq "CODE") {
           return "$_[0]=" . cb2str $_[0];
        } else {
           return "$_[0]";
        }
     } else {
        for ("\'$_[0]\'") { # make copy
           substr $_, $Carp::MaxArgLen, length, "'..."
              if length > $Carp::MaxArgLen;
           return $_;
        }
     }
  }
  
  =item AnyEvent::Debug::backtrace [$skip]
  
  Creates a backtrace (actually an AnyEvent::Debug::Backtrace object
  that you can stringify), not unlike the Carp module would. Unlike the
  Carp module it resolves some references (such as callbacks) to more
  user-friendly strings, has a more succinct output format and most
  importantly: doesn't leak memory like hell.
  
  The reason it creates an object is to save time, as formatting can be
  done at a later time. Still, creating a backtrace is a relatively slow
  operation.
  
  =cut
  
  sub backtrace(;$) {
     my $w = shift;
  
     my (@bt, @c);
     my ($modlen, $sub);
  
     for (;;) {
        #         0          1      2            3         4           5          6            7       8         9         10
        # ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
        package DB;
        @c = caller $w++
           or last;
        package AnyEvent::Debug; # no block for speed reasons
  
        if ($c[7]) {
           $sub = "require $c[6]";
        } elsif (defined $c[6]) {
           $sub = "eval \"\"";
        } else {
           $sub = ($c[4] ? "" : "&") . $c[3];
  
           $sub .= "("
                   . (join ",",
                         map sv2str $DB::args[$_],
                            0 .. (@DB::args < $Carp::MaxArgNums ? @DB::args : $Carp::MaxArgNums) - 1)
                   . ")"
              if $c[4];
        }
  
        push @bt, [\($STRCACHE{$c[1]} ||= $c[1]), $c[2], $sub];
     }
  
     @DB::args = ();
  
     bless \@bt, "AnyEvent::Debug::Backtrace"
  }
  
  =back
  
  =cut
  
  package AnyEvent::Debug::Wrap;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Scalar::Util ();
  use Carp ();
  
  sub _reset {
     for my $name (qw(io timer signal child idle)) {
        my $super = "SUPER::$name";
  
        *$name = sub {
           my ($self, %arg) = @_;
  
           my $w;
  
           my $t = $TRACE;
  
           my ($pkg, $file, $line, $sub);
           
           $w = 0;
           do {
              ($pkg, $file, $line) = caller $w++;
           } while $pkg =~ /^(?:AE|AnyEvent::(?:Socket|Handle|Util|Debug|Strict|Base|CondVar|CondVar::Base|Impl::.*)|Coro::AnyEvent::CondVar)$/;
  
           $sub = (caller $w)[3];
  
           my $cb = $arg{cb};
           $arg{cb} = sub {
              ++$w->{called};
  
              local $TRACE_CUR = $w;
  
              $TRACE_LOGGER->("enter $w") if $TRACE_ENABLED && $t;
              eval {
                 local $SIG{__DIE__} = sub {
                    die $_[0] . AnyEvent::Debug::backtrace
                       if defined $^S;
                 };
                 &$cb;
              };
              if ($@) {
                 my $err = "$@";
                 push @{ $w->{error} }, [AE::now, $err]
                    if @{ $w->{error} } < 10;
                 AE::log die => "($w) $err"
                    or warn "($w) $err";
              }
              $TRACE_LOGGER->("leave $w") if $TRACE_ENABLED && $t;
           };
  
           $self = bless {
              type   => $name,
              w      => $self->$super (%arg),
              rfile  => \($STRCACHE{$file} ||= $file),
              line   => $line,
              sub    => $sub,
              cur    => "$TRACE_CUR",
              now    => AE::now,
              arg    => \%arg,
              cb     => $cb,
              called => 0,
              rt     => \$t,
           }, "AnyEvent::Debug::Wrapped";
  
           delete $arg{cb};
  
           $self->{bt} = AnyEvent::Debug::backtrace 1
              if $WRAP_LEVEL >= 2;
  
           Scalar::Util::weaken ($w = $self);
           Scalar::Util::weaken ($AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $self} = $self);
  
           $TRACE_LOGGER->("creat $w") if $TRACE_ENABLED && $t;
  
           $self
        };
     }
  }
  
  package AnyEvent::Debug::Wrapped;
  
  =head1 THE AnyEvent::Debug::Wrapped CLASS
  
  All watchers created while the wrap level is non-zero will be wrapped
  inside an AnyEvent::Debug::Wrapped object. The address of the
  wrapped watcher will become its ID - every watcher will be stored in
  C<$AnyEvent::Debug::Wrapped{$id}>.
  
  These wrapper objects can be stringified and have some methods defined on
  them.
  
  For debugging, of course, it can be helpful to look into these objects,
  which is why this is documented here, but this might change at any time in
  future versions.
  
  Each object is a relatively standard hash with the following members:
  
     type   => name of the method used ot create the watcher (e.g. C<io>, C<timer>).
     w      => the actual watcher
     rfile  => reference to the filename of the file the watcher was created in
     line   => line number where it was created
     sub    => function name (or a special string) which created the watcher
     cur    => if created inside another watcher callback, this is the string rep of the other watcher
     now    => the timestamp (AE::now) when the watcher was created
     arg    => the arguments used to create the watcher (sans C<cb>)
     cb     => the original callback used to create the watcher
     called => the number of times the callback was called
  
  Each object supports the following mehtods (warning: these are only
  available on wrapped watchers, so are best for interactive use via the
  debug shell).
  
  =over 4
  
  =cut
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use overload
     '""'     => sub {
        $_[0]{str} ||= do {
           my ($pkg, $line) = @{ $_[0]{caller} };
  
           my $mod = AnyEvent::Debug::path2mod ${ $_[0]{rfile} };
           my $sub = $_[0]{sub};
  
           if (defined $sub) {
              $sub =~ s/^\Q$mod\E:://;
              $sub = "($sub)";
           }
  
           "$mod:$_[0]{line}$sub>$_[0]{type}>"
           . (AnyEvent::Debug::cb2str $_[0]{cb})
        };
     },
     fallback => 1,
  ;
  
  =item $w->id
  
  Returns the numerical id of the watcher, as used in the debug shell.
  
  =cut
  
  sub id {
     Scalar::Util::refaddr shift
  }
  
  =item $w->verbose
  
  Returns a multiline textual description of the watcher, including the
  first ten exceptions caught while executing the callback.
  
  =cut
  
  sub verbose {
     my ($self) = @_;
  
     my $res = "type:    $self->{type} watcher\n"
             . "args:    " . (join " ", %{ $self->{arg} }) . "\n" # TODO: decode fh?
             . "created: " . (AnyEvent::Log::format_time $self->{now}) . " ($self->{now})\n"
             . "file:    ${ $self->{rfile} }\n"
             . "line:    $self->{line}\n"
             . "subname: $self->{sub}\n"
             . "context: $self->{cur}\n"
             . "tracing: " . (${ $self->{rt} } ? "enabled" : "disabled") . "\n"
             . "cb:      $self->{cb} (" . (AnyEvent::Debug::cb2str $self->{cb}) . ")\n"
             . "invoked: $self->{called} times\n";
  
     if (exists $self->{bt}) {
        $res .= "created\n$self->{bt}";
     }
  
     if (exists $self->{error}) {
        $res .= "errors:   " . @{$self->{error}} . "\n";
  
        $res .= "error: " . (AnyEvent::Log::format_time $_->[0]) . " ($_->[0]) $_->[1]\n"
           for @{$self->{error}};
     }
  
     $res
  }
  
  =item $w->trace ($on)
  
  Enables (C<$on> is true) or disables (C<$on> is false) tracing on this
  watcher.
  
  To get tracing messages, both the global logging settings must have trace
  messages enabled for the context C<AnyEvent::Debug> and tracing must be
  enabled for the wrapped watcher.
  
  To enable trace messages globally, the simplest way is to start the
  program with C<PERL_ANYEVENT_VERBOSE=9> in the environment.
  
  Tracing for each individual watcher is enabled by default (unless
  C<$AnyEvent::Debug::TRACE> has been set to false).
  
  =cut
  
  sub trace {
     ${ $_[0]{rt} } = $_[1];
  }
  
  sub DESTROY {
     $TRACE_LOGGER->("dstry $_[0]") if $TRACE_ENABLED && ${ $_[0]{rt} };
  
     delete $AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $_[0]};
  }
  
  =back
  
  =cut
  
  package AnyEvent::Debug::Backtrace;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  sub as_string {
     my ($self) = @_;
  
     my @bt;
     my $modlen;
  
     for (@$self) {
        my ($rpath, $line, $sub) = @$_;
  
        $rpath = (AnyEvent::Debug::path2mod $$rpath) . " line $line";
        $modlen = length $rpath if $modlen < length $rpath;
  
        $sub =~ s/\r/\\r/g;
        $sub =~ s/\n/\\n/g;
        $sub =~ s/([\x00-\x1f\x7e-\xff])/sprintf "\\x%02x", ord $1/ge;
        $sub =~ s/([^\x20-\x7e])/sprintf "\\x{%x}", ord $1/ge;
  
        push @bt, [$rpath, $sub];
     }
  
     join "",
        map { sprintf "%*s %s\n", -$modlen, $_->[0], $_->[1] }
           @bt
  }
  
  use overload
     '""'     => \&as_string,
     fallback => 1,
  ;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_DEBUG

$fatpacked{"AnyEvent/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_HANDLE';
  =head1 NAME
  
  AnyEvent::Handle - non-blocking I/O on streaming handles via AnyEvent
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use AnyEvent::Handle;
  
     my $cv = AnyEvent->condvar;
  
     my $hdl; $hdl = new AnyEvent::Handle
        fh => \*STDIN,
        on_error => sub {
           my ($hdl, $fatal, $msg) = @_;
           AE::log error => $msg;
           $hdl->destroy;
           $cv->send;
        };
  
     # send some request line
     $hdl->push_write ("getinfo\015\012");
  
     # read the response line
     $hdl->push_read (line => sub {
        my ($hdl, $line) = @_;
        say "got line <$line>";
        $cv->send;
     });
  
     $cv->recv;
  
  =head1 DESCRIPTION
  
  This is a helper module to make it easier to do event-based I/O
  on stream-based filehandles (sockets, pipes, and other stream
  things). Specifically, it doesn't work as expected on files, packet-based
  sockets or similar things.
  
  The L<AnyEvent::Intro> tutorial contains some well-documented
  AnyEvent::Handle examples.
  
  In the following, where the documentation refers to "bytes", it means
  characters. As sysread and syswrite are used for all I/O, their
  treatment of characters applies to this module as well.
  
  At the very minimum, you should specify C<fh> or C<connect>, and the
  C<on_error> callback.
  
  All callbacks will be invoked with the handle object as their first
  argument.
  
  =cut
  
  package AnyEvent::Handle;
  
  use Scalar::Util ();
  use List::Util ();
  use Carp ();
  use Errno qw(EAGAIN EWOULDBLOCK EINTR);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  
  our $VERSION = $AnyEvent::VERSION;
  
  sub _load_func($) {
     my $func = $_[0];
  
     unless (defined &$func) {
        my $pkg = $func;
        do {
           $pkg =~ s/::[^:]+$//
              or return;
           eval "require $pkg";
        } until defined &$func;
     }
  
     \&$func
  }
  
  sub MAX_READ_SIZE() { 131072 }
  
  =head1 METHODS
  
  =over 4
  
  =item $handle = B<new> AnyEvent::Handle fh => $filehandle, key => value...
  
  The constructor supports these arguments (all as C<< key => value >> pairs).
  
  =over 4
  
  =item fh => $filehandle     [C<fh> or C<connect> MANDATORY]
  
  The filehandle this L<AnyEvent::Handle> object will operate on.
  NOTE: The filehandle will be set to non-blocking mode (using
  C<AnyEvent::fh_unblock>) by the constructor and needs to stay in
  that mode.
  
  =item connect => [$host, $service]      [C<fh> or C<connect> MANDATORY]
  
  Try to connect to the specified host and service (port), using
  C<AnyEvent::Socket::tcp_connect>. The C<$host> additionally becomes the
  default C<peername>.
  
  You have to specify either this parameter, or C<fh>, above.
  
  It is possible to push requests on the read and write queues, and modify
  properties of the stream, even while AnyEvent::Handle is connecting.
  
  When this parameter is specified, then the C<on_prepare>,
  C<on_connect_error> and C<on_connect> callbacks will be called under the
  appropriate circumstances:
  
  =over 4
  
  =item on_prepare => $cb->($handle)
  
  This (rarely used) callback is called before a new connection is
  attempted, but after the file handle has been created (you can access that
  file handle via C<< $handle->{fh} >>). It could be used to prepare the
  file handle with parameters required for the actual connect (as opposed to
  settings that can be changed when the connection is already established).
  
  The return value of this callback should be the connect timeout value in
  seconds (or C<0>, or C<undef>, or the empty list, to indicate that the
  default timeout is to be used).
  
  =item on_connect => $cb->($handle, $host, $port, $retry->())
  
  This callback is called when a connection has been successfully established.
  
  The peer's numeric host and port (the socket peername) are passed as
  parameters, together with a retry callback. At the time it is called the
  read and write queues, EOF status, TLS status and similar properties of
  the handle will have been reset.
  
  If, for some reason, the handle is not acceptable, calling C<$retry> will
  continue with the next connection target (in case of multi-homed hosts or
  SRV records there can be multiple connection endpoints). The C<$retry>
  callback can be invoked after the connect callback returns, i.e. one can
  start a handshake and then decide to retry with the next host if the
  handshake fails.
  
  In most cases, you should ignore the C<$retry> parameter.
  
  =item on_connect_error => $cb->($handle, $message)
  
  This callback is called when the connection could not be
  established. C<$!> will contain the relevant error code, and C<$message> a
  message describing it (usually the same as C<"$!">).
  
  If this callback isn't specified, then C<on_error> will be called with a
  fatal error instead.
  
  =back
  
  =item on_error => $cb->($handle, $fatal, $message)
  
  This is the error callback, which is called when, well, some error
  occured, such as not being able to resolve the hostname, failure to
  connect, or a read error.
  
  Some errors are fatal (which is indicated by C<$fatal> being true). On
  fatal errors the handle object will be destroyed (by a call to C<< ->
  destroy >>) after invoking the error callback (which means you are free to
  examine the handle object). Examples of fatal errors are an EOF condition
  with active (but unsatisfiable) read watchers (C<EPIPE>) or I/O errors. In
  cases where the other side can close the connection at will, it is
  often easiest to not report C<EPIPE> errors in this callback.
  
  AnyEvent::Handle tries to find an appropriate error code for you to check
  against, but in some cases (TLS errors), this does not work well.
  
  If you report the error to the user, it is recommended to always output
  the C<$message> argument in human-readable error messages (you don't need
  to report C<"$!"> if you report C<$message>).
  
  If you want to react programmatically to the error, then looking at C<$!>
  and comparing it against some of the documented C<Errno> values is usually
  better than looking at the C<$message>.
  
  Non-fatal errors can be retried by returning, but it is recommended
  to simply ignore this parameter and instead abondon the handle object
  when this callback is invoked. Examples of non-fatal errors are timeouts
  C<ETIMEDOUT>) or badly-formatted data (C<EBADMSG>).
  
  On entry to the callback, the value of C<$!> contains the operating
  system error code (or C<ENOSPC>, C<EPIPE>, C<ETIMEDOUT>, C<EBADMSG> or
  C<EPROTO>).
  
  While not mandatory, it is I<highly> recommended to set this callback, as
  you will not be notified of errors otherwise. The default just calls
  C<croak>.
  
  =item on_read => $cb->($handle)
  
  This sets the default read callback, which is called when data arrives
  and no read request is in the queue (unlike read queue callbacks, this
  callback will only be called when at least one octet of data is in the
  read buffer).
  
  To access (and remove data from) the read buffer, use the C<< ->rbuf >>
  method or access the C<< $handle->{rbuf} >> member directly. Note that you
  must not enlarge or modify the read buffer, you can only remove data at
  the beginning from it.
  
  You can also call C<< ->push_read (...) >> or any other function that
  modifies the read queue. Or do both. Or ...
  
  When an EOF condition is detected, AnyEvent::Handle will first try to
  feed all the remaining data to the queued callbacks and C<on_read> before
  calling the C<on_eof> callback. If no progress can be made, then a fatal
  error will be raised (with C<$!> set to C<EPIPE>).
  
  Note that, unlike requests in the read queue, an C<on_read> callback
  doesn't mean you I<require> some data: if there is an EOF and there
  are outstanding read requests then an error will be flagged. With an
  C<on_read> callback, the C<on_eof> callback will be invoked.
  
  =item on_eof => $cb->($handle)
  
  Set the callback to be called when an end-of-file condition is detected,
  i.e. in the case of a socket, when the other side has closed the
  connection cleanly, and there are no outstanding read requests in the
  queue (if there are read requests, then an EOF counts as an unexpected
  connection close and will be flagged as an error).
  
  For sockets, this just means that the other side has stopped sending data,
  you can still try to write data, and, in fact, one can return from the EOF
  callback and continue writing data, as only the read part has been shut
  down.
  
  If an EOF condition has been detected but no C<on_eof> callback has been
  set, then a fatal error will be raised with C<$!> set to <0>.
  
  =item on_drain => $cb->($handle)
  
  This sets the callback that is called once when the write buffer becomes
  empty (and immediately when the handle object is created).
  
  To append to the write buffer, use the C<< ->push_write >> method.
  
  This callback is useful when you don't want to put all of your write data
  into the queue at once, for example, when you want to write the contents
  of some file to the socket you might not want to read the whole file into
  memory and push it into the queue, but instead only read more data from
  the file when the write queue becomes empty.
  
  =item timeout => $fractional_seconds
  
  =item rtimeout => $fractional_seconds
  
  =item wtimeout => $fractional_seconds
  
  If non-zero, then these enables an "inactivity" timeout: whenever this
  many seconds pass without a successful read or write on the underlying
  file handle (or a call to C<timeout_reset>), the C<on_timeout> callback
  will be invoked (and if that one is missing, a non-fatal C<ETIMEDOUT>
  error will be raised).
  
  There are three variants of the timeouts that work independently of each
  other, for both read and write (triggered when nothing was read I<OR>
  written), just read (triggered when nothing was read), and just write:
  C<timeout>, C<rtimeout> and C<wtimeout>, with corresponding callbacks
  C<on_timeout>, C<on_rtimeout> and C<on_wtimeout>, and reset functions
  C<timeout_reset>, C<rtimeout_reset>, and C<wtimeout_reset>.
  
  Note that timeout processing is active even when you do not have any
  outstanding read or write requests: If you plan to keep the connection
  idle then you should disable the timeout temporarily or ignore the
  timeout in the corresponding C<on_timeout> callback, in which case
  AnyEvent::Handle will simply restart the timeout.
  
  Zero (the default) disables the corresponding timeout.
  
  =item on_timeout => $cb->($handle)
  
  =item on_rtimeout => $cb->($handle)
  
  =item on_wtimeout => $cb->($handle)
  
  Called whenever the inactivity timeout passes. If you return from this
  callback, then the timeout will be reset as if some activity had happened,
  so this condition is not fatal in any way.
  
  =item rbuf_max => <bytes>
  
  If defined, then a fatal error will be raised (with C<$!> set to C<ENOSPC>)
  when the read buffer ever (strictly) exceeds this size. This is useful to
  avoid some forms of denial-of-service attacks.
  
  For example, a server accepting connections from untrusted sources should
  be configured to accept only so-and-so much data that it cannot act on
  (for example, when expecting a line, an attacker could send an unlimited
  amount of data without a callback ever being called as long as the line
  isn't finished).
  
  =item wbuf_max => <bytes>
  
  If defined, then a fatal error will be raised (with C<$!> set to C<ENOSPC>)
  when the write buffer ever (strictly) exceeds this size. This is useful to
  avoid some forms of denial-of-service attacks.
  
  Although the units of this parameter is bytes, this is the I<raw> number
  of bytes not yet accepted by the kernel. This can make a difference when
  you e.g. use TLS, as TLS typically makes your write data larger (but it
  can also make it smaller due to compression).
  
  As an example of when this limit is useful, take a chat server that sends
  chat messages to a client. If the client does not read those in a timely
  manner then the send buffer in the server would grow unbounded.
  
  =item autocork => <boolean>
  
  When disabled (the default), C<push_write> will try to immediately
  write the data to the handle if possible. This avoids having to register
  a write watcher and wait for the next event loop iteration, but can
  be inefficient if you write multiple small chunks (on the wire, this
  disadvantage is usually avoided by your kernel's nagle algorithm, see
  C<no_delay>, but this option can save costly syscalls).
  
  When enabled, writes will always be queued till the next event loop
  iteration. This is efficient when you do many small writes per iteration,
  but less efficient when you do a single write only per iteration (or when
  the write buffer often is full). It also increases write latency.
  
  =item no_delay => <boolean>
  
  When doing small writes on sockets, your operating system kernel might
  wait a bit for more data before actually sending it out. This is called
  the Nagle algorithm, and usually it is beneficial.
  
  In some situations you want as low a delay as possible, which can be
  accomplishd by setting this option to a true value.
  
  The default is your operating system's default behaviour (most likely
  enabled). This option explicitly enables or disables it, if possible.
  
  =item keepalive => <boolean>
  
  Enables (default disable) the SO_KEEPALIVE option on the stream socket:
  normally, TCP connections have no time-out once established, so TCP
  connections, once established, can stay alive forever even when the other
  side has long gone. TCP keepalives are a cheap way to take down long-lived
  TCP connections when the other side becomes unreachable. While the default
  is OS-dependent, TCP keepalives usually kick in after around two hours,
  and, if the other side doesn't reply, take down the TCP connection some 10
  to 15 minutes later.
  
  It is harmless to specify this option for file handles that do not support
  keepalives, and enabling it on connections that are potentially long-lived
  is usually a good idea.
  
  =item oobinline => <boolean>
  
  BSD majorly fucked up the implementation of TCP urgent data. The result
  is that almost no OS implements TCP according to the specs, and every OS
  implements it slightly differently.
  
  If you want to handle TCP urgent data, then setting this flag (the default
  is enabled) gives you the most portable way of getting urgent data, by
  putting it into the stream.
  
  Since BSD emulation of OOB data on top of TCP's urgent data can have
  security implications, AnyEvent::Handle sets this flag automatically
  unless explicitly specified. Note that setting this flag after
  establishing a connection I<may> be a bit too late (data loss could
  already have occured on BSD systems), but at least it will protect you
  from most attacks.
  
  =item read_size => <bytes>
  
  The initial read block size, the number of bytes this module will try
  to read during each loop iteration. Each handle object will consume
  at least this amount of memory for the read buffer as well, so when
  handling many connections watch out for memory requirements). See also
  C<max_read_size>. Default: C<2048>.
  
  =item max_read_size => <bytes>
  
  The maximum read buffer size used by the dynamic adjustment
  algorithm: Each time AnyEvent::Handle can read C<read_size> bytes in
  one go it will double C<read_size> up to the maximum given by this
  option. Default: C<131072> or C<read_size>, whichever is higher.
  
  =item low_water_mark => <bytes>
  
  Sets the number of bytes (default: C<0>) that make up an "empty" write
  buffer: If the buffer reaches this size or gets even samller it is
  considered empty.
  
  Sometimes it can be beneficial (for performance reasons) to add data to
  the write buffer before it is fully drained, but this is a rare case, as
  the operating system kernel usually buffers data as well, so the default
  is good in almost all cases.
  
  =item linger => <seconds>
  
  If this is non-zero (default: C<3600>), the destructor of the
  AnyEvent::Handle object will check whether there is still outstanding
  write data and will install a watcher that will write this data to the
  socket. No errors will be reported (this mostly matches how the operating
  system treats outstanding data at socket close time).
  
  This will not work for partial TLS data that could not be encoded
  yet. This data will be lost. Calling the C<stoptls> method in time might
  help.
  
  =item peername => $string
  
  A string used to identify the remote site - usually the DNS hostname
  (I<not> IDN!) used to create the connection, rarely the IP address.
  
  Apart from being useful in error messages, this string is also used in TLS
  peername verification (see C<verify_peername> in L<AnyEvent::TLS>). This
  verification will be skipped when C<peername> is not specified or is
  C<undef>.
  
  =item tls => "accept" | "connect" | Net::SSLeay::SSL object
  
  When this parameter is given, it enables TLS (SSL) mode, that means
  AnyEvent will start a TLS handshake as soon as the connection has been
  established and will transparently encrypt/decrypt data afterwards.
  
  All TLS protocol errors will be signalled as C<EPROTO>, with an
  appropriate error message.
  
  TLS mode requires Net::SSLeay to be installed (it will be loaded
  automatically when you try to create a TLS handle): this module doesn't
  have a dependency on that module, so if your module requires it, you have
  to add the dependency yourself. If Net::SSLeay cannot be loaded or is too
  old, you get an C<EPROTO> error.
  
  Unlike TCP, TLS has a server and client side: for the TLS server side, use
  C<accept>, and for the TLS client side of a connection, use C<connect>
  mode.
  
  You can also provide your own TLS connection object, but you have
  to make sure that you call either C<Net::SSLeay::set_connect_state>
  or C<Net::SSLeay::set_accept_state> on it before you pass it to
  AnyEvent::Handle. Also, this module will take ownership of this connection
  object.
  
  At some future point, AnyEvent::Handle might switch to another TLS
  implementation, then the option to use your own session object will go
  away.
  
  B<IMPORTANT:> since Net::SSLeay "objects" are really only integers,
  passing in the wrong integer will lead to certain crash. This most often
  happens when one uses a stylish C<< tls => 1 >> and is surprised about the
  segmentation fault.
  
  Use the C<< ->starttls >> method if you need to start TLS negotiation later.
  
  =item tls_ctx => $anyevent_tls
  
  Use the given C<AnyEvent::TLS> object to create the new TLS connection
  (unless a connection object was specified directly). If this
  parameter is missing (or C<undef>), then AnyEvent::Handle will use
  C<AnyEvent::Handle::TLS_CTX>.
  
  Instead of an object, you can also specify a hash reference with C<< key
  => value >> pairs. Those will be passed to L<AnyEvent::TLS> to create a
  new TLS context object.
  
  =item on_starttls => $cb->($handle, $success[, $error_message])
  
  This callback will be invoked when the TLS/SSL handshake has finished. If
  C<$success> is true, then the TLS handshake succeeded, otherwise it failed
  (C<on_stoptls> will not be called in this case).
  
  The session in C<< $handle->{tls} >> can still be examined in this
  callback, even when the handshake was not successful.
  
  TLS handshake failures will not cause C<on_error> to be invoked when this
  callback is in effect, instead, the error message will be passed to C<on_starttls>.
  
  Without this callback, handshake failures lead to C<on_error> being
  called as usual.
  
  Note that you cannot just call C<starttls> again in this callback. If you
  need to do that, start an zero-second timer instead whose callback can
  then call C<< ->starttls >> again.
  
  =item on_stoptls => $cb->($handle)
  
  When a SSLv3/TLS shutdown/close notify/EOF is detected and this callback is
  set, then it will be invoked after freeing the TLS session. If it is not,
  then a TLS shutdown condition will be treated like a normal EOF condition
  on the handle.
  
  The session in C<< $handle->{tls} >> can still be examined in this
  callback.
  
  This callback will only be called on TLS shutdowns, not when the
  underlying handle signals EOF.
  
  =item json => L<JSON>, L<JSON::PP> or L<JSON::XS> object
  
  This is the json coder object used by the C<json> read and write types.
  
  If you don't supply it, then AnyEvent::Handle will create and use a
  suitable one (on demand), which will write and expect UTF-8 encoded
  JSON texts (either using L<JSON::XS> or L<JSON>). The written texts are
  guaranteed not to contain any newline character.
  
  For security reasons, this encoder will likely I<not> handle numbers and
  strings, only arrays and objects/hashes. The reason is that originally
  JSON was self-delimited, but Dougles Crockford thought it was a splendid
  idea to redefine JSON incompatibly, so this is no longer true.
  
  For protocols that used back-to-back JSON texts, this might lead to
  run-ins, where two or more JSON texts will be interpreted as one JSON
  text.
  
  For this reason, if the default encoder uses L<JSON::XS>, it will default
  to not allowing anything but arrays and objects/hashes, at least for the
  forseeable future (it will change at some point). This might or might not
  be true for the L<JSON> module, so this might cause a security issue.
  
  If you depend on either behaviour, you should create your own json object
  and pass it in explicitly.
  
  =item cbor => L<CBOR::XS> object
  
  This is the cbor coder object used by the C<cbor> read and write types.
  
  If you don't supply it, then AnyEvent::Handle will create and use a
  suitable one (on demand), which will write CBOR without using extensions,
  if possible.
  
  Note that you are responsible to depend on the L<CBOR::XS> module if you
  want to use this functionality, as AnyEvent does not have a dependency on
  it itself.
  
  =back
  
  =cut
  
  sub new {
     my $class = shift;
     my $self = bless { @_ }, $class;
  
     if ($self->{fh}) {
        $self->_start;
        return unless $self->{fh}; # could be gone by now
  
     } elsif ($self->{connect}) {
        require AnyEvent::Socket;
  
        $self->{peername} = $self->{connect}[0]
           unless exists $self->{peername};
  
        $self->{_skip_drain_rbuf} = 1;
  
        {
           Scalar::Util::weaken (my $self = $self);
  
           $self->{_connect} =
              AnyEvent::Socket::tcp_connect (
                 $self->{connect}[0],
                 $self->{connect}[1],
                 sub {
                    my ($fh, $host, $port, $retry) = @_;
  
                    delete $self->{_connect}; # no longer needed
  
                    if ($fh) {
                       $self->{fh} = $fh;
  
                       delete $self->{_skip_drain_rbuf};
                       $self->_start;
  
                       $self->{on_connect}
                          and $self->{on_connect}($self, $host, $port, sub {
                                 delete @$self{qw(fh _tw _rtw _wtw _ww _rw _eof _queue rbuf _wbuf tls _tls_rbuf _tls_wbuf)};
                                 $self->{_skip_drain_rbuf} = 1;
                                 &$retry;
                              });
  
                    } else {
                       if ($self->{on_connect_error}) {
                          $self->{on_connect_error}($self, "$!");
                          $self->destroy if $self;
                       } else {
                          $self->_error ($!, 1);
                       }
                    }
                 },
                 sub {
                    local $self->{fh} = $_[0];
  
                    $self->{on_prepare}
                       ? $self->{on_prepare}->($self)
                       : ()
                 }
              );
        }
  
     } else {
        Carp::croak "AnyEvent::Handle: either an existing fh or the connect parameter must be specified";
     }
  
     $self
  }
  
  sub _start {
     my ($self) = @_;
  
     # too many clueless people try to use udp and similar sockets
     # with AnyEvent::Handle, do them a favour.
     my $type = getsockopt $self->{fh}, Socket::SOL_SOCKET (), Socket::SO_TYPE ();
     Carp::croak "AnyEvent::Handle: only stream sockets supported, anything else will NOT work!"
        if Socket::SOCK_STREAM () != (unpack "I", $type) && defined $type;
  
     AnyEvent::fh_unblock $self->{fh};
  
     $self->{_activity}  =
     $self->{_ractivity} =
     $self->{_wactivity} = AE::now;
  
     $self->{read_size} ||= 2048;
     $self->{max_read_size} = $self->{read_size}
        if $self->{read_size} > ($self->{max_read_size} || MAX_READ_SIZE);
  
     $self->timeout   (delete $self->{timeout}  ) if $self->{timeout};
     $self->rtimeout  (delete $self->{rtimeout} ) if $self->{rtimeout};
     $self->wtimeout  (delete $self->{wtimeout} ) if $self->{wtimeout};
  
     $self->no_delay  (delete $self->{no_delay} ) if exists $self->{no_delay}  && $self->{no_delay};
     $self->keepalive (delete $self->{keepalive}) if exists $self->{keepalive} && $self->{keepalive};
  
     $self->oobinline (exists $self->{oobinline} ? delete $self->{oobinline} : 1);
  
     $self->starttls  (delete $self->{tls}, delete $self->{tls_ctx})
        if $self->{tls};
  
     $self->on_drain  (delete $self->{on_drain} ) if $self->{on_drain};
  
     $self->start_read
        if $self->{on_read} || @{ $self->{_queue} };
  
     $self->_drain_wbuf;
  }
  
  sub _error {
     my ($self, $errno, $fatal, $message) = @_;
  
     $! = $errno;
     $message ||= "$!";
  
     if ($self->{on_error}) {
        $self->{on_error}($self, $fatal, $message);
        $self->destroy if $fatal;
     } elsif ($self->{fh} || $self->{connect}) {
        $self->destroy;
        Carp::croak "AnyEvent::Handle uncaught error: $message";
     }
  }
  
  =item $fh = $handle->fh
  
  This method returns the file handle used to create the L<AnyEvent::Handle> object.
  
  =cut
  
  sub fh { $_[0]{fh} }
  
  =item $handle->on_error ($cb)
  
  Replace the current C<on_error> callback (see the C<on_error> constructor argument).
  
  =cut
  
  sub on_error {
     $_[0]{on_error} = $_[1];
  }
  
  =item $handle->on_eof ($cb)
  
  Replace the current C<on_eof> callback (see the C<on_eof> constructor argument).
  
  =cut
  
  sub on_eof {
     $_[0]{on_eof} = $_[1];
  }
  
  =item $handle->on_timeout ($cb)
  
  =item $handle->on_rtimeout ($cb)
  
  =item $handle->on_wtimeout ($cb)
  
  Replace the current C<on_timeout>, C<on_rtimeout> or C<on_wtimeout>
  callback, or disables the callback (but not the timeout) if C<$cb> =
  C<undef>. See the C<timeout> constructor argument and method.
  
  =cut
  
  # see below
  
  =item $handle->autocork ($boolean)
  
  Enables or disables the current autocork behaviour (see C<autocork>
  constructor argument). Changes will only take effect on the next write.
  
  =cut
  
  sub autocork {
     $_[0]{autocork} = $_[1];
  }
  
  =item $handle->no_delay ($boolean)
  
  Enables or disables the C<no_delay> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub no_delay {
     $_[0]{no_delay} = $_[1];
  
     setsockopt $_[0]{fh}, Socket::IPPROTO_TCP (), Socket::TCP_NODELAY (), int $_[1]
        if $_[0]{fh};
  }
  
  =item $handle->keepalive ($boolean)
  
  Enables or disables the C<keepalive> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub keepalive {
     $_[0]{keepalive} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_KEEPALIVE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->oobinline ($boolean)
  
  Enables or disables the C<oobinline> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub oobinline {
     $_[0]{oobinline} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_OOBINLINE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->on_starttls ($cb)
  
  Replace the current C<on_starttls> callback (see the C<on_starttls> constructor argument).
  
  =cut
  
  sub on_starttls {
     $_[0]{on_starttls} = $_[1];
  }
  
  =item $handle->on_stoptls ($cb)
  
  Replace the current C<on_stoptls> callback (see the C<on_stoptls> constructor argument).
  
  =cut
  
  sub on_stoptls {
     $_[0]{on_stoptls} = $_[1];
  }
  
  =item $handle->rbuf_max ($max_octets)
  
  Configures the C<rbuf_max> setting (C<undef> disables it).
  
  =item $handle->wbuf_max ($max_octets)
  
  Configures the C<wbuf_max> setting (C<undef> disables it).
  
  =cut
  
  sub rbuf_max {
     $_[0]{rbuf_max} = $_[1];
  }
  
  sub wbuf_max {
     $_[0]{wbuf_max} = $_[1];
  }
  
  #############################################################################
  
  =item $handle->timeout ($seconds)
  
  =item $handle->rtimeout ($seconds)
  
  =item $handle->wtimeout ($seconds)
  
  Configures (or disables) the inactivity timeout.
  
  The timeout will be checked instantly, so this method might destroy the
  handle before it returns.
  
  =item $handle->timeout_reset
  
  =item $handle->rtimeout_reset
  
  =item $handle->wtimeout_reset
  
  Reset the activity timeout, as if data was received or sent.
  
  These methods are cheap to call.
  
  =cut
  
  for my $dir ("", "r", "w") {
     my $timeout    = "${dir}timeout";
     my $tw         = "_${dir}tw";
     my $on_timeout = "on_${dir}timeout";
     my $activity   = "_${dir}activity";
     my $cb;
  
     *$on_timeout = sub {
        $_[0]{$on_timeout} = $_[1];
     };
  
     *$timeout = sub {
        my ($self, $new_value) = @_;
  
        $new_value >= 0
           or Carp::croak "AnyEvent::Handle->$timeout called with negative timeout ($new_value), caught";
  
        $self->{$timeout} = $new_value;
        delete $self->{$tw}; &$cb;
     };
  
     *{"${dir}timeout_reset"} = sub {
        $_[0]{$activity} = AE::now;
     };
  
     # main workhorse:
     # reset the timeout watcher, as neccessary
     # also check for time-outs
     $cb = sub {
        my ($self) = @_;
  
        if ($self->{$timeout} && $self->{fh}) {
           my $NOW = AE::now;
  
           # when would the timeout trigger?
           my $after = $self->{$activity} + $self->{$timeout} - $NOW;
  
           # now or in the past already?
           if ($after <= 0) {
              $self->{$activity} = $NOW;
  
              if ($self->{$on_timeout}) {
                 $self->{$on_timeout}($self);
              } else {
                 $self->_error (Errno::ETIMEDOUT);
              }
  
              # callback could have changed timeout value, optimise
              return unless $self->{$timeout};
  
              # calculate new after
              $after = $self->{$timeout};
           }
  
           Scalar::Util::weaken $self;
           return unless $self; # ->error could have destroyed $self
  
           $self->{$tw} ||= AE::timer $after, 0, sub {
              delete $self->{$tw};
              $cb->($self);
           };
        } else {
           delete $self->{$tw};
        }
     }
  }
  
  #############################################################################
  
  =back
  
  =head2 WRITE QUEUE
  
  AnyEvent::Handle manages two queues per handle, one for writing and one
  for reading.
  
  The write queue is very simple: you can add data to its end, and
  AnyEvent::Handle will automatically try to get rid of it for you.
  
  When data could be written and the write buffer is shorter then the low
  water mark, the C<on_drain> callback will be invoked once.
  
  =over 4
  
  =item $handle->on_drain ($cb)
  
  Sets the C<on_drain> callback or clears it (see the description of
  C<on_drain> in the constructor).
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub on_drain {
     my ($self, $cb) = @_;
  
     $self->{on_drain} = $cb;
  
     $cb->($self)
        if $cb && $self->{low_water_mark} >= (length $self->{wbuf}) + (length $self->{_tls_wbuf});
  }
  
  =item $handle->push_write ($data)
  
  Queues the given scalar to be written. You can push as much data as
  you want (only limited by the available memory and C<wbuf_max>), as
  C<AnyEvent::Handle> buffers it independently of the kernel.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub _drain_wbuf {
     my ($self) = @_;
  
     if (!$self->{_ww} && length $self->{wbuf}) {
  
        Scalar::Util::weaken $self;
  
        my $cb = sub {
           my $len = syswrite $self->{fh}, $self->{wbuf};
  
           if (defined $len) {
              substr $self->{wbuf}, 0, $len, "";
  
              $self->{_activity} = $self->{_wactivity} = AE::now;
  
              $self->{on_drain}($self)
                 if $self->{low_water_mark} >= (length $self->{wbuf}) + (length $self->{_tls_wbuf})
                    && $self->{on_drain};
  
              delete $self->{_ww} unless length $self->{wbuf};
           } elsif ($! != EAGAIN && $! != EINTR && $! != EWOULDBLOCK && $! != WSAEWOULDBLOCK) {
              $self->_error ($!, 1);
           }
        };
  
        # try to write data immediately
        $cb->() unless $self->{autocork};
  
        # if still data left in wbuf, we need to poll
        $self->{_ww} = AE::io $self->{fh}, 1, $cb
           if length $self->{wbuf};
  
        if (
           defined $self->{wbuf_max}
           && $self->{wbuf_max} < length $self->{wbuf}
        ) {
           $self->_error (Errno::ENOSPC, 1), return;
        }
     };
  }
  
  our %WH;
  
  # deprecated
  sub register_write_type($$) {
     $WH{$_[0]} = $_[1];
  }
  
  sub push_write {
     my $self = shift;
  
     if (@_ > 1) {
        my $type = shift;
  
        @_ = ($WH{$type} ||= _load_func "$type\::anyevent_write_type"
              or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_write")
             ->($self, @_);
     }
  
     # we downgrade here to avoid hard-to-track-down bugs,
     # and diagnose the problem earlier and better.
  
     if ($self->{tls}) {
        utf8::downgrade $self->{_tls_wbuf} .= $_[0];
        &_dotls ($self)    if $self->{fh};
     } else {
        utf8::downgrade $self->{wbuf}      .= $_[0];
        $self->_drain_wbuf if $self->{fh};
     }
  }
  
  =item $handle->push_write (type => @args)
  
  Instead of formatting your data yourself, you can also let this module
  do the job by specifying a type and type-specific arguments. You
  can also specify the (fully qualified) name of a package, in which
  case AnyEvent tries to load the package and then expects to find the
  C<anyevent_write_type> function inside (see "custom write types", below).
  
  Predefined types are (if you have ideas for additional types, feel free to
  drop by and tell us):
  
  =over 4
  
  =item netstring => $string
  
  Formats the given value as netstring
  (http://cr.yp.to/proto/netstrings.txt, this is not a recommendation to use them).
  
  =cut
  
  register_write_type netstring => sub {
     my ($self, $string) = @_;
  
     (length $string) . ":$string,"
  };
  
  =item packstring => $format, $data
  
  An octet string prefixed with an encoded length. The encoding C<$format>
  uses the same format as a Perl C<pack> format, but must specify a single
  integer only (only one of C<cCsSlLqQiInNvVjJw> is allowed, plus an
  optional C<!>, C<< < >> or C<< > >> modifier).
  
  =cut
  
  register_write_type packstring => sub {
     my ($self, $format, $string) = @_;
  
     pack "$format/a*", $string
  };
  
  =item json => $array_or_hashref
  
  Encodes the given hash or array reference into a JSON object. Unless you
  provide your own JSON object, this means it will be encoded to JSON text
  in UTF-8.
  
  The default encoder might or might not handle every type of JSON value -
  it might be limited to arrays and objects for security reasons. See the
  C<json> constructor attribute for more details.
  
  JSON objects (and arrays) are self-delimiting, so if you only use arrays
  and hashes, you can write JSON at one end of a handle and read them at the
  other end without using any additional framing.
  
  The JSON text generated by the default encoder is guaranteed not to
  contain any newlines: While this module doesn't need delimiters after or
  between JSON texts to be able to read them, many other languages depend on
  them.
  
  A simple RPC protocol that interoperates easily with other languages is
  to send JSON arrays (or objects, although arrays are usually the better
  choice as they mimic how function argument passing works) and a newline
  after each JSON text:
  
     $handle->push_write (json => ["method", "arg1", "arg2"]); # whatever
     $handle->push_write ("\012");
   
  An AnyEvent::Handle receiver would simply use the C<json> read type and
  rely on the fact that the newline will be skipped as leading whitespace:
  
     $handle->push_read (json => sub { my $array = $_[1]; ... });
  
  Other languages could read single lines terminated by a newline and pass
  this line into their JSON decoder of choice.
  
  =item cbor => $perl_scalar
  
  Encodes the given scalar into a CBOR value. Unless you provide your own
  L<CBOR::XS> object, this means it will be encoded to a CBOR string not
  using any extensions, if possible.
  
  CBOR values are self-delimiting, so you can write CBOR at one end of
  a handle and read them at the other end without using any additional
  framing.
  
  A simple nd very very fast RPC protocol that interoperates with
  other languages is to send CBOR and receive CBOR values (arrays are
  recommended):
  
     $handle->push_write (cbor => ["method", "arg1", "arg2"]); # whatever
   
  An AnyEvent::Handle receiver would simply use the C<cbor> read type:
  
     $handle->push_read (cbor => sub { my $array = $_[1]; ... });
  
  =cut
  
  sub json_coder() {
     eval { require JSON::XS; JSON::XS->new->utf8 }
        || do { require JSON::PP; JSON::PP->new->utf8 }
  }
  
  register_write_type json => sub {
     my ($self, $ref) = @_;
  
     ($self->{json} ||= json_coder)
        ->encode ($ref)
  };
  
  sub cbor_coder() {
     require CBOR::XS;
     CBOR::XS->new
  }
  
  register_write_type cbor => sub {
     my ($self, $scalar) = @_;
  
     ($self->{cbor} ||= cbor_coder)
        ->encode ($scalar)
  };
  
  =item storable => $reference
  
  Freezes the given reference using L<Storable> and writes it to the
  handle. Uses the C<nfreeze> format.
  
  =cut
  
  register_write_type storable => sub {
     my ($self, $ref) = @_;
  
     require Storable unless $Storable::VERSION;
  
     pack "w/a*", Storable::nfreeze ($ref)
  };
  
  =back
  
  =item $handle->push_shutdown
  
  Sometimes you know you want to close the socket after writing your data
  before it was actually written. One way to do that is to replace your
  C<on_drain> handler by a callback that shuts down the socket (and set
  C<low_water_mark> to C<0>). This method is a shorthand for just that, and
  replaces the C<on_drain> callback with:
  
     sub { shutdown $_[0]{fh}, 1 }
  
  This simply shuts down the write side and signals an EOF condition to the
  the peer.
  
  You can rely on the normal read queue and C<on_eof> handling
  afterwards. This is the cleanest way to close a connection.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub push_shutdown {
     my ($self) = @_;
  
     delete $self->{low_water_mark};
     $self->on_drain (sub { shutdown $_[0]{fh}, 1 });
  }
  
  =item custom write types - Package::anyevent_write_type $handle, @args
  
  Instead of one of the predefined types, you can also specify the name of
  a package. AnyEvent will try to load the package and then expects to find
  a function named C<anyevent_write_type> inside. If it isn't found, it
  progressively tries to load the parent package until it either finds the
  function (good) or runs out of packages (bad).
  
  Whenever the given C<type> is used, C<push_write> will the function with
  the handle object and the remaining arguments.
  
  The function is supposed to return a single octet string that will be
  appended to the write buffer, so you can mentally treat this function as a
  "arguments to on-the-wire-format" converter.
  
  Example: implement a custom write type C<join> that joins the remaining
  arguments using the first one.
  
     $handle->push_write (My::Type => " ", 1,2,3);
  
     # uses the following package, which can be defined in the "My::Type" or in
     # the "My" modules to be auto-loaded, or just about anywhere when the
     # My::Type::anyevent_write_type is defined before invoking it.
  
     package My::Type;
  
     sub anyevent_write_type {
        my ($handle, $delim, @args) = @_;
  
        join $delim, @args
     }
  
  =cut
  
  #############################################################################
  
  =back
  
  =head2 READ QUEUE
  
  AnyEvent::Handle manages two queues per handle, one for writing and one
  for reading.
  
  The read queue is more complex than the write queue. It can be used in two
  ways, the "simple" way, using only C<on_read> and the "complex" way, using
  a queue.
  
  In the simple case, you just install an C<on_read> callback and whenever
  new data arrives, it will be called. You can then remove some data (if
  enough is there) from the read buffer (C<< $handle->rbuf >>). Or you can
  leave the data there if you want to accumulate more (e.g. when only a
  partial message has been received so far), or change the read queue with
  e.g. C<push_read>.
  
  In the more complex case, you want to queue multiple callbacks. In this
  case, AnyEvent::Handle will call the first queued callback each time new
  data arrives (also the first time it is queued) and remove it when it has
  done its job (see C<push_read>, below).
  
  This way you can, for example, push three line-reads, followed by reading
  a chunk of data, and AnyEvent::Handle will execute them in order.
  
  Example 1: EPP protocol parser. EPP sends 4 byte length info, followed by
  the specified number of bytes which give an XML datagram.
  
     # in the default state, expect some header bytes
     $handle->on_read (sub {
        # some data is here, now queue the length-header-read (4 octets)
        shift->unshift_read (chunk => 4, sub {
           # header arrived, decode
           my $len = unpack "N", $_[1];
  
           # now read the payload
           shift->unshift_read (chunk => $len, sub {
              my $xml = $_[1];
              # handle xml
           });
        });
     });
  
  Example 2: Implement a client for a protocol that replies either with "OK"
  and another line or "ERROR" for the first request that is sent, and 64
  bytes for the second request. Due to the availability of a queue, we can
  just pipeline sending both requests and manipulate the queue as necessary
  in the callbacks.
  
  When the first callback is called and sees an "OK" response, it will
  C<unshift> another line-read. This line-read will be queued I<before> the
  64-byte chunk callback.
  
     # request one, returns either "OK + extra line" or "ERROR"
     $handle->push_write ("request 1\015\012");
  
     # we expect "ERROR" or "OK" as response, so push a line read
     $handle->push_read (line => sub {
        # if we got an "OK", we have to _prepend_ another line,
        # so it will be read before the second request reads its 64 bytes
        # which are already in the queue when this callback is called
        # we don't do this in case we got an error
        if ($_[1] eq "OK") {
           $_[0]->unshift_read (line => sub {
              my $response = $_[1];
              ...
           });
        }
     });
  
     # request two, simply returns 64 octets
     $handle->push_write ("request 2\015\012");
  
     # simply read 64 bytes, always
     $handle->push_read (chunk => 64, sub {
        my $response = $_[1];
        ...
     });
  
  =over 4
  
  =cut
  
  sub _drain_rbuf {
     my ($self) = @_;
  
     # avoid recursion
     return if $self->{_skip_drain_rbuf};
     local $self->{_skip_drain_rbuf} = 1;
  
     while () {
        # we need to use a separate tls read buffer, as we must not receive data while
        # we are draining the buffer, and this can only happen with TLS.
        $self->{rbuf} .= delete $self->{_tls_rbuf}
           if exists $self->{_tls_rbuf};
  
        my $len = length $self->{rbuf};
  
        if (my $cb = shift @{ $self->{_queue} }) {
           unless ($cb->($self)) {
              # no progress can be made
              # (not enough data and no data forthcoming)
              $self->_error (Errno::EPIPE, 1), return
                 if $self->{_eof};
  
              unshift @{ $self->{_queue} }, $cb;
              last;
           }
        } elsif ($self->{on_read}) {
           last unless $len;
  
           $self->{on_read}($self);
  
           if (
              $len == length $self->{rbuf} # if no data has been consumed
              && !@{ $self->{_queue} }     # and the queue is still empty
              && $self->{on_read}          # but we still have on_read
           ) {
              # no further data will arrive
              # so no progress can be made
              $self->_error (Errno::EPIPE, 1), return
                 if $self->{_eof};
  
              last; # more data might arrive
           }
        } else {
           # read side becomes idle
           delete $self->{_rw} unless $self->{tls};
           last;
        }
     }
  
     if ($self->{_eof}) {
        $self->{on_eof}
           ? $self->{on_eof}($self)
           : $self->_error (0, 1, "Unexpected end-of-file");
  
        return;
     }
  
     if (
        defined $self->{rbuf_max}
        && $self->{rbuf_max} < length $self->{rbuf}
     ) {
        $self->_error (Errno::ENOSPC, 1), return;
     }
  
     # may need to restart read watcher
     unless ($self->{_rw}) {
        $self->start_read
           if $self->{on_read} || @{ $self->{_queue} };
     }
  }
  
  =item $handle->on_read ($cb)
  
  This replaces the currently set C<on_read> callback, or clears it (when
  the new callback is C<undef>). See the description of C<on_read> in the
  constructor.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub on_read {
     my ($self, $cb) = @_;
  
     $self->{on_read} = $cb;
     $self->_drain_rbuf if $cb;
  }
  
  =item $handle->rbuf
  
  Returns the read buffer (as a modifiable lvalue). You can also access the
  read buffer directly as the C<< ->{rbuf} >> member, if you want (this is
  much faster, and no less clean).
  
  The only operation allowed on the read buffer (apart from looking at it)
  is removing data from its beginning. Otherwise modifying or appending to
  it is not allowed and will lead to hard-to-track-down bugs.
  
  NOTE: The read buffer should only be used or modified in the C<on_read>
  callback or when C<push_read> or C<unshift_read> are used with a single
  callback (i.e. untyped). Typed C<push_read> and C<unshift_read> methods
  will manage the read buffer on their own.
  
  =cut
  
  sub rbuf : lvalue {
     $_[0]{rbuf}
  }
  
  =item $handle->push_read ($cb)
  
  =item $handle->unshift_read ($cb)
  
  Append the given callback to the end of the queue (C<push_read>) or
  prepend it (C<unshift_read>).
  
  The callback is called each time some additional read data arrives.
  
  It must check whether enough data is in the read buffer already.
  
  If not enough data is available, it must return the empty list or a false
  value, in which case it will be called repeatedly until enough data is
  available (or an error condition is detected).
  
  If enough data was available, then the callback must remove all data it is
  interested in (which can be none at all) and return a true value. After returning
  true, it will be removed from the queue.
  
  These methods may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  our %RH;
  
  sub register_read_type($$) {
     $RH{$_[0]} = $_[1];
  }
  
  sub push_read {
     my $self = shift;
     my $cb = pop;
  
     if (@_) {
        my $type = shift;
  
        $cb = ($RH{$type} ||= _load_func "$type\::anyevent_read_type"
               or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_read")
              ->($self, $cb, @_);
     }
  
     push @{ $self->{_queue} }, $cb;
     $self->_drain_rbuf;
  }
  
  sub unshift_read {
     my $self = shift;
     my $cb = pop;
  
     if (@_) {
        my $type = shift;
  
        $cb = ($RH{$type} ||= _load_func "$type\::anyevent_read_type"
               or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::unshift_read")
              ->($self, $cb, @_);
     }
  
     unshift @{ $self->{_queue} }, $cb;
     $self->_drain_rbuf;
  }
  
  =item $handle->push_read (type => @args, $cb)
  
  =item $handle->unshift_read (type => @args, $cb)
  
  Instead of providing a callback that parses the data itself you can chose
  between a number of predefined parsing formats, for chunks of data, lines
  etc. You can also specify the (fully qualified) name of a package, in
  which case AnyEvent tries to load the package and then expects to find the
  C<anyevent_read_type> function inside (see "custom read types", below).
  
  Predefined types are (if you have ideas for additional types, feel free to
  drop by and tell us):
  
  =over 4
  
  =item chunk => $octets, $cb->($handle, $data)
  
  Invoke the callback only once C<$octets> bytes have been read. Pass the
  data read to the callback. The callback will never be called with less
  data.
  
  Example: read 2 bytes.
  
     $handle->push_read (chunk => 2, sub {
        say "yay " . unpack "H*", $_[1];
     });
  
  =cut
  
  register_read_type chunk => sub {
     my ($self, $cb, $len) = @_;
  
     sub {
        $len <= length $_[0]{rbuf} or return;
        $cb->($_[0], substr $_[0]{rbuf}, 0, $len, "");
        1
     }
  };
  
  =item line => [$eol, ]$cb->($handle, $line, $eol)
  
  The callback will be called only once a full line (including the end of
  line marker, C<$eol>) has been read. This line (excluding the end of line
  marker) will be passed to the callback as second argument (C<$line>), and
  the end of line marker as the third argument (C<$eol>).
  
  The end of line marker, C<$eol>, can be either a string, in which case it
  will be interpreted as a fixed record end marker, or it can be a regex
  object (e.g. created by C<qr>), in which case it is interpreted as a
  regular expression.
  
  The end of line marker argument C<$eol> is optional, if it is missing (NOT
  undef), then C<qr|\015?\012|> is used (which is good for most internet
  protocols).
  
  Partial lines at the end of the stream will never be returned, as they are
  not marked by the end of line marker.
  
  =cut
  
  register_read_type line => sub {
     my ($self, $cb, $eol) = @_;
  
     if (@_ < 3) {
        # this is faster then the generic code below
        sub {
           (my $pos = index $_[0]{rbuf}, "\012") >= 0
              or return;
  
           (my $str = substr $_[0]{rbuf}, 0, $pos + 1, "") =~ s/(\015?\012)\Z// or die;
           $cb->($_[0], $str, "$1");
           1
        }
     } else {
        $eol = quotemeta $eol unless ref $eol;
        $eol = qr|^(.*?)($eol)|s;
  
        sub {
           $_[0]{rbuf} =~ s/$eol// or return;
  
           $cb->($_[0], "$1", "$2");
           1
        }
     }
  };
  
  =item regex => $accept[, $reject[, $skip], $cb->($handle, $data)
  
  Makes a regex match against the regex object C<$accept> and returns
  everything up to and including the match. All the usual regex variables
  ($1, %+ etc.) from the regex match are available in the callback.
  
  Example: read a single line terminated by '\n'.
  
     $handle->push_read (regex => qr<\n>, sub { ... });
  
  If C<$reject> is given and not undef, then it determines when the data is
  to be rejected: it is matched against the data when the C<$accept> regex
  does not match and generates an C<EBADMSG> error when it matches. This is
  useful to quickly reject wrong data (to avoid waiting for a timeout or a
  receive buffer overflow).
  
  Example: expect a single decimal number followed by whitespace, reject
  anything else (not the use of an anchor).
  
     $handle->push_read (regex => qr<^[0-9]+\s>, qr<[^0-9]>, sub { ... });
  
  If C<$skip> is given and not C<undef>, then it will be matched against
  the receive buffer when neither C<$accept> nor C<$reject> match,
  and everything preceding and including the match will be accepted
  unconditionally. This is useful to skip large amounts of data that you
  know cannot be matched, so that the C<$accept> or C<$reject> regex do not
  have to start matching from the beginning. This is purely an optimisation
  and is usually worth it only when you expect more than a few kilobytes.
  
  Example: expect a http header, which ends at C<\015\012\015\012>. Since we
  expect the header to be very large (it isn't in practice, but...), we use
  a skip regex to skip initial portions. The skip regex is tricky in that
  it only accepts something not ending in either \015 or \012, as these are
  required for the accept regex.
  
     $handle->push_read (regex =>
        qr<\015\012\015\012>,
        undef, # no reject
        qr<^.*[^\015\012]>,
        sub { ... });
  
  =cut
  
  register_read_type regex => sub {
     my ($self, $cb, $accept, $reject, $skip) = @_;
  
     my $data;
     my $rbuf = \$self->{rbuf};
  
     sub {
        # accept
        if ($$rbuf =~ $accept) {
           $data .= substr $$rbuf, 0, $+[0], "";
           $cb->($_[0], $data);
           return 1;
        }
        
        # reject
        if ($reject && $$rbuf =~ $reject) {
           $_[0]->_error (Errno::EBADMSG);
        }
  
        # skip
        if ($skip && $$rbuf =~ $skip) {
           $data .= substr $$rbuf, 0, $+[0], "";
        }
  
        ()
     }
  };
  
  =item netstring => $cb->($handle, $string)
  
  A netstring (http://cr.yp.to/proto/netstrings.txt, this is not an endorsement).
  
  Throws an error with C<$!> set to EBADMSG on format violations.
  
  =cut
  
  register_read_type netstring => sub {
     my ($self, $cb) = @_;
  
     sub {
        unless ($_[0]{rbuf} =~ s/^(0|[1-9][0-9]*)://) {
           if ($_[0]{rbuf} =~ /[^0-9]/) {
              $_[0]->_error (Errno::EBADMSG);
           }
           return;
        }
  
        my $len = $1;
  
        $_[0]->unshift_read (chunk => $len, sub {
           my $string = $_[1];
           $_[0]->unshift_read (chunk => 1, sub {
              if ($_[1] eq ",") {
                 $cb->($_[0], $string);
              } else {
                 $_[0]->_error (Errno::EBADMSG);
              }
           });
        });
  
        1
     }
  };
  
  =item packstring => $format, $cb->($handle, $string)
  
  An octet string prefixed with an encoded length. The encoding C<$format>
  uses the same format as a Perl C<pack> format, but must specify a single
  integer only (only one of C<cCsSlLqQiInNvVjJw> is allowed, plus an
  optional C<!>, C<< < >> or C<< > >> modifier).
  
  For example, DNS over TCP uses a prefix of C<n> (2 octet network order),
  EPP uses a prefix of C<N> (4 octtes).
  
  Example: read a block of data prefixed by its length in BER-encoded
  format (very efficient).
  
     $handle->push_read (packstring => "w", sub {
        my ($handle, $data) = @_;
     });
  
  =cut
  
  register_read_type packstring => sub {
     my ($self, $cb, $format) = @_;
  
     sub {
        # when we can use 5.10 we can use ".", but for 5.8 we use the re-pack method
        defined (my $len = eval { unpack $format, $_[0]{rbuf} })
           or return;
  
        $format = length pack $format, $len;
  
        # bypass unshift if we already have the remaining chunk
        if ($format + $len <= length $_[0]{rbuf}) {
           my $data = substr $_[0]{rbuf}, $format, $len;
           substr $_[0]{rbuf}, 0, $format + $len, "";
           $cb->($_[0], $data);
        } else {
           # remove prefix
           substr $_[0]{rbuf}, 0, $format, "";
  
           # read remaining chunk
           $_[0]->unshift_read (chunk => $len, $cb);
        }
  
        1
     }
  };
  
  =item json => $cb->($handle, $hash_or_arrayref)
  
  Reads a JSON object or array, decodes it and passes it to the
  callback. When a parse error occurs, an C<EBADMSG> error will be raised.
  
  If a C<json> object was passed to the constructor, then that will be
  used for the final decode, otherwise it will create a L<JSON::XS> or
  L<JSON::PP> coder object expecting UTF-8.
  
  This read type uses the incremental parser available with JSON version
  2.09 (and JSON::XS version 2.2) and above.
  
  Since JSON texts are fully self-delimiting, the C<json> read and write
  types are an ideal simple RPC protocol: just exchange JSON datagrams. See
  the C<json> write type description, above, for an actual example.
  
  =cut
  
  register_read_type json => sub {
     my ($self, $cb) = @_;
  
     my $json = $self->{json} ||= json_coder;
  
     my $data;
  
     sub {
        my $ref = eval { $json->incr_parse ($_[0]{rbuf}) };
  
        if ($ref) {
           $_[0]{rbuf} = $json->incr_text;
           $json->incr_text = "";
           $cb->($_[0], $ref);
  
           1
        } elsif ($@) {
           # error case
           $json->incr_skip;
  
           $_[0]{rbuf} = $json->incr_text;
           $json->incr_text = "";
  
           $_[0]->_error (Errno::EBADMSG);
  
           ()
        } else {
           $_[0]{rbuf} = "";
  
           ()
        }
     }
  };
  
  =item cbor => $cb->($handle, $scalar)
  
  Reads a CBOR value, decodes it and passes it to the callback. When a parse
  error occurs, an C<EBADMSG> error will be raised.
  
  If a L<CBOR::XS> object was passed to the constructor, then that will be
  used for the final decode, otherwise it will create a CBOR coder without
  enabling any options.
  
  You have to provide a dependency to L<CBOR::XS> on your own: this module
  will load the L<CBOR::XS> module, but AnyEvent does not depend on it
  itself.
  
  Since CBOR values are fully self-delimiting, the C<cbor> read and write
  types are an ideal simple RPC protocol: just exchange CBOR datagrams. See
  the C<cbor> write type description, above, for an actual example.
  
  =cut
  
  register_read_type cbor => sub {
     my ($self, $cb) = @_;
  
     my $cbor = $self->{cbor} ||= cbor_coder;
  
     my $data;
  
     sub {
        my (@value) = eval { $cbor->incr_parse ($_[0]{rbuf}) };
  
        if (@value) {
           $cb->($_[0], @value);
  
           1
        } elsif ($@) {
           # error case
           $cbor->incr_reset;
  
           $_[0]->_error (Errno::EBADMSG);
  
           ()
        } else {
           ()
        }
     }
  };
  
  =item storable => $cb->($handle, $ref)
  
  Deserialises a L<Storable> frozen representation as written by the
  C<storable> write type (BER-encoded length prefix followed by nfreeze'd
  data).
  
  Raises C<EBADMSG> error if the data could not be decoded.
  
  =cut
  
  register_read_type storable => sub {
     my ($self, $cb) = @_;
  
     require Storable unless $Storable::VERSION;
  
     sub {
        # when we can use 5.10 we can use ".", but for 5.8 we use the re-pack method
        defined (my $len = eval { unpack "w", $_[0]{rbuf} })
           or return;
  
        my $format = length pack "w", $len;
  
        # bypass unshift if we already have the remaining chunk
        if ($format + $len <= length $_[0]{rbuf}) {
           my $data = substr $_[0]{rbuf}, $format, $len;
           substr $_[0]{rbuf}, 0, $format + $len, "";
  
           eval { $cb->($_[0], Storable::thaw ($data)); 1 }
              or return $_[0]->_error (Errno::EBADMSG);
        } else {
           # remove prefix
           substr $_[0]{rbuf}, 0, $format, "";
  
           # read remaining chunk
           $_[0]->unshift_read (chunk => $len, sub {
              eval { $cb->($_[0], Storable::thaw ($_[1])); 1 }
                 or $_[0]->_error (Errno::EBADMSG);
           });
        }
  
        1
     }
  };
  
  =item tls_detect => $cb->($handle, $detect, $major, $minor)
  
  Checks the input stream for a valid SSL or TLS handshake TLSPaintext
  record without consuming anything. Only SSL version 3 or higher
  is handled, up to the fictituous protocol 4.x (but both SSL3+ and
  SSL2-compatible framing is supported).
  
  If it detects that the input data is likely TLS, it calls the callback
  with a true value for C<$detect> and the (on-wire) TLS version as second
  and third argument (C<$major> is C<3>, and C<$minor> is 0..4 for SSL
  3.0, TLS 1.0, 1.1, 1.2 and 1.3, respectively).  If it detects the input
  to be definitely not TLS, it calls the callback with a false value for
  C<$detect>.
  
  The callback could use this information to decide whether or not to start
  TLS negotiation.
  
  In all cases the data read so far is passed to the following read
  handlers.
  
  Usually you want to use the C<tls_autostart> read type instead.
  
  If you want to design a protocol that works in the presence of TLS
  dtection, make sure that any non-TLS data doesn't start with the octet 22
  (ASCII SYN, 16 hex) or 128-255 (i.e. highest bit set). The checks this
  read type does are a bit more strict, but might losen in the future to
  accomodate protocol changes.
  
  This read type does not rely on L<AnyEvent::TLS> (and thus, not on
  L<Net::SSLeay>).
  
  =item tls_autostart => [$tls_ctx, ]$tls
  
  Tries to detect a valid SSL or TLS handshake. If one is detected, it tries
  to start tls by calling C<starttls> with the given arguments.
  
  In practise, C<$tls> must be C<accept>, or a Net::SSLeay context that has
  been configured to accept, as servers do not normally send a handshake on
  their own and ths cannot be detected in this way.
  
  See C<tls_detect> above for more details.
  
  Example: give the client a chance to start TLS before accepting a text
  line.
  
     $hdl->push_read (tls_autostart => "accept");
     $hdl->push_read (line => sub {
        print "received ", ($_[0]{tls} ? "encrypted" : "cleartext"), " <$_[1]>\n";
     });
  
  =cut
  
  register_read_type tls_detect => sub {
     my ($self, $cb) = @_;
  
     sub {
        # this regex matches a full or partial tls record
        if (
           # ssl3+: type(22=handshake) major(=3) minor(any) length_hi
           $self->{rbuf} =~ /^(?:\z| \x16 (\z| [\x03\x04] (?:\z| . (?:\z| [\x00-\x40] ))))/xs
           # ssl2 comapatible: len_hi len_lo type(1) major minor dummy(forlength)
           or $self->{rbuf} =~ /^(?:\z| [\x80-\xff] (?:\z| . (?:\z| \x01 (\z| [\x03\x04] (?:\z| . (?:\z| . ))))))/xs
        ) {
           return if 3 != length $1; # partial match, can't decide yet
  
           # full match, valid TLS record
           my ($major, $minor) = unpack "CC", $1;
           $cb->($self, "accept", $major, $minor);
        } else {
           # mismatch == guaranteed not TLS
           $cb->($self, undef);
        }
  
        1
     }
  };
  
  register_read_type tls_autostart => sub {
     my ($self, @tls) = @_;
  
     $RH{tls_detect}($self, sub {
        return unless $_[1];
        $_[0]->starttls (@tls);
     })
  };
  
  =back
  
  =item custom read types - Package::anyevent_read_type $handle, $cb, @args
  
  Instead of one of the predefined types, you can also specify the name
  of a package. AnyEvent will try to load the package and then expects to
  find a function named C<anyevent_read_type> inside. If it isn't found, it
  progressively tries to load the parent package until it either finds the
  function (good) or runs out of packages (bad).
  
  Whenever this type is used, C<push_read> will invoke the function with the
  handle object, the original callback and the remaining arguments.
  
  The function is supposed to return a callback (usually a closure) that
  works as a plain read callback (see C<< ->push_read ($cb) >>), so you can
  mentally treat the function as a "configurable read type to read callback"
  converter.
  
  It should invoke the original callback when it is done reading (remember
  to pass C<$handle> as first argument as all other callbacks do that,
  although there is no strict requirement on this).
  
  For examples, see the source of this module (F<perldoc -m
  AnyEvent::Handle>, search for C<register_read_type>)).
  
  =item $handle->stop_read
  
  =item $handle->start_read
  
  In rare cases you actually do not want to read anything from the
  socket. In this case you can call C<stop_read>. Neither C<on_read> nor
  any queued callbacks will be executed then. To start reading again, call
  C<start_read>.
  
  Note that AnyEvent::Handle will automatically C<start_read> for you when
  you change the C<on_read> callback or push/unshift a read callback, and it
  will automatically C<stop_read> for you when neither C<on_read> is set nor
  there are any read requests in the queue.
  
  In older versions of this module (<= 5.3), these methods had no effect,
  as TLS does not support half-duplex connections. In current versions they
  work as expected, as this behaviour is required to avoid certain resource
  attacks, where the program would be forced to read (and buffer) arbitrary
  amounts of data before being able to send some data. The drawback is that
  some readings of the the SSL/TLS specifications basically require this
  attack to be working, as SSL/TLS implementations might stall sending data
  during a rehandshake.
  
  As a guideline, during the initial handshake, you should not stop reading,
  and as a client, it might cause problems, depending on your application.
  
  =cut
  
  sub stop_read {
     my ($self) = @_;
  
     delete $self->{_rw};
  }
  
  sub start_read {
     my ($self) = @_;
  
     unless ($self->{_rw} || $self->{_eof} || !$self->{fh}) {
        Scalar::Util::weaken $self;
  
        $self->{_rw} = AE::io $self->{fh}, 0, sub {
           my $rbuf = \($self->{tls} ? my $buf : $self->{rbuf});
           my $len = sysread $self->{fh}, $$rbuf, $self->{read_size}, length $$rbuf;
  
           if ($len > 0) {
              $self->{_activity} = $self->{_ractivity} = AE::now;
  
              if ($self->{tls}) {
                 Net::SSLeay::BIO_write ($self->{_rbio}, $$rbuf);
  
                 &_dotls ($self);
              } else {
                 $self->_drain_rbuf;
              }
  
              if ($len == $self->{read_size}) {
                 $self->{read_size} *= 2;
                 $self->{read_size} = $self->{max_read_size} || MAX_READ_SIZE
                    if $self->{read_size} > ($self->{max_read_size} || MAX_READ_SIZE);
              }
  
           } elsif (defined $len) {
              delete $self->{_rw};
              $self->{_eof} = 1;
              $self->_drain_rbuf;
  
           } elsif ($! != EAGAIN && $! != EINTR && $! != EWOULDBLOCK && $! != WSAEWOULDBLOCK) {
              return $self->_error ($!, 1);
           }
        };
     }
  }
  
  our $ERROR_SYSCALL;
  our $ERROR_WANT_READ;
  
  sub _tls_error {
     my ($self, $err) = @_;
  
     return $self->_error ($!, 1)
        if $err == Net::SSLeay::ERROR_SYSCALL ();
  
     my $err = Net::SSLeay::ERR_error_string (Net::SSLeay::ERR_get_error ());
  
     # reduce error string to look less scary
     $err =~ s/^error:[0-9a-fA-F]{8}:[^:]+:([^:]+):/\L$1: /;
  
     if ($self->{_on_starttls}) {
        (delete $self->{_on_starttls})->($self, undef, $err);
        &_freetls;
     } else {
        &_freetls;
        $self->_error (Errno::EPROTO, 1, $err);
     }
  }
  
  # poll the write BIO and send the data if applicable
  # also decode read data if possible
  # this is basiclaly our TLS state machine
  # more efficient implementations are possible with openssl,
  # but not with the buggy and incomplete Net::SSLeay.
  sub _dotls {
     my ($self) = @_;
  
     my $tmp;
  
     while (length $self->{_tls_wbuf}) {
        if (($tmp = Net::SSLeay::write ($self->{tls}, $self->{_tls_wbuf})) <= 0) {
           $tmp = Net::SSLeay::get_error ($self->{tls}, $tmp);
  
           return $self->_tls_error ($tmp)
              if $tmp != $ERROR_WANT_READ
                 && ($tmp != $ERROR_SYSCALL || $!);
  
           last;
        }
  
        substr $self->{_tls_wbuf}, 0, $tmp, "";
     }
  
     while (defined ($tmp = Net::SSLeay::read ($self->{tls}))) {
        unless (length $tmp) {
           $self->{_on_starttls}
              and (delete $self->{_on_starttls})->($self, undef, "EOF during handshake"); # ???
           &_freetls;
  
           if ($self->{on_stoptls}) {
              $self->{on_stoptls}($self);
              return;
           } else {
              # let's treat SSL-eof as we treat normal EOF
              delete $self->{_rw};
              $self->{_eof} = 1;
           }
        }
  
        $self->{_tls_rbuf} .= $tmp;
        $self->_drain_rbuf;
        $self->{tls} or return; # tls session might have gone away in callback
     }
  
     $tmp = Net::SSLeay::get_error ($self->{tls}, -1); # -1 is not neccessarily correct, but Net::SSLeay doesn't tell us
     return $self->_tls_error ($tmp)
        if $tmp != $ERROR_WANT_READ
           && ($tmp != $ERROR_SYSCALL || $!);
  
     while (length ($tmp = Net::SSLeay::BIO_read ($self->{_wbio}))) {
        $self->{wbuf} .= $tmp;
        $self->_drain_wbuf;
        $self->{tls} or return; # tls session might have gone away in callback
     }
  
     $self->{_on_starttls}
        and Net::SSLeay::state ($self->{tls}) == Net::SSLeay::ST_OK ()
        and (delete $self->{_on_starttls})->($self, 1, "TLS/SSL connection established");
  }
  
  =item $handle->starttls ($tls[, $tls_ctx])
  
  Instead of starting TLS negotiation immediately when the AnyEvent::Handle
  object is created, you can also do that at a later time by calling
  C<starttls>. See the C<tls> constructor argument for general info.
  
  Starting TLS is currently an asynchronous operation - when you push some
  write data and then call C<< ->starttls >> then TLS negotiation will start
  immediately, after which the queued write data is then sent. This might
  change in future versions, so best make sure you have no outstanding write
  data when calling this method.
  
  The first argument is the same as the C<tls> constructor argument (either
  C<"connect">, C<"accept"> or an existing Net::SSLeay object).
  
  The second argument is the optional C<AnyEvent::TLS> object that is used
  when AnyEvent::Handle has to create its own TLS connection object, or
  a hash reference with C<< key => value >> pairs that will be used to
  construct a new context.
  
  The TLS connection object will end up in C<< $handle->{tls} >>, the TLS
  context in C<< $handle->{tls_ctx} >> after this call and can be used or
  changed to your liking. Note that the handshake might have already started
  when this function returns.
  
  Due to bugs in OpenSSL, it might or might not be possible to do multiple
  handshakes on the same stream. It is best to not attempt to use the
  stream after stopping TLS.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  our %TLS_CACHE; #TODO not yet documented, should we?
  
  sub starttls {
     my ($self, $tls, $ctx) = @_;
  
     Carp::croak "It is an error to call starttls on an AnyEvent::Handle object while TLS is already active, caught"
        if $self->{tls};
  
     unless (defined $AnyEvent::TLS::VERSION) {
        eval {
           require Net::SSLeay;
           require AnyEvent::TLS;
           1
        } or return $self->_error (Errno::EPROTO, 1, "TLS support not available on this system");
     }
  
     $self->{tls}     = $tls;
     $self->{tls_ctx} = $ctx if @_ > 2;
  
     return unless $self->{fh};
  
     $ERROR_SYSCALL   = Net::SSLeay::ERROR_SYSCALL     ();
     $ERROR_WANT_READ = Net::SSLeay::ERROR_WANT_READ   ();
  
     $tls = delete $self->{tls};
     $ctx = $self->{tls_ctx};
  
     local $Carp::CarpLevel = 1; # skip ourselves when creating a new context or session
  
     if ("HASH" eq ref $ctx) {
        if ($ctx->{cache}) {
           my $key = $ctx+0;
           $ctx = $TLS_CACHE{$key} ||= new AnyEvent::TLS %$ctx;
        } else {
           $ctx = new AnyEvent::TLS %$ctx;
        }
     }
     
     $self->{tls_ctx} = $ctx || TLS_CTX ();
     $self->{tls}     = $tls = $self->{tls_ctx}->_get_session ($tls, $self, $self->{peername});
  
     # basically, this is deep magic (because SSL_read should have the same issues)
     # but the openssl maintainers basically said: "trust us, it just works".
     # (unfortunately, we have to hardcode constants because the abysmally misdesigned
     # and mismaintained ssleay-module didn't offer them for a decade or so).
     # http://www.mail-archive.com/openssl-dev@openssl.org/msg22420.html
     #
     # in short: this is a mess.
     #
     # note that we do not try to keep the length constant between writes as we are required to do.
     # we assume that most (but not all) of this insanity only applies to non-blocking cases,
     # and we drive openssl fully in blocking mode here. Or maybe we don't - openssl seems to
     # have identity issues in that area.
  #   Net::SSLeay::set_mode ($ssl,
  #      (eval { local $SIG{__DIE__}; Net::SSLeay::MODE_ENABLE_PARTIAL_WRITE () } || 1)
  #      | (eval { local $SIG{__DIE__}; Net::SSLeay::MODE_ACCEPT_MOVING_WRITE_BUFFER () } || 2));
     Net::SSLeay::set_mode ($tls, 1|2);
  
     $self->{_rbio} = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
     $self->{_wbio} = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
  
     Net::SSLeay::BIO_write ($self->{_rbio}, $self->{rbuf});
     $self->{rbuf} = "";
  
     Net::SSLeay::set_bio ($tls, $self->{_rbio}, $self->{_wbio});
  
     $self->{_on_starttls} = sub { $_[0]{on_starttls}(@_) }
        if $self->{on_starttls};
  
     &_dotls; # need to trigger the initial handshake
     $self->start_read; # make sure we actually do read
  }
  
  =item $handle->stoptls
  
  Shuts down the SSL connection - this makes a proper EOF handshake by
  sending a close notify to the other side, but since OpenSSL doesn't
  support non-blocking shut downs, it is not guaranteed that you can re-use
  the stream afterwards.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub stoptls {
     my ($self) = @_;
  
     if ($self->{tls} && $self->{fh}) {
        Net::SSLeay::shutdown ($self->{tls});
  
        &_dotls;
  
  #      # we don't give a shit. no, we do, but we can't. no...#d#
  #      # we, we... have to use openssl :/#d#
  #      &_freetls;#d#
     }
  }
  
  sub _freetls {
     my ($self) = @_;
  
     return unless $self->{tls};
  
     $self->{tls_ctx}->_put_session (delete $self->{tls})
        if $self->{tls} > 0;
     
     delete @$self{qw(_rbio _wbio _tls_wbuf _on_starttls)};
  }
  
  =item $handle->resettls
  
  This rarely-used method simply resets and TLS state on the handle, usually
  causing data loss.
  
  One case where it may be useful is when you want to skip over the data in
  the stream but you are not interested in interpreting it, so data loss is
  no concern.
  
  =cut
  
  *resettls = \&_freetls;
  
  sub DESTROY {
     my ($self) = @_;
  
     &_freetls;
  
     my $linger = exists $self->{linger} ? $self->{linger} : 3600;
  
     if ($linger && length $self->{wbuf} && $self->{fh}) {
        my $fh   = delete $self->{fh};
        my $wbuf = delete $self->{wbuf};
  
        my @linger;
  
        push @linger, AE::io $fh, 1, sub {
           my $len = syswrite $fh, $wbuf, length $wbuf;
  
           if ($len > 0) {
              substr $wbuf, 0, $len, "";
           } elsif (defined $len || ($! != EAGAIN && $! != EINTR && $! != EWOULDBLOCK && $! != WSAEWOULDBLOCK)) {
              @linger = (); # end
           }
        };
        push @linger, AE::timer $linger, 0, sub {
           @linger = ();
        };
     }
  }
  
  =item $handle->destroy
  
  Shuts down the handle object as much as possible - this call ensures that
  no further callbacks will be invoked and as many resources as possible
  will be freed. Any method you will call on the handle object after
  destroying it in this way will be silently ignored (and it will return the
  empty list).
  
  Normally, you can just "forget" any references to an AnyEvent::Handle
  object and it will simply shut down. This works in fatal error and EOF
  callbacks, as well as code outside. It does I<NOT> work in a read or write
  callback, so when you want to destroy the AnyEvent::Handle object from
  within such an callback. You I<MUST> call C<< ->destroy >> explicitly in
  that case.
  
  Destroying the handle object in this way has the advantage that callbacks
  will be removed as well, so if those are the only reference holders (as
  is common), then one doesn't need to do anything special to break any
  reference cycles.
  
  The handle might still linger in the background and write out remaining
  data, as specified by the C<linger> option, however.
  
  =cut
  
  sub destroy {
     my ($self) = @_;
  
     $self->DESTROY;
     %$self = ();
     bless $self, "AnyEvent::Handle::destroyed";
  }
  
  sub AnyEvent::Handle::destroyed::AUTOLOAD {
     #nop
  }
  
  =item $handle->destroyed
  
  Returns false as long as the handle hasn't been destroyed by a call to C<<
  ->destroy >>, true otherwise.
  
  Can be useful to decide whether the handle is still valid after some
  callback possibly destroyed the handle. For example, C<< ->push_write >>,
  C<< ->starttls >> and other methods can call user callbacks, which in turn
  can destroy the handle, so work can be avoided by checking sometimes:
  
     $hdl->starttls ("accept");
     return if $hdl->destroyed;
     $hdl->push_write (...
  
  Note that the call to C<push_write> will silently be ignored if the handle
  has been destroyed, so often you can just ignore the possibility of the
  handle being destroyed.
  
  =cut
  
  sub destroyed { 0 }
  sub AnyEvent::Handle::destroyed::destroyed { 1 }
  
  =item AnyEvent::Handle::TLS_CTX
  
  This function creates and returns the AnyEvent::TLS object used by default
  for TLS mode.
  
  The context is created by calling L<AnyEvent::TLS> without any arguments.
  
  =cut
  
  our $TLS_CTX;
  
  sub TLS_CTX() {
     $TLS_CTX ||= do {
        require AnyEvent::TLS;
  
        new AnyEvent::TLS
     }
  }
  
  =back
  
  
  =head1 NONFREQUENTLY ASKED QUESTIONS
  
  =over 4
  
  =item I C<undef> the AnyEvent::Handle reference inside my callback and
  still get further invocations!
  
  That's because AnyEvent::Handle keeps a reference to itself when handling
  read or write callbacks.
  
  It is only safe to "forget" the reference inside EOF or error callbacks,
  from within all other callbacks, you need to explicitly call the C<<
  ->destroy >> method.
  
  =item Why is my C<on_eof> callback never called?
  
  Probably because your C<on_error> callback is being called instead: When
  you have outstanding requests in your read queue, then an EOF is
  considered an error as you clearly expected some data.
  
  To avoid this, make sure you have an empty read queue whenever your handle
  is supposed to be "idle" (i.e. connection closes are O.K.). You can set
  an C<on_read> handler that simply pushes the first read requests in the
  queue.
  
  See also the next question, which explains this in a bit more detail.
  
  =item How can I serve requests in a loop?
  
  Most protocols consist of some setup phase (authentication for example)
  followed by a request handling phase, where the server waits for requests
  and handles them, in a loop.
  
  There are two important variants: The first (traditional, better) variant
  handles requests until the server gets some QUIT command, causing it to
  close the connection first (highly desirable for a busy TCP server). A
  client dropping the connection is an error, which means this variant can
  detect an unexpected detection close.
  
  To handle this case, always make sure you have a non-empty read queue, by
  pushing the "read request start" handler on it:
  
     # we assume a request starts with a single line
     my @start_request; @start_request = (line => sub {
        my ($hdl, $line) = @_;
  
        ... handle request
  
        # push next request read, possibly from a nested callback
        $hdl->push_read (@start_request);
     });
  
     # auth done, now go into request handling loop
     # now push the first @start_request
     $hdl->push_read (@start_request);
  
  By always having an outstanding C<push_read>, the handle always expects
  some data and raises the C<EPIPE> error when the connction is dropped
  unexpectedly.
  
  The second variant is a protocol where the client can drop the connection
  at any time. For TCP, this means that the server machine may run out of
  sockets easier, and in general, it means you cannot distinguish a protocl
  failure/client crash from a normal connection close. Nevertheless, these
  kinds of protocols are common (and sometimes even the best solution to the
  problem).
  
  Having an outstanding read request at all times is possible if you ignore
  C<EPIPE> errors, but this doesn't help with when the client drops the
  connection during a request, which would still be an error.
  
  A better solution is to push the initial request read in an C<on_read>
  callback. This avoids an error, as when the server doesn't expect data
  (i.e. is idly waiting for the next request, an EOF will not raise an
  error, but simply result in an C<on_eof> callback. It is also a bit slower
  and simpler:
  
     # auth done, now go into request handling loop
     $hdl->on_read (sub {
        my ($hdl) = @_;
  
        # called each time we receive data but the read queue is empty
        # simply start read the request
  
        $hdl->push_read (line => sub {
           my ($hdl, $line) = @_;
  
           ... handle request
  
           # do nothing special when the request has been handled, just
           # let the request queue go empty.
        });
     });
  
  =item I get different callback invocations in TLS mode/Why can't I pause
  reading?
  
  Unlike, say, TCP, TLS connections do not consist of two independent
  communication channels, one for each direction. Or put differently, the
  read and write directions are not independent of each other: you cannot
  write data unless you are also prepared to read, and vice versa.
  
  This means that, in TLS mode, you might get C<on_error> or C<on_eof>
  callback invocations when you are not expecting any read data - the reason
  is that AnyEvent::Handle always reads in TLS mode.
  
  During the connection, you have to make sure that you always have a
  non-empty read-queue, or an C<on_read> watcher. At the end of the
  connection (or when you no longer want to use it) you can call the
  C<destroy> method.
  
  =item How do I read data until the other side closes the connection?
  
  If you just want to read your data into a perl scalar, the easiest way
  to achieve this is by setting an C<on_read> callback that does nothing,
  clearing the C<on_eof> callback and in the C<on_error> callback, the data
  will be in C<$_[0]{rbuf}>:
  
     $handle->on_read (sub { });
     $handle->on_eof (undef);
     $handle->on_error (sub {
        my $data = delete $_[0]{rbuf};
     });
  
  Note that this example removes the C<rbuf> member from the handle object,
  which is not normally allowed by the API. It is expressly permitted in
  this case only, as the handle object needs to be destroyed afterwards.
  
  The reason to use C<on_error> is that TCP connections, due to latencies
  and packets loss, might get closed quite violently with an error, when in
  fact all data has been received.
  
  It is usually better to use acknowledgements when transferring data,
  to make sure the other side hasn't just died and you got the data
  intact. This is also one reason why so many internet protocols have an
  explicit QUIT command.
  
  =item I don't want to destroy the handle too early - how do I wait until
  all data has been written?
  
  After writing your last bits of data, set the C<on_drain> callback
  and destroy the handle in there - with the default setting of
  C<low_water_mark> this will be called precisely when all data has been
  written to the socket:
  
     $handle->push_write (...);
     $handle->on_drain (sub {
        AE::log debug => "All data submitted to the kernel.";
        undef $handle;
     });
  
  If you just want to queue some data and then signal EOF to the other side,
  consider using C<< ->push_shutdown >> instead.
  
  =item I want to contact a TLS/SSL server, I don't care about security.
  
  If your TLS server is a pure TLS server (e.g. HTTPS) that only speaks TLS,
  connect to it and then create the AnyEvent::Handle with the C<tls>
  parameter:
  
     tcp_connect $host, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh  => $fh,
           tls => "connect",
           on_error => sub { ... };
  
        $handle->push_write (...);
     };
  
  =item I want to contact a TLS/SSL server, I do care about security.
  
  Then you should additionally enable certificate verification, including
  peername verification, if the protocol you use supports it (see
  L<AnyEvent::TLS>, C<verify_peername>).
  
  E.g. for HTTPS:
  
     tcp_connect $host, $port, sub {
        my ($fh) = @_;
  
         my $handle = new AnyEvent::Handle
            fh       => $fh,
            peername => $host,
            tls      => "connect",
            tls_ctx  => { verify => 1, verify_peername => "https" },
            ...
  
  Note that you must specify the hostname you connected to (or whatever
  "peername" the protocol needs) as the C<peername> argument, otherwise no
  peername verification will be done.
  
  The above will use the system-dependent default set of trusted CA
  certificates. If you want to check against a specific CA, add the
  C<ca_file> (or C<ca_cert>) arguments to C<tls_ctx>:
  
         tls_ctx  => {
            verify          => 1,
            verify_peername => "https",
            ca_file         => "my-ca-cert.pem",
         },
  
  =item I want to create a TLS/SSL server, how do I do that?
  
  Well, you first need to get a server certificate and key. You have
  three options: a) ask a CA (buy one, use cacert.org etc.) b) create a
  self-signed certificate (cheap. check the search engine of your choice,
  there are many tutorials on the net) or c) make your own CA (tinyca2 is a
  nice program for that purpose).
  
  Then create a file with your private key (in PEM format, see
  L<AnyEvent::TLS>), followed by the certificate (also in PEM format). The
  file should then look like this:
  
     -----BEGIN RSA PRIVATE KEY-----
     ...header data
     ... lots of base64'y-stuff
     -----END RSA PRIVATE KEY-----
  
     -----BEGIN CERTIFICATE-----
     ... lots of base64'y-stuff
     -----END CERTIFICATE-----
  
  The important bits are the "PRIVATE KEY" and "CERTIFICATE" parts.  Then
  specify this file as C<cert_file>:
  
     tcp_server undef, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh       => $fh,
           tls      => "accept",
           tls_ctx  => { cert_file => "my-server-keycert.pem" },
           ...
  
  When you have intermediate CA certificates that your clients might not
  know about, just append them to the C<cert_file>.
  
  =back
  
  =head1 SUBCLASSING AnyEvent::Handle
  
  In many cases, you might want to subclass AnyEvent::Handle.
  
  To make this easier, a given version of AnyEvent::Handle uses these
  conventions:
  
  =over 4
  
  =item * all constructor arguments become object members.
  
  At least initially, when you pass a C<tls>-argument to the constructor it
  will end up in C<< $handle->{tls} >>. Those members might be changed or
  mutated later on (for example C<tls> will hold the TLS connection object).
  
  =item * other object member names are prefixed with an C<_>.
  
  All object members not explicitly documented (internal use) are prefixed
  with an underscore character, so the remaining non-C<_>-namespace is free
  for use for subclasses.
  
  =item * all members not documented here and not prefixed with an underscore
  are free to use in subclasses.
  
  Of course, new versions of AnyEvent::Handle may introduce more "public"
  member variables, but that's just life. At least it is documented.
  
  =back
  
  =head1 AUTHOR
  
  Robin Redeker C<< <elmex at ta-sa.org> >>, Marc Lehmann <schmorp@schmorp.de>.
  
  =cut
  
  1
  
ANYEVENT_HANDLE

$fatpacked{"AnyEvent/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO';
  =head1 NAME
  
  AnyEvent::IO - the DBI of asynchronous I/O implementations
  
  =head1 SYNOPSIS
  
     use AnyEvent::IO;
  
     # load /etc/passwd, call callback with the file data when done.
     aio_load "/etc/passwd", sub {
        my ($data) = @_
           or return AE::log error => "/etc/passwd: $!";
  
        warn "/etc/passwd contains ", ($data =~ y/://) , " colons.\n";
     };
  
     # the rest of the SYNOPSIS does the same, but with individual I/O calls
  
     # also import O_XXX flags
     use AnyEvent::IO qw(:DEFAULT :flags);
  
     my $filedata = AE::cv;
  
     # first open the file
     aio_open "/etc/passwd", O_RDONLY, 0, sub {
        my ($fh) = @_
           or return AE::log error => "/etc/passwd: $!";
  
        # now stat the file to get the size
        aio_stat $fh, sub {
           @_
              or return AE::log error => "/etc/passwd: $!";
  
           my $size = -s _;
  
           # now read all the file data
           aio_read $fh, $size, sub {
              my ($data) = @_
                 or return AE::log error => "/etc/passwd: $!";
  
              $size == length $data
                 or return AE::log error => "/etc/passwd: short read, file changed?";
  
              # mostly the same as aio_load, above - $data contains
              # the file contents now.
              $filedata->($data);
           };
        };
     };
  
     my $passwd = $filedata->recv;
     warn length $passwd, " octets.\n";
  
  =head1 DESCRIPTION
  
  This module provides functions that do I/O in an asynchronous fashion. It
  is to I/O the same as L<AnyEvent> is to event libraries - it only
  I<interfaces> to other implementations or to a portable pure-perl
  implementation (which does not, however, do asynchronous I/O).
  
  The only other implementation that is supported (or even known to the
  author) is L<IO::AIO>, which is used automatically when it can be loaded
  (via L<AnyEvent::AIO>, which also needs to be installed). If it is not
  available, then L<AnyEvent::IO> falls back to its synchronous pure-perl
  implementation.
  
  Unlike L<AnyEvent>, which model to use is currently decided at module load
  time, not at first use. Future releases might change this.
  
  =head2 RATIONALE
  
  While disk I/O often seems "instant" compared to, say, socket I/O, there
  are many situations where your program can block for extended time periods
  when doing disk I/O. For example, you access a disk on an NFS server and
  it is gone - can take ages to respond again, if ever. Or your system is
  extremely busy because it creates or restores a backup - reading data from
  disk can then take seconds. Or you use Linux, which for so many years has
  a close-to-broken VM/IO subsystem that can often induce minutes or more of
  delay for disk I/O, even under what I would consider light I/O loads.
  
  Whatever the situation, some programs just can't afford to block for long
  times (say, half a second or more), because they need to respond as fast
  as possible.
  
  For those cases, you need asynchronous I/O.
  
  The problem is, AnyEvent itself sometimes reads disk files (for example,
  when looking at F</etc/hosts>), and under the above situations, this can
  bring your program to a complete halt even if your program otherwise
  takes care to only use asynchronous I/O for everything (e.g. by using
  L<IO::AIO>).
  
  On the other hand, requiring L<IO::AIO> for AnyEvent is clearly
  impossible, as AnyEvent promises to stay pure-perl, and the overhead of
  IO::AIO for small programs would be immense, especially when asynchronous
  I/O isn't even needed.
  
  Clearly, this calls for an abstraction layer, and that is what you are
  looking at right now :-)
  
  =head2 ASYNCHRONOUS VS. NON-BLOCKING
  
  Many people are continuously confused on what the difference is between
  asynchronous I/O and non-blocking I/O. In fact, those two terms are
  not well defined, which often makes it hard to even talk about the
  difference. Here is a short guideline that should leave you less
  confused. It only talks about read operations, but the reasoning works
  with other I/O operations as well.
  
  Non-blocking I/O means that data is delivered by some external means,
  automatically - that is, something I<pushes> data towards your file
  handle, without you having to do anything. Non-blocking means that if
  your operating system currently has no data (or EOF, or some error)
  available for you, it will not wait ("block") as it would normally do,
  but immediately return with an error (e.g. C<EWOULDBLOCK> - "I would have
  blocked, but you forbid it").
  
  Your program can then wait for data to arrive by other means, for example,
  an I/O watcher which tells you when to re-attempt the read, after which it
  can try to read again, and so on.
  
  Often, you would expect this to work for disk files as well - if the data
  isn't already in memory, one might want to wait for it and then re-attempt
  the read for example. While this is sound reasoning, the POSIX API does
  not support this, because disk drives and file systems do not send data
  "on their own", and more so, the OS already knows that data is there, it
  doesn't need to "wait" until it arrives from some external entity, it only
  needs to transfer the data from disk to your memory buffer.
  
  So basically, while the concept is sound, the existing OS APIs do not
  support this. Therefore, it makes no sense to switch a disk file handle
  into non-blocking mode - it will behave exactly the same as in blocking
  mode, namely it will block until the data has been read from the disk.
  
  The alternative to non-blocking I/O that actually works with disk files
  is usually called I<asynchronous I/O>. Asynchronous, because the actual
  I/O is done while your program does something else: there is no need to
  call the read function to see if data is there, you only order the read
  once, and it will notify you when the read has finished and the data is
  your buffer - all the work is done in the background.
  
  This works with disk files, and even with sockets and other sources. It
  is, however, not very efficient when used with sources that could be
  driven in a non-blocking way, because it usually has higher overhead
  in the OS than non-blocking I/O, because it ties memory buffers for a
  potentially unlimited time and often only a limited number of operations
  can be done in parallel.
  
  That's why asynchronous I/O makes most sense when confronted with disk
  files, and non-blocking I/O only makes sense with sockets, pipes and
  similar streaming sources.
  
  =head1 IMPORT TAGS
  
  By default, this module exports all C<aio_>xxx functions. In addition,
  the following import tags can be used:
  
     :aio       all aio_* functions, same as :DEFAULT
     :flags     the fcntl open flags (O_CREAT, O_RDONLY, ...)
  
  =head1 API NOTES
  
  The functions in this module are not meant to be the most versatile or
  the highest-performers (they are not very slow either, of course). They
  are primarily meant to give users of your code the option to do the I/O
  asynchronously (by installing L<IO::AIO> and L<AnyEvent::AIO>),
  without adding a dependency on those modules.
  
  =head2 NAMING
  
  All the functions in this module implement an I/O operation, usually with
  the same or similar name as the Perl built-in that they mimic, but with
  an C<aio_> prefix. If you like you can think of the C<aio_>xxx functions as
  "AnyEvent I/O" or "Asynchronous I/O" variants of Perl built-ins.
  
  =head2 CALLING CONVENTIONS AND ERROR REPORTING
  
  Each function expects a callback as their last argument. The callback is
  usually called with the result data or result code. An error is usually
  signalled by passing no arguments to the callback, which is then free to
  look at C<$!> for the error code.
  
  This makes all of the following forms of error checking valid:
  
     aio_open ...., sub {
        my $fh = shift   # scalar assignment - will assign undef on error
           or return AE::log error => "...";
  
        my ($fh) = @_    # list assignment - will be 0 elements on error
           or return AE::log error => "...";
  
        @_               # check the number of elements directly
           or return AE::log error => "...";
  
  =head2 CAVEAT: RELATIVE PATHS
  
  When a path is specified, this path I<must be an absolute> path, unless
  you make certain that nothing in your process calls C<chdir> or an
  equivalent function while the request executes.
  
  =head2 CAVEAT: OTHER SHARED STATE
  
  Changing the C<umask> while any requests execute that create files (or
  otherwise rely on the current umask) results in undefined behaviour -
  likewise changing anything else that would change the outcome, such as
  your effective user or group ID.
  
  =head2 CALLBACKS MIGHT BE CALLED BEFORE FUNCTION RETURNS TO CALLER
  
  Unlike other functions in the AnyEvent module family, these functions
  I<may> call your callback instantly, before returning. This should not be
  a real problem, as these functions never return anything useful.
  
  =head2 BEHAVIOUR AT PROGRAM EXIT
  
  Both L<AnyEvent::IO::Perl> and L<AnyEvent::IO::IOAIO> implementations
  make sure that operations that have started will be finished on a clean
  programs exit. That makes programs work that start some I/O operations and
  then exit. For example this complete program:
  
     use AnyEvent::IO;
  
     aio_stat "path1", sub {
        aio_stat "path2", sub {
           warn "both stats done\n";
        };
     };
  
  Starts a C<stat> operation and then exits by "falling off the end" of
  the program. Nevertheless, I<both> C<stat> operations will be executed,
  as AnyEvent::IO waits for all outstanding requests to finish and you can
  start new requests from request callbacks.
  
  In fact, since L<AnyEvent::IO::Perl> is currently synchronous, the
  program will do both stats before falling off the end, but with
  L<AnyEvent::IO::IOAIO>, the program first falls of the end, then the stats
  are executed.
  
  While not guaranteed, this behaviour will be present in future versions,
  if reasonably possible (which is extreemly likely :).
  
  =cut
  
  package AnyEvent::IO;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use base "Exporter";
  
  our @AIO_REQ = qw(
     aio_load aio_open aio_close aio_seek aio_read aio_write aio_truncate
     aio_utime aio_chown aio_chmod aio_stat aio_lstat
     aio_link aio_symlink aio_readlink aio_rename aio_unlink
     aio_mkdir aio_rmdir aio_readdir
  );
  *EXPORT = \@AIO_REQ;
  our @FLAGS = qw(O_RDONLY O_WRONLY O_RDWR O_CREAT O_EXCL O_TRUNC O_APPEND);
  *EXPORT_OK = \@FLAGS;
  our %EXPORT_TAGS = (flags => \@FLAGS, aio => \@AIO_REQ);
  
  our $MODEL;
  
  if ($MODEL) {
     AE::log 7 => "Found preloaded IO model '$MODEL', using it.";
  } else {
     if ($ENV{PERL_ANYEVENT_IO_MODEL} =~ /^([a-zA-Z0-9:]+)$/) {
        if (eval { require "AnyEvent/IO/$ENV{PERL_ANYEVENT_IO_MODEL}.pm" }) {
           AE::log 7 => "Loaded IO model '$MODEL' (forced by \$ENV{PERL_ANYEVENT_IO_MODEL}), using it.";
        } else {
           undef $MODEL;
           AE::log 4 => "Unable to load IO model '$ENV{PERL_ANYEVENT_IO_MODEL}' (from \$ENV{PERL_ANYEVENT_IO_MODEL}):\n$@";
        }
     }
  
     unless ($MODEL) {
        if (eval { require IO::AIO; require AnyEvent::AIO; require AnyEvent::IO::IOAIO }) {
           AE::log 7 => "Autoloaded IO model 'IOAIO', using it.";
        } else {
           require AnyEvent::IO::Perl;
           AE::log 7 => "Autoloaded IO model 'Perl', using it.";
        }
     }
  }
  
  =head1 GLOBAL VARIABLES AND FUNCTIONS
  
  =over 4
  
  =item $AnyEvent::IO::MODEL
  
  Contains the package name of the backend I/O model in use - at the moment,
  this is usually C<AnyEvent::IO::Perl> or C<AnyEvent::IO::IOAIO>.
  
  =item aio_load $path, $cb->($data)
  
  Tries to open C<$path> and read its contents into memory (obviously,
  should only be used on files that are "small enough"), then passes them to
  the callback as a string.
  
  Example: load F</etc/hosts>.
  
     aio_load "/etc/hosts", sub {
        my ($hosts) = @_
           or return AE::log error => "/etc/hosts: $!";
  
        AE::log info => "/etc/hosts contains ", ($hosts =~ y/\n/), " lines\n";
     };
  
  =item aio_open $path, $flags, $mode, $cb->($fh)
  
  Tries to open the file specified by C<$path> with the O_XXX-flags
  C<$flags> (from the Fcntl module, or see below) and the mode C<$mode> (a
  good value is 0666 for C<O_CREAT>, and C<0> otherwise).
  
  The (normal, standard, perl) file handle associated with the opened file
  is then passed to the callback.
  
  This works very much like Perl's C<sysopen> function.
  
  Changing the C<umask> while this request executes results in undefined
  behaviour - likewise changing anything else that would change the outcome,
  such as your effective user or group ID.
  
  To avoid having to load L<Fcntl>, this module provides constants
  for C<O_RDONLY>, C<O_WRONLY>, C<O_RDWR>, C<O_CREAT>, C<O_EXCL>,
  C<O_TRUNC> and C<O_APPEND> - you can either access them directly
  (C<AnyEvent::IO::O_RDONLY>) or import them by specifying the C<:flags>
  import tag (see SYNOPSIS).
  
  Example: securely open a file in F</var/tmp>, fail if it exists or is a symlink.
  
     use AnyEvent::IO qw(:flags);
  
     aio_open "/var/tmp/mytmp$$", O_CREAT | O_EXCL | O_RDWR, 0600, sub {
        my ($fh) = @_
           or return AE::log error => "$! - denial of service attack?";
  
        # now we have $fh
     };
  
  =item aio_close $fh, $cb->($success)
  
  Closes the file handle (yes, close can block your process indefinitely)
  and passes a true value to the callback on success.
  
  Due to idiosyncrasies in perl, instead of calling C<close>, the file
  handle might get closed by C<dup2>'ing another file descriptor over
  it, that is, the C<$fh> might still be open, but can be closed safely
  afterwards and must not be used for anything.
  
  Example: close a file handle, and dirty as we are, do not even bother
  to check for errors.
  
     aio_close $fh, sub { };
  
  =item aio_read $fh, $length, $cb->($data)
  
  Tries to read C<$length> octets from the current position from C<$fh> and
  passes these bytes to C<$cb>. Otherwise the semantics are very much like
  those of Perl's C<sysread>.
  
  If less than C<$length> octets have been read, C<$data> will contain
  only those bytes actually read. At EOF, C<$data> will be a zero-length
  string. If an error occurs, then nothing is passed to the callback.
  
  Obviously, multiple C<aio_read>'s or C<aio_write>'s at the same time on file
  handles sharing the underlying open file description results in undefined
  behaviour, due to sharing of the current file offset (and less obviously
  so, because OS X is not thread safe and corrupts data when you try).
  
  Example: read 128 octets from a file.
  
     aio_read $fh, 128, sub {
        my ($data) = @_
           or return AE::log error "read from fh: $!";
    
        if (length $data) {
           print "read ", length $data, " octets.\n";
        } else {
           print "EOF\n";
        }
     };
  
  =item aio_seek $fh, $offset, $whence, $callback->($offs)
  
  Seeks the filehandle to the new C<$offset>, similarly to Perl's
  C<sysseek>. The C<$whence> are the traditional values (C<0> to count from
  start, C<1> to count from the current position and C<2> to count from the
  end).
  
  The resulting absolute offset will be passed to the callback on success.
  
  Example: measure the size of the file in the old-fashioned way using seek.
  
     aio_seek $fh, 0, 2, sub {
        my ($size) = @_
           or return AE::log error => "seek to end failed: $!";
  
        # maybe we need to seek to the beginning again?
        aio_seek $fh, 0, 0, sub {
           # now we are hopefully at the beginning
        };
     };
  
  =item aio_write $fh, $data, $cb->($length)
  
  Tries to write the octets in C<$data> to the current position of C<$fh>
  and passes the actual number of bytes written to the C<$cb>. Otherwise the
  semantics are very much like those of Perl's C<syswrite>.
  
  If less than C<length $data> octets have been written, C<$length> will
  reflect that. If an error occurs, then nothing is passed to the callback.
  
  Obviously, multiple C<aio_read>'s or C<aio_write>'s at the same time on file
  handles sharing the underlying open file description results in undefined
  behaviour, due to sharing of the current file offset (and less obviously
  so, because OS X is not thread safe and corrupts data when you try).
  
  =item aio_truncate $fh_or_path, $new_length, $cb->($success)
  
  Calls C<truncate> on the path or perl file handle and passes a true value
  to the callback on success.
  
  Example: truncate F</etc/passwd> to zero length - this only works on
  systems that support C<truncate>, should not be tried out for obvious
  reasons and debian will probably open yte another security bug about this
  example.
  
     aio_truncate "/etc/passwd", sub {
        @_
           or return AE::log error => "/etc/passwd: $! - are you root enough?";
     };
  
  =item aio_utime $fh_or_path, $atime, $mtime, $cb->($success)
  
  Calls C<utime> on the path or perl file handle and passes a true value to
  the callback on success.
  
  The special case of both C<$atime> and C<$mtime> being C<undef> sets the
  times to the current time, on systems that support this.
  
  Example: try to touch F<file>.
  
     aio_utime "file", undef, undef, sub { };
  
  =item aio_chown $fh_or_path, $uid, $gid, $cb->($success)
  
  Calls C<chown> on the path or perl file handle and passes a true value to
  the callback on success.
  
  If C<$uid> or C<$gid> can be specified as C<undef>, in which case the
  uid or gid of the file is not changed. This differs from Perl's C<chown>
  built-in, which wants C<-1> for this.
  
  Example: update the group of F<file> to 0 (root), but leave the owner alone.
  
     aio_chown "file", undef, 0, sub {
        @_
           or return AE::log error => "chown 'file': $!";
     };
  
  =item aio_chmod $fh_or_path, $perms, $cb->($success)
  
  Calls C<chmod> on the path or perl file handle and passes a true value to
  the callback on success.
  
  Example: change F<file> to be user/group/world-readable, but leave the other flags
  alone.
  
     aio_stat "file", sub {
        @_
           or return AE::log error => "file: $!";
  
        aio_chmod "file", (stat _)[2] & 07777 | 00444, sub { };
     };
  
  =item aio_stat $fh_or_path, $cb->($success)
  
  =item aio_lstat $path, $cb->($success)
  
  Calls C<stat> or C<lstat> on the path or perl file handle and passes a
  true value to the callback on success.
  
  The stat data will be available by C<stat>'ing the C<_> file handle
  (e.g. C<-x _>, C<stat _> and so on).
  
  Example: see if we can find the number of subdirectories of F</etc>.
  
     aio_stat "/etc", sub {
        @_
           or return AE::log error => "/etc: $!";
  
        (stat _)[3] >= 2
           or return AE::log warn => "/etc has low link count - non-POSIX filesystem?";
  
        print "/etc has ", (stat _)[3] - 2, " subdirectories.\n";
     };
  
  =item aio_link $oldpath, $newpath, $cb->($success)
  
  Calls C<link> on the paths and passes a true value to the callback on
  success.
  
  Example: link "F<file> to F<file.bak>, then rename F<file.new> over F<file>,
  to atomically replace it.
  
     aio_link "file", "file.bak", sub {
        @_
           or return AE::log error => "file: $!";
  
        aio_rename "file.new", "file", sub {
           @_
              or return AE::log error => "file.new: $!";
  
           print "file atomically replaced by file.new, backup file.bak\n";
        };
     };
  
  =item aio_symlink $oldpath, $newpath, $cb->($success)
  
  Calls C<symlink> on the paths and passes a true value to the callback on
  success.
  
  Example: create a symlink "F<slink> containing "random data".
  
     aio_symlink "random data", "slink", sub {
        @_
           or return AE::log error => "slink: $!";
     };
  
  =item aio_readlink $path, $cb->($target)
  
  Calls C<readlink> on the paths and passes the link target string to the
  callback.
  
  Example: read the symlink called Fyslink> and verify that it contains "random data".
  
    aio_readlink "slink", sub {
       my ($target) = @_
          or return AE::log error => "slink: $!";
  
       $target eq "random data"
          or AE::log critical => "omg, the world will end!";
    };
  
  =item aio_rename $oldpath, $newpath, $cb->($success)
  
  Calls C<rename> on the paths and passes a true value to the callback on
  success.
  
  See C<aio_link> for an example.
  
  =item aio_unlink $path, $cb->($success)
  
  Tries to unlink the object at C<$path> and passes a true value to the
  callback on success.
  
  Example: try to delete the file F<tmpfile.dat~>.
  
     aio_unlink "tmpfile.dat~", sub { };
  
  =item aio_mkdir $path, $perms, $cb->($success)
  
  Calls C<mkdir> on the path with the given permissions C<$perms> (when in
  doubt, C<0777> is a good value) and passes a true value to the callback on
  success.
  
  Example: try to create the directory F<subdir> and leave it to whoeveer
  comes after us to check whether it worked.
  
     aio_mkdir "subdir", 0777, sub { };
  
  =item aio_rmdir $path, $cb->($success)
  
  Tries to remove the directory at C<$path> and passes a true value to the
  callback on success.
  
  Example: try to remove the directory F<subdir> and don't give a damn if
  that fails.
  
     aio_rmdir "subdir", sub { };
  
  =item aio_readdir $path, $cb->(\@names)
  
  Reads all filenames from the directory specified by C<$path> and passes
  them to the callback, as an array reference with the names (without a path
  prefix). The F<.> and F<..> names will be filtered out first.
  
  The ordering of the file names is undefined - backends that are capable
  of it (e.g. L<IO::AIO>) will return the ordering that most likely is
  fastest to C<stat> through, and furthermore put entries that likely are
  directories first in the array.
  
  If you need best performance in recursive directory traversal or when
  looking at really big directories, you are advised to use L<IO::AIO>
  directly, specifically the C<aio_readdirx> and C<aio_scandir> functions,
  which have more options to tune performance.
  
  Example: recursively scan a directory hierarchy, silently skip diretcories
  we couldn't read and print all others.
  
     sub scan($); # visibility-in-next statement is not so useful these days
     sub scan($) {
        my ($path) = @_;
  
        aio_readdir $path, sub {
           my ($names) = @_
              or return;
  
           print "$path\n";
  
           for my $name (@$names) {
              aio_lstat "$path/$name", sub {
                 scan "$path/$name"
                    if -d _;
              };
           }
        };
     }
  
     scan "/etc";
  
  =back
  
  =head1 ENVIRONMENT VARIABLES
  
  See the description of C<PERL_ANYEVENT_IO_MODEL> in the L<AnyEvent>
  manpage.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IO

$fatpacked{"AnyEvent/IO/IOAIO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_IOAIO';
  =head1 NAME
  
  AnyEvent::IO::IOAIO - AnyEvent::IO backend based on IO::AIO
  
  =head1 SYNOPSIS
  
     use AnyEvent::IO;
  
  =head1 DESCRIPTION
  
  This is the L<IO::AIO>-based backend of L<AnyEvent::IO> (via
  L<AnyEvent::AIO>). All I/O operations it implements are done
  asynchronously.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::IO::IOAIO;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  our $VERSION = $AnyEvent::VERSION;
  
  package AnyEvent::IO;
  
  use IO::AIO 4.13 ();
  use AnyEvent::AIO ();
  
  our $MODEL = "AnyEvent::IO::IOAIO";
  
  sub aio_load($$) {
     my ($cb, $data) = $_[1];
     IO::AIO::aio_load $_[0], $data,                  sub { $cb->($_[0] >= 0 ? $data : ()) };
  }
  
  sub aio_open($$$$) {
     my $cb = $_[3];
     IO::AIO::aio_open $_[0], $_[1], $_[2],           sub { $cb->($_[0] or ()) };
  }
  
  sub aio_close($$) {
     my $cb = $_[1];
     IO::AIO::aio_close $_[0],                        sub { $cb->($_[0] >= 0 ? 1 : ()) };
  }
  
  sub aio_seek($$$$) {
     my ($cb) = $_[3];
     IO::AIO::aio_seek $_[0], $_[1], $_[2],           sub { $cb->($_[0] >= 0 ? $_[0] : ()) };
  }
  
  sub aio_read($$$) {
     my ($cb, $data) = $_[2];
     IO::AIO::aio_read $_[0], undef, $_[1], $data, 0, sub { $cb->($_[0] >= 0 ? $data : ()) };
  }
  
  sub aio_write($$$) {
     my $cb = $_[2];
     IO::AIO::aio_write $_[0], undef, (length $_[1]), $_[1], 0,
                                                      sub { $cb->($_[0] >= 0 ? $_[0] : ()) };
  }
  
  sub aio_truncate($$$) {
     my $cb = $_[2];
     IO::AIO::aio_truncate $_[0], $_[1],              sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_utime($$$$) {
     my $cb = $_[3];
     IO::AIO::aio_utime $_[0], $_[1], $_[2],          sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_chown($$$$) {
     my $cb = $_[3];
     IO::AIO::aio_chown $_[0], $_[1], $_[2],          sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_chmod($$$) {
     my $cb = $_[2];
     IO::AIO::aio_chmod $_[0], $_[1],                 sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_stat($$) {
     my $cb = $_[1];
     IO::AIO::aio_stat $_[0],                         sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_lstat($$) {
     my $cb = $_[1];
     IO::AIO::aio_lstat $_[0],                        sub { $cb->($_[0] ? () : 1) }
  }
  
  sub aio_link($$$) {
     my $cb = $_[2];
     IO::AIO::aio_link $_[0], $_[1],                  sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_symlink($$$) {
     my $cb = $_[2];
     IO::AIO::aio_symlink $_[0], $_[1],               sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_readlink($$) {
     my $cb = $_[1];
     IO::AIO::aio_readlink $_[0],                     sub { $cb->(defined $_[0] ? $_[0] : ()) };
  }
  
  sub aio_rename($$$) {
     my $cb = $_[2];
     IO::AIO::aio_rename $_[0], $_[1],                sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_unlink($$) {
     my $cb = $_[1];
     IO::AIO::aio_unlink $_[0],                       sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_mkdir($$$) {
     my $cb = $_[2];
     IO::AIO::aio_mkdir $_[0], $_[1],                 sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_rmdir($$) {
     my $cb = $_[1];
     IO::AIO::aio_rmdir $_[0],                        sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_readdir($$) {
     my $cb = $_[1];
  
     IO::AIO::aio_readdirx $_[0], IO::AIO::READDIR_DIRS_FIRST | IO::AIO::READDIR_STAT_ORDER,
                                                      sub { $cb->($_[0] or ()); };
  }
  
  =back
  
  =head1 SEE ALSO
  
  L<AnyEvent::IO>, L<AnyEvent>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IO_IOAIO

$fatpacked{"AnyEvent/IO/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_PERL';
  =head1 NAME
  
  AnyEvent::IO::Perl - pure perl backend for AnyEvent::IO
  
  =head1 SYNOPSIS
  
     use AnyEvent::IO;
  
  =head1 DESCRIPTION
  
  This is the pure-perl backend of L<AnyEvent::IO> - it is always available,
  but does not actually implement any I/O operation asynchronously -
  everything is synchronous.
  
  For simple programs that can wait for I/O, this is likely the most
  efficient implementation.
  
  =cut
  
  package AnyEvent::IO::Perl;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  our $VERSION = $AnyEvent::VERSION;
  
  package AnyEvent::IO;
  
  our $MODEL = "AnyEvent::IO::Perl";
  
  sub aio_load($$) {
     my ($path, $cb, $fh, $data) = @_;
  
     $cb->(
        (open $fh, "<:raw:perlio", $path
           and stat $fh
           and (-s _) == sysread $fh, $data, -s _)
        ? $data : ()
     );
  }
  
  sub aio_open($$$$) {
     sysopen my $fh, $_[0], $_[1], $_[2]
        or return $_[3]();
  
     $_[3]($fh)
  }
  
  sub aio_close($$) {
     $_[1](close $_[0]);
  }
  
  sub aio_seek($$$$) {
     my $data;
     $_[3](sysseek $_[0], $_[1], $_[2] or ());
  }
  
  sub aio_read($$$) {
     my $data;
     $_[2]( (defined sysread $_[0], $data, $_[1]) ? $data : () );
  }
  
  sub aio_write($$$) {
     my $res = syswrite $_[0], $_[1];
     $_[2](defined $res ? $res : ());
  }
  
  sub aio_truncate($$$) {
     #TODO: raises an exception on !truncate|ftruncate systems, maybe eval + set errno?
     $_[2](truncate $_[0], $_[1] or ());
  }
  
  sub aio_utime($$$$) {
     $_[3](utime $_[1], $_[2], $_[0] or ());
  }
  
  sub aio_chown($$$$) {
     $_[3](chown defined $_[1] ? $_[1] : -1, defined $_[2] ? $_[2] : -1, $_[0] or ());
  }
  
  sub aio_chmod($$$) {
     $_[2](chmod $_[1], $_[0] or ());
  }
  
  sub aio_stat($$) {
     $_[1](stat  $_[0]);
  }
  
  sub aio_lstat($$) {
     $_[1](lstat $_[0]);
  }
  
  sub aio_link($$$) {
     $_[2](link $_[0], $_[1] or ());
  }
  
  sub aio_symlink($$$) {
     #TODO: raises an exception on !symlink systems, maybe eval + set errno?
     $_[2](symlink $_[0], $_[1] or ());
  }
  
  sub aio_readlink($$) {
     #TODO: raises an exception on !symlink systems, maybe eval + set errno?
     my $res = readlink $_[0];
     $_[1](defined $res ? $res : ());
  }
  
  sub aio_rename($$$) {
     $_[2](rename $_[0], $_[1] or ());
  }
  
  sub aio_unlink($$) {
     $_[1](unlink $_[0] or ());
  }
  
  sub aio_mkdir($$$) {
     $_[2](mkdir $_[0], $_[1] or ());
  }
  
  sub aio_rmdir($$) {
     $_[1](rmdir $_[0] or ());
  }
  
  sub aio_readdir($$) {
     my ($fh, @res);
  
     opendir $fh, $_[0]
        or return $_[1]();
  
     @res = grep !/^\.\.?$/, readdir $fh;
  
     $_[1]((closedir $fh) ? \@res : ());
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent::IO>, L<AnyEvent>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IO_PERL

$fatpacked{"AnyEvent/Impl/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_COCOA';
  =head1 NAME
  
  AnyEvent::Impl::Cocoa - AnyEvent adaptor for Cocoa::EventLoop
  
  =head1 SYNOPSIS
  
      use AnyEvent;
      use Cocoa::EventLoop;
      
      # do something
  
  =head1 DESCRIPTION
  
  This module provides NSRunLoop support to AnyEvent.
  
  NSRunLoop is an event loop for Cocoa applications, wrapped by
  L<Cocoa::EventLoop>. By using this module, you can use Cocoa based API in
  your AnyEvent application, or AnyEvent within Cocoa applications.
  
  It does not support blocking waits.
  
  =head1 BUGS
  
  Right now, L<Cocoa::EventLoop> (and this module) are in an early
  development phase and has some shortcomings and likely bugs.
  
  For example, there seems to be no way to just handle a single event
  with Cocoa (is there nothing they can implement properly?), so this
  module currently wakes up at least ten times a second when waiting for
  events. Also, events caused by timers might get delayed by up to 0.1
  seconds.
  
  =cut
  
  package AnyEvent::Impl::Cocoa;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Cocoa::EventLoop;
  
  sub io {
     my ($class, %arg) = @_;
  
     Cocoa::EventLoop->io (%arg)
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     Cocoa::EventLoop->timer (%arg)
  }
  
  # does not support blocking waits
  
  #sub loop {
  #   Cocoa::EventLoop->run;
  #}
  
  =head1 AUTHORS
  
  Daisuke Murase <typester@cpan.org>, Marc Lehmann <schmorp@schmorp.de>.
  
  =head1 COPYRIGHTS
  
     Copyright (c) 2009 by KAYAC Inc.
     Copyright (c) 2010,2011 by Marc Lehmann <schmorp@schmorp.de>
  
  =cut
  
  1
  
ANYEVENT_IMPL_COCOA

$fatpacked{"AnyEvent/Impl/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EV';
  =head1 NAME
  
  AnyEvent::Impl::EV - AnyEvent adaptor for EV
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use EV;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make EV work with AnyEvent except by loading EV before
  creating the first AnyEvent watcher.
  
  EV is the fastest event library for perl, and best supported by
  AnyEvent. Most functions from the L<AE> API are implemented as direct
  aliases to EV functions, so using EV via AE is as fast as using EV
  directly.
  
  =cut
  
  package AnyEvent::Impl::EV;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use EV 4.00;
  
  *AE::time       = \&EV::time;
  *AE::now        = \&EV::now;
  *AE::now_update = \&EV::now_update;
  *AE::timer      = \&EV::timer;
  *AE::signal     = \&EV::signal;
  *AE::idle       = \&EV::idle;
  
  # cannot override directly, as EV doesn't allow arguments
  sub time       { EV::time       }
  sub now        { EV::now        }
  sub now_update { EV::now_update }
  
  *AE::io = defined &EV::_ae_io # 3.8+, but keep just in case it is dropped
     ? \&EV::_ae_io
     : sub($$$) { EV::io $_[0], $_[1] ? EV::WRITE : EV::READ, $_[2] };
  
  sub timer {
     my ($class, %arg) = @_;
  
     EV::timer $arg{after}, $arg{interval}, $arg{cb}
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     EV::io
        $arg{fh},
        $arg{poll} eq "r" ? EV::READ : EV::WRITE,
        $arg{cb}
  }
  
  sub signal {
     my ($class, %arg) = @_;
  
     EV::signal $arg{signal}, $arg{cb}
  }
  
  sub child {
     my ($class, %arg) = @_;
  
     my $cb = $arg{cb};
  
     EV::child $arg{pid}, 0, sub {
        $cb->($_[0]->rpid, $_[0]->rstatus);
     }
  }
  
  sub idle {
     my ($class, %arg) = @_;
  
     EV::idle $arg{cb}
  }
  
  sub _poll {
     EV::run EV::RUN_ONCE;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     EV::run EV::RUN_ONCE until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   EV::run;
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<EV>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_EV

$fatpacked{"AnyEvent/Impl/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENT';
  =head1 NAME
  
  AnyEvent::Impl::Event - AnyEvent adaptor for Event
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Event;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Event work with AnyEvent except by loading Event before
  creating the first AnyEvent watcher.
  
  The event module is reasonably efficient and generally works correctly
  even with many watchers, except that its signal handling is inherently
  racy and requires the wake-up-frequently workaround.
  
  =cut
  
  package AnyEvent::Impl::Event;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Event qw(unloop); # we have to import something to make Event use Time::HiRes
  
  sub io {
     my (undef, %arg) = @_;
     $arg{fd} = delete $arg{fh};
     $arg{poll} .= "e" if AnyEvent::WIN32; # work around windows connect bug
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \(Event->io (%arg)), __PACKAGE__
  }
  
  sub timer {
     my (undef, %arg) = @_;
     $arg{after} = 0 if $arg{after} < 0;
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \Event->timer (%arg, repeat => $arg{interval}), __PACKAGE__
  }
  
  sub idle {
     my (undef, %arg) = @_;
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \Event->idle (repeat => 1, min => 0, %arg), __PACKAGE__
  }
  
  sub DESTROY {
     ${$_[0]}->cancel;
  }
  
  sub signal {
     my (undef, %arg) = @_;
  
     my $cb = $arg{cb};
     my $w = Event->signal (
        signal => AnyEvent::Base::sig2name $arg{signal},
        cb     => sub { &$cb }, # event doesn't like callable objects
     );
  
     AnyEvent::Base::_sig_add;
     bless \$w, "AnyEvent::Impl::Event::signal"
  }
  
  sub AnyEvent::Impl::Event::signal::DESTROY {
     AnyEvent::Base::_sig_del;
     ${$_[0]}->cancel;
  }
  
  sub _poll {
     Event::one_event;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Event::one_event until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   Event::loop;
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Event>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_EVENT

$fatpacked{"AnyEvent/Impl/EventLib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENTLIB';
  =head1 NAME
  
  AnyEvent::Impl::EventLib - AnyEvent adaptor for Event::Lib
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Event::Lib;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Event work with AnyEvent except by loading Event::Lib
  before creating the first AnyEvent watcher.
  
  Note: the AnyEvent author has not found recent releases of Event::Lib to
  be even remotely working (not even the examples from the manpage or the
  testsuite work), so this event backend should be avoided (or somebody
  should step up and maintain it, hint, hint).
  
  The L<Event::Lib> module suffers from the same limitations and bugs as
  libevent, most notably it kills already-installed watchers on a file
  descriptor and it is unable to support fork. These are not fatal issues,
  and are worked-around by this module, but the L<Event::Lib> perl module
  itself has many additional bugs such as taking references to file handles
  and callbacks instead of making a copy or freeing still-allocated scalars,
  causing memory corruption and random crashes. Only Tk rivals it in its
  brokenness.
  
  This adaptor module employs the same workaround around the watcher
  problems as Tk and should therefore be avoided. (This was done for
  simplicity, one could in theory work around the problems with lower
  overhead by managing our own watchers).
  
  Event::Lib also leaks file handles and memory and tends to just exit on
  problems.
  
  It also doesn't work around the Windows bug of not signalling TCP
  connection failures.
  
  It also doesn't work with many special devices on Linux (F</dev/random>
  works, F</dev/urandom> fails, F</dev/tty> works, F</dev/null> fails and so
  on).
  
  Event::Lib does not support idle watchers. They could be emulated using
  low-priority timers but as the priority range (and availability) is not
  queryable nor guaranteed, and the default priority is likely the lowest
  one, this module cannot use them.
  
  Avoid Event::Lib if you can.
  
  =cut
  
  package AnyEvent::Impl::EventLib;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Event::Lib;
  
  # Event::Lib doesn't always take a reference to the callback, so closures
  # cause memory corruption and segfaults. it also has an issue actually
  # calling callbacks, so this exists as workaround.
  sub ccb {
     # Event:Lib accesses $_[0] after the callback, when it might be freed,
     # so we keep it referenced until after the callback. This still accesses
     # a freed scalar, but at least it'll not crash.
     my $keep_it = $_[0];
  
     $_[2]();
  }
  
  my $ccb = \&ccb;
  
  sub io {
     my (undef, %arg) = @_;
  
     # work around these bugs in Event::Lib:
     # - adding a callback might destroy other callbacks
     # - only one callback per fd/poll combination
     my ($fh, $mode) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, EV_READ, EV_WRITE;
  
     # event_new errornously takes a reference to fh and cb instead of making a copy
     # fortunately, going through %arg/_dupfh already makes a copy, so it happpens to work
     my $w = event_new $fh, $mode | EV_PERSIST, $ccb, $arg{cb};
     event_add $w;
     bless \\$w, __PACKAGE__
  }
  
  sub timer {
     my (undef, %arg) = @_;
  
     my $ival = $arg{interval};
     my $cb   = $arg{cb};
  
     my $w; $w = timer_new $ccb,
                    $ival
                       ? sub { event_add $w, $ival; &$cb }
                       : sub { undef $w           ; &$cb };
  
     event_add $w, $arg{after} || 1e-10; # work around 0-bug in Event::Lib
  
     bless \\$w, __PACKAGE__
  }
  
  sub DESTROY {
     local $@;
     ${${$_[0]}}->remove;
  }
  
  sub signal {
     my (undef, %arg) = @_;
  
     my $w = signal_new AnyEvent::Base::sig2num $arg{signal}, $ccb, $arg{cb};
     event_add $w;
     AnyEvent::Base::_sig_add;
     bless \\$w, "AnyEvent::Impl::EventLib::signal"
  }
  
  sub AnyEvent::Impl::EventLib::signal::DESTROY {
     AnyEvent::Base::_sig_del;
     local $@;
     ${${$_[0]}}->remove;
  }
  
  #sub loop {
  #   event_mainloop;
  #}
  
  sub _poll {
     event_one_loop;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     event_one_loop until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Event::Lib>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_EVENTLIB

$fatpacked{"AnyEvent/Impl/FLTK.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_FLTK';
  =head1 NAME
  
  AnyEvent::Impl::FLTK - AnyEvent adaptor for FLTK (Fast Light Toolkit version two)
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use FLTK;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make FLTK work with AnyEvent except by loading FLTK before
  creating the first AnyEvent watcher.
  
  This implementation is not to be confused with AnyEvent::Impl::FLTK by
  Sanko Robinson. That implementation is completely broken, and the author
  is apparently unreachable.
  
  In any case, FLTK suffers from typical GUI-ToolKit diseases, such as O(n)
  or worse for every operation (adding a timer, destroying a timer etc.),
  the typical Not-Well-Tested Perl Interface disases such as non-random
  memory corruption and the typical Event-Loop-as-an-Afterthrough issues,
  such as multiple watchers on the same fd silently overwriting the others.
  
  It doesn't have native idle, signal or child watchers, so all of these are
  emulated.
  
  =cut
  
  package AnyEvent::Impl::FLTK;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use FLTK 0.532 ();
  use Scalar::Util ();
  
  #*AE::timer      = \&EV::timer;
  #*AE::signal     = \&EV::signal;
  #*AE::idle       = \&EV::idle;
  
  # FLTK::get_time_secs returns a glob :/
  # on unix, fltk uses gettimeofday, so we are likely compatible
  # on windows, fltk uses GetTickCount, to which we are unlikely to be compatible with.
  #sub time { FLTK::get_time_secs }
  #*now = \&time;
  
  sub timer_interval_cb {
     my $id = shift; # add_timeout kills @_, so we have to make a copy :(
     $id->[0] = FLTK::add_timeout $id->[1], \&timer_interval_cb, $id;
     &{ $id->[2] }
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     my $cb = $arg{cb};
  
     if ($arg{interval}) {
        my $id = [undef, $arg{interval}, $cb];
  
        $id->[0] = FLTK::add_timeout $arg{after}, \&timer_interval_cb, $id;
  
        return bless $id, "AnyEvent::Impl::FLTK::timer"
     } else {
        # non-repeating timers can be done very efficiently
        # also, FLTK doesn't like callable objects
        return FLTK::add_timeout $arg{after}, sub { &$cb }
     }
  }
  
  sub AnyEvent::Impl::FLTK::timer::DESTROY {
     undef $_[0][0];
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     # only one watcher/fd :(
  
     my $cb = $arg{cb};
     my ($fh, $ev) = AnyEvent::_dupfh $arg{poll}, $arg{fh},
        FLTK::READ,
        FLTK::WRITE | (AnyEvent::WIN32 ? FLTK::EXCEPT : 0);
  
     # fltk hardcodes poll constants and aliases EXCEPT with POLLERR,
     # which is grossly wrong, but likely it doesn't use poll on windows.
     FLTK::add_fd $fh, $ev, sub { &$cb }
  }
  
  # use signal and child emulation - fltk has no facilities for that
  
  # fltk idle watchers are like EV::check watchers, and fltk check watchers
  # are like EV::prepare watchers. both are called when the loop is busy,
  # so we have to use idle watcher emulation.
  
  sub _poll {
     FLTK::wait;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     FLTK::wait until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   FLTK::run;
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<FLTK>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_FLTK

$fatpacked{"AnyEvent/Impl/Glib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_GLIB';
  =head1 NAME
  
  AnyEvent::Impl::Glib - AnyEvent adaptor for Glib
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Glib;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Glib work with AnyEvent except by loading Glib before
  creating the first AnyEvent watcher.
  
  Glib is probably the most inefficient event loop that has ever seen the
  light of the world: Glib not only scans all its watchers (really, ALL of
  them, whether I/O-related, timer-related or what not) during each loop
  iteration, it also does so multiple times and rebuilds the poll list for
  the kernel each time again, dynamically even. Newer versions of libglib
  fortunately do not call malloc/free on every single watcher invocation,
  though.
  
  Glib also enforces certain undocumented behaviours, for example, you
  cannot always remove active child watchers, and the conditions on when
  it is valid to do so are not documented. Of course, if you get it wrong,
  you get "GLib-CRITICAL" messages. This makes it extremely hard to write
  "correct" glib programs, as you have to study the source code to get it
  right, and hope future versions don't change any internals.
  
  AnyEvent implements the necessary workarounds, at a small performance
  cost.
  
  On the positive side, and most importantly, when it works, Glib generally
  works correctly, no quarrels there.
  
  If you create many watchers (as in: more than two), you might consider one
  of the L<Glib::EV>, L<EV::Glib> or L<Glib::Event> modules that map Glib to
  other, more efficient, event loops.
  
  This module uses the default Glib main context for all its watchers.
  
  =cut
  
  package AnyEvent::Impl::Glib;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Glib 1.210 (); # (stable 1.220 2009, also Glib 2.4+ required, 2004)
  
  our $mainloop = Glib::MainContext->default;
  
  my %io_cond = (
     r => ["in" , "hup"],
     w => ["out", "hup"],
  );
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = add_watch Glib::IO
        $fd,
        $io_cond{$arg{poll}},
        sub { &$cb; 1 };
  
     bless \\$source, $class
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb   = $arg{cb};
     my $ival = $arg{interval} * 1000;
  
     my $source; $source = add Glib::Timeout $arg{after} < 0 ? 0 : $arg{after} * 1000,
        $ival ? sub {
                  remove Glib::Source $source;
                  $source = add Glib::Timeout $ival, sub { &$cb; 1 };
                  &$cb;
                  1 # already removed, should be a nop
                }
              : sub {
                 # due to the braindamaged libglib API (it manages
                 # removed-but-active watchers internally, but forces
                 # users to # manage the same externally as well),
                 # we have to go through these contortions.
                 remove Glib::Source $source;
                 undef $source;
                 &$cb;
                 1 # already removed, should be a nop
              };
  
     bless \\$source, $class
  }
  
  sub idle {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $source = add Glib::Idle sub { &$cb; 1 };
  
     bless \\$source, $class
  }
  
  sub DESTROY {
     remove Glib::Source $${$_[0]}
        if defined $${$_[0]};
  }
  
  our %pid_w;
  our %pid_cb;
  
  sub child {
     my ($class, %arg) = @_;
  
     $arg{pid} > 0
        or Carp::croak "Glib does not support watching for all pids (pid == 0) as attempted";
  
     my $pid = $arg{pid};
     my $cb  = $arg{cb};
  
     $pid_cb{$pid}{$cb+0} = $cb;
  
     $pid_w{$pid} ||= Glib::Child->watch_add ($pid, sub {
        # the unbelievably braindamaged glib api ignores the return
        # value and always removes the watcher (this is of course
        # undocumented), so we need to go through these contortions to
        # work around this, here and in DESTROY.
        undef $pid_w{$pid};
  
        $_->($_[0], $_[1])
           for values %{ $pid_cb{$pid} };
  
        1 # gets ignored
     });
  
     bless [$pid, $cb+0], "AnyEvent::Impl::Glib::child"
  }
  
  sub AnyEvent::Impl::Glib::child::DESTROY {
     my ($pid, $icb) = @{ $_[0] };
  
     delete $pid_cb{$pid}{$icb};
     unless (%{ $pid_cb{$pid} }) {
        delete $pid_cb{$pid};
        my $source = delete $pid_w{$pid};
        remove Glib::Source if defined $source;
     }
  }
  
  #sub loop {
  #   # hackish, but we do not have a mainloop, just a maincontext
  #   $mainloop->iteration (1) while 1;
  #}
  
  sub _poll {
     $mainloop->iteration (1);
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     $mainloop->iteration (1) until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Glib>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_GLIB

$fatpacked{"AnyEvent/Impl/IOAsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IOASYNC';
  =head1 NAME
  
  AnyEvent::Impl::IOAsync - AnyEvent adaptor for IO::Async
  
  =head1 SYNOPSIS
  
    use AnyEvent;
    use IO::Async::Loop;
  
    # optionally set another event loop
    use AnyEvent::Impl::IOAsync;
    my $loop = new IO::Async::Loop;
    AnyEvent::Impl::IOAsync::set_loop $loop;
  
  =head1 DESCRIPTION
  
  This module provides support for IO::Async as AnyEvent backend. It supports
  I/O, timers, signals and child process watchers. Idle watchers are emulated.
  I/O watchers need to dup their fh because IO::Async only supports IO handles,
  not plain file descriptors.
  
  =head1 FUNCTIONS AND VARIABLES
  
  The only user-servicible part in this module is the C<set_loop> function
  and C<$LOOP> variable:
  
  =over 4
  
  =item AnyEvent::Impl::IOAsync::set_loop $new_loop
  
  Unfortunately, IO::Async has no concept of a default loop. Modules using
  IO::Async must be told by their caller which loop to use, which makes it
  impossible to transparently use IO::Async from a module.
  
  This module is no exception. It creates a new IO::Async::Loop object when
  it is loaded. This might not be the right loop object, though, and thus
  you can replace it by a call to this function with the loop object of your
  choice.
  
  Note that switching loops while watchers are already initialised can have
  unexpected effects, and is not supported unless you can live witht he
  consequences.
  
  =item $AnyEvent::Impl::IOAsync::LOOP
  
  This variable always contains the IO::Async::Loop object used by this
  AnyEvent backend. See above for more info.
  
  Storing the "default" loop makes this module a possible arbiter for other
  modules that want to use IO::Async transparently. It's advised to directly
  refer to this variable each time you want to use it, without making a
  local copy.
  
  =back
  
  =head1 PROBLEMS WITH IO::Async
  
  This section had a long list of problems and shortcomings that made it
  almost impossible to support L<IO::Async>. With version 0.33 of IO::Async,
  however, most of these have been fixed, so L<IO::Async> can now be used as
  easily as many other loops.
  
  There are a few remaining problems that require emulation or workarounds:
  
  =over 4
  
  =item No support for multiple watchers per event
  
  In most (all? documentation?) cases you cannot have multiple watchers
  for the same event (what's the point of having all these fancy notifier
  classes when you cannot have multiple notifiers for the same event? That's
  like only allowing one timer per second or so...).
  
  For I/O watchers, AnyEvent has to dup() every file handle, as IO::Async
  fails to support the same or different file handles pointing to the same
  fd (the good thing is that it is documented, but why not fix it instead?).
  
  =back
  
  Apart from these fatal flaws, there are a number of unpleasent properties
  that just need some mentioning:
  
  =over 4
  
  =item Confusing and misleading names
  
  Another rather negative point about this module family is its name,
  which is deeply confusing: Despite the "async" in the name, L<IO::Async>
  only does I<synchronous> I/O, there is nothing "asynchronous" about it
  whatsoever (when I first heard about it, I thought, "wow, a second async
  I/O module, what does it do compared to L<IO::AIO>", and was somehow set
  back when I learned that the only "async" aspect of it is the name).
  
  =item Inconsistent, incomplete and convoluted API
  
  Implementing AnyEvent's rather simple timers on top of IO::Async's timers
  was a nightmare (try implementing a timer with configurable interval and
  delay value...).
  
  The method naming is chaotic: C<watch_child> creates a child watcher,
  but C<watch_io> is an internal method; C<detach_signal> removes a signal
  watcher, but C<detach_child> forks a subprocess and so on).
  
  =item Unpleasant surprises on GNU/Linux
  
  When you develop your program on FreeBSD and run it on GNU/Linux, you
  might have unpleasant surprises, as IO::Async::Loop will by default use
  L<IO::Async::Loop::Epoll>, which is incompatible with C<fork>, so your
  network server will run into spurious and very hard to debug problems
  under heavy load, as IO::Async forks a lot of processes, e.g. for DNS
  resolution. It would be better if IO::Async would only load "safe"
  backends by default (or fix the epoll backend to work in the presence of
  fork, which admittedly is hard - EV does it for you, and also does not use
  unsafe backends by default).
  
  =back
  
  On the positive side, performance with IO::Async is quite good even in my
  very demanding eyes.
  
  =cut
  
  package AnyEvent::Impl::IOAsync;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Time::HiRes ();
  use Scalar::Util ();
  
  use IO::Async::Loop 0.33;
  
  our $LOOP = new IO::Async::Loop;
  
  sub set_loop($) {
     $LOOP = $_[0];
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
  
     my $id;
  
     if (my $ival = $arg{interval}) {
        my $ival_cb; $ival_cb = sub {
           $id = $LOOP->enqueue_timer (delay => $ival, code => $ival_cb);
           &$cb;
        };
        $id = $LOOP->enqueue_timer (delay => $arg{after}, code => $ival_cb);
  
        # we have to weaken afterwards, but when enqueue dies, we have a memleak.
        # still, we do anything for speed...
        Scalar::Util::weaken $ival_cb;
  
     } else {
        # IO::Async has problems with overloaded objects
        $id = $LOOP->enqueue_timer (delay => $arg{after}, code => sub {
           undef $id; # IO::Async <= 0.43 bug workaround
           &$cb;
        });
     }
  
     bless \\$id, "AnyEvent::Impl::IOAsync::timer"
  }
  
  sub AnyEvent::Impl::IOAsync::timer::DESTROY {
     # Need to be well-behaved during global destruction
     $LOOP->cancel_timer (${${$_[0]}})
        if defined ${${$_[0]}}; # IO::Async <= 0.43 bug workaround
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     # Ensure we have a real IO handle, and not just a UNIX fd integer
     my ($fh) = AnyEvent::_dupfh $arg{poll}, $arg{fh};
  
     my $event = $arg{poll} eq "r" ? "on_read_ready" : "on_write_ready";
  
     $LOOP->watch_io (
        handle => $fh,
        $event => $arg{cb},
     );
  
     bless [$fh, $event], "AnyEvent::Impl::IOAsync::io"
  }
  
  sub AnyEvent::Impl::IOAsync::io::DESTROY {
     $LOOP->unwatch_io (
        handle => $_[0][0],
        $_[0][1] => 1,
     );
  }
  
  sub signal {
     my ($class, %arg) = @_;
  
     my $signal = $arg{signal};
  
     my $id = $LOOP->attach_signal ($arg{signal}, $arg{cb});
     bless [$signal, $id], "AnyEvent::Impl::IOAsync::signal"
  }
  
  sub AnyEvent::Impl::IOAsync::signal::DESTROY {
     $LOOP->detach_signal (@{ $_[0] });
  }
  
  our %pid_cb;
  
  sub child {
     my ($class, %arg) = @_;
  
     my $pid = $arg{pid};
  
     $LOOP->watch_child ($pid, $arg{cb});
     bless [$pid], "AnyEvent::Impl::IOAsync::child"
  }
  
  sub child {
     my ($class, %arg) = @_;
  
     my $pid = $arg{pid};
     my $cb  = $arg{cb};
  
     unless (%{ $pid_cb{$pid} }) {
        $LOOP->watch_child ($pid, sub {
           $_->($_[0], $_[1])
              for values %{ $pid_cb{$pid} };
        });
     }
  
     $pid_cb{$pid}{$cb+0} = $cb;
  
     bless [$pid, $cb+0], "AnyEvent::Impl::IOAsync::child"
  }
  
  sub AnyEvent::Impl::IOAsync::child::DESTROY {
     my ($pid, $icb) = @{ $_[0] };
  
     delete $pid_cb{$pid}{$icb};
  
     unless (%{ $pid_cb{$pid} }) {
        delete $pid_cb{$pid};
        $LOOP->unwatch_child ($pid);
     }
  }
  
  #sub loop {
  #   $LOOP->loop_forever;
  #}
  
  sub _poll {
     $LOOP->loop_once;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     $LOOP->loop_once until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<IO::Async>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
   Paul Evans <leonerd@leonerd.org.uk>
   Rewrote the backend for IO::Async version 0.33.
  
  =cut
  
  1
  
ANYEVENT_IMPL_IOASYNC

$fatpacked{"AnyEvent/Impl/Irssi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IRSSI';
  =head1 NAME
  
  AnyEvent::Impl::Irssi - AnyEvent adaptor for Irssi
  
  =head1 SYNOPSIS
  
     use AnyEvent;
    
     # this module gets loaded automatically when running under irssi
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Irssi scripts work with AnyEvent.
  
  Limitations of this backend and implementation details:
  
  =over 4
  
  =item * This backend does not support blocking waits.
  
  That means you must set a callback on any condvars, or otherwise make sure
  to never call C<recv> on a condvar that hasn't been signalled yet.
  
  =item * Child exits will be handled by AnyEvent.
  
  AnyEvent will take over child handling, as Irssi only polls for children
  once/second and cannot handle unspecific child watchers.
  
  This I<should> have no negative effect, as AnyEvent will emit a pidwait
  signal just like irssi itself would.
  
  =item * Artificial timer delays.
  
  Irssi artificially enforces timers to have at least a 10ms delay (by
  croaking, even).
  
  This means that some applications will be limited to a rate of 100Hz (for
  example, L<Coro::AnyEvent> thread scheduling).
  
  =item * Irssi leaks memory like hell.
  
  Yeah.
  
  =back
  
  Apart from that, documentation is notoriously wrong (e.g. file handles
  are not supported by C<input_add>, contrary to documentation), hooking
  into irssi has to be done in... weird... ways, but otherwise, Irssi is
  surprisingly full-featured (for basically being a hack).
  
  =cut
  
  package AnyEvent::Impl::Irssi;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Carp ();
  use Irssi ();
  
  our @ISA;
  
  # irssi works only from certain namespaces, so we
  # create one and use it.
  sub init {
     my $pkg = caller;
  
     push @ISA, $pkg;
  
     local $/;
     eval "package $pkg; " . <DATA>;
     print "AnyEvent::Impl::Irssi fatal compilation error: $@" if $@;
  
     close DATA;
  }
  
  Irssi::command "/script exec -permanent AnyEvent::Impl::Irssi::init 'AnyEvent adaptor'";
  
  1;
  
  __DATA__
  
  BEGIN { AnyEvent::common_sense }
  use base "AnyEvent::Base";
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = Irssi::input_add
        $fd,
        $arg{poll} eq "r" ? Irssi::INPUT_READ : Irssi::INPUT_WRITE,
        $cb,
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::io"
  }
  
  sub AnyEvent::Impl::Irssi::io::DESTROY {
     Irssi::input_remove $${$_[0]};
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb    = $arg{cb};
     my $ival  = $arg{interval} * 1000;
     my $after = $arg{after} * 1000;
  
     my $source; $source = Irssi::timeout_add_once $after > 10 ? $after : 10,
        ($ival ? sub {
                   $source = Irssi::timeout_add $ival > 10 ? $ival : 10, $cb, undef;
                   &$cb;
                   0
                 }
               : $cb),
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::timer"
  }
  
  sub AnyEvent::Impl::Irssi::timer::DESTROY {
     Irssi::timeout_remove $${$_[0]};
  }
  
  my $_pidwait = sub {
     my ($rpid, $rstatus) = @_;
  
     AnyEvent::Base->_emit_childstatus ($rpid, $rstatus);
  };
  
  Irssi::signal_add pidwait => $_pidwait;
  
  sub _emit_childstatus {
     my ($self, $rpid, $rstatus) = @_;
     $self->SUPER::_emit_childstatus ($rpid, $rstatus);
  
     Irssi::signal_remove pidwait => $_pidwait;
     Irssi::signal_emit   pidwait => $rpid+0, $rstatus+0;
     Irssi::signal_add    pidwait => $_pidwait;
  }
  
  #sub loop {
  #   Carp::croak "Irssi does not support blocking waits";
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Irssi>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_IRSSI

$fatpacked{"AnyEvent/Impl/POE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_POE';
  =head1 NAME
  
  AnyEvent::Impl::POE - AnyEvent adaptor for POE
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use POE;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make POE work with AnyEvent except by loading POE before
  creating the first AnyEvent watcher. There are some cases where POE will
  issue spurious (and non-suppressible) warnings. These can be avoided by
  loading AnyEvent::Impl::POE before loading any other modules using POE and
  AnyEvent, i.e. in your main program.
  
  AnyEvent::Impl::POE will output some spurious message how to work around
  POE's spurious messages when it detects these cases.
  
  Unfortunately, POE isn't generic enough to implement a fully working
  AnyEvent backend: POE is too badly designed, too badly documented and too
  badly implemented.
  
  Here are the details, and what it means to you if you want to be
  interoperable with POE:
  
  =over 4
  
  =item Weird messages
  
  If you only use C<run_one_timeslice> (as AnyEvent has to for its
  condition variables), POE will print an ugly, unsuppressible, message at
  program exit:
  
     Sessions were started, but POE::Kernel's run() method was never...
  
  The message is correct, the question is why POE prints it in the first
  place in a correct program (this is not a singular case though).
  
  AnyEvent consequently patches the POE kernel so it thinks it already
  ran. Other workarounds, even the one cited in the POE documentation
  itself, have serious side effects, such as throwing away events.
  
  The author of POE verified that this is indeed true, and has no plans to
  change this.
  
  POE has other weird messages, and sometimes weird behaviour, for example,
  it doesn't support overloaded code references as callbacks for no apparent
  reason.
  
  =item One POE session per Event
  
  AnyEvent has to create one POE::Session per event watcher, which is
  immensely slow and makes watchers very large. The reason for this is
  lacking lifetime management (mostly undocumented, too). Without one
  session/watcher it is not possible to easily keep the kernel from running
  endlessly.
  
  This is not just a problem with the way AnyEvent has to interact with
  POE, but is a principal issue with POEs lifetime management (namely
  that stopping the kernel stops sessions, but AnyEvent has no control
  over who and when the kernel starts or stops w.r.t. AnyEvent watcher
  creation/destruction).
  
  From benchmark data it is not clear that session creation is that costly,
  though - the real inefficiencies with POE seem to come from other sources,
  such as event handling.
  
  =item One watcher per fd/event combo
  
  POE, of course, suffers from the same bug as Tk and some other badly
  designed event models in that it doesn't support multiple watchers per
  fd/poll combo. The workaround is the same as with Tk: AnyEvent::Impl::POE
  creates a separate file descriptor to hand to POE, which isn't fast and
  certainly not nice to your resources.
  
  Of course, without the workaround, POE also prints ugly messages again
  that say the program *might* be buggy.
  
  While this is not good to performance, at least regarding speed, with a
  modern Linux kernel, the overhead is actually quite small.
  
  =item Timing deficiencies
  
  POE manages to not have a function that returns the current time. This is
  extremely problematic, as POE can use different time functions, which can
  differ by more than a second - and user code is left guessing which one is
  used.
  
  In addition, most timer functions in POE want an absolute timestamp, which
  is hard to create if all you have is a relative time and no function to
  return the "current time".
  
  And of course POE doesn't handle time jumps at all (not even when using
  an event loop that happens to do that, such as L<EV>, as it does its own
  unoptimised timer management).
  
  AnyEvent works around the unavailability of the current time using
  relative timers exclusively, in the hope that POE gets it right at least
  internally.
  
  =item Lack of defined event ordering
  
  POE cannot guarantee the order of callback invocation for timers, and
  usually gets it wrong. That is, if you have two timers, one timing out
  after another (all else being equal), the callbacks might be called in
  reverse order.
  
  How one manages to even implement stuff that way escapes me.
  
  =item Child watchers
  
  POE offers child watchers - which is a laudable thing, as few event loops
  do. Unfortunately, they cannot even implement AnyEvent's simple child
  watchers: they are not generic enough (the POE implementation isn't even
  generic enough to let properly designed back-end use their native child
  watcher instead - it insist on doing it itself the broken way).
  
  Unfortunately, POE's child handling is inherently racy: if the child exits
  before the handler is created (because e.g. it crashes or simply is quick
  about it), then current versions of POE (1.352) will I<never> invoke the
  child watcher, and there is nothing that can be done about it. Older
  versions of POE only delayed in this case. The reason is that POE first
  checks if the child has already exited, and I<then> installs the signal
  handler - aa classical race.
  
  Your only hope is for the fork'ed process to not exit too quickly, in
  which case everything happens to work.
  
  Of course, whenever POE reaps an unrelated child it will also output a
  message for it that you cannot suppress (which shouldn't be too surprising
  at this point). Very professional.
  
  As a workaround, AnyEvent::Impl::POE will take advantage of undocumented
  behaviour in POE::Kernel to catch the status of all child processes, but
  it cannot guarantee delivery.
  
  How one manages to have such a glaring bug in an event loop after ten
  years of development escapes me.
  
  (There are more annoying bugs, for example, POE runs C<waitpid>
  unconditionally at finaliser time, so your program will hang until all
  child processes have exited.)
  
  =item Documentation quality
  
  At the time of this writing, POE was in its tenth year. Still, its
  documentation is extremely lacking, making it impossible to implement
  stuff as trivial as AnyEvent watchers without having to resort to
  undocumented behaviour or features.
  
  For example, the POE::Kernel manpage has nine occurrences of the word TODO
  with an explanation of whats missing. In general, the POE man pages are
  littered with comments like "section not yet written".
  
  Some other gems:
  
     This allows many object methods to also be package methods.
  
  This is nice, but since it doesn't document I<which> methods these are,
  this is utterly useless information.
  
     Terminal signals will kill sessions if they are not handled by a
     "sig_handled"() call. The OS signals that usually kill or dump a
     process are considered terminal in POE, but they never trigger a
     coredump. These are: HUP, INT, QUIT and TERM.
  
  Although AnyEvent calls C<sig_handled>, removing it has no apparent
  effects on POE handling SIGINT.
  
     refcount_increment SESSION_ID, COUNTER_NAME
  
  Nowhere is explained which COUNTER_NAMEs are valid and which aren't - not
  all scalars (or even strings) are valid counter names. Take your guess,
  failure is of course completely silent. I found this out the hard way, as
  the first name I came up with was silently ignored.
  
     get_next_event_time() returns the time the next event is due, in a form
     compatible with the UNIX time() function.
  
  And surely, one would hope that POE supports sub-second accuracy as
  documented elsewhere, unlike the explanation above implies. Yet:
  
     POE::Kernel timers support subsecond accuracy, but dont expect too
     much here. Perl is not the right language for realtime programming.
  
  ... of course, Perl is not the right language to expect sub-second
  accuracy - the manpage author must hate Perl to spread so much FUD in
  so little space. The Deliantra game server logs with 100s-accuracy
  because Perl is fast enough to require this, and is still able to deliver
  map updates with little jitter at exactly the right time. It does not,
  however, use POE.
  
     Furthermore, since the Kernel keeps track of everything sessions do, it
     knows when a session has run out of tasks to perform.
  
  This is impossible - how does the kernel know that a session is no longer
  watching for some (external) event (e.g. by some other session)? It
  cannot, and therefore this is wrong - but you would be hard pressed to
  find out how to work around this and tell the kernel manually about such
  events.
  
  It gets worse, though - the notion of "task" or "resource", although used
  throughout the documentation, is not defined in a usable way. For example,
  waiting for a timeout is considered to be a task, waiting for a signal is
  not (a session that only waits for a signal is considered finished and
  gets removed). The user is left guessing when waiting for an event counts
  as task and when not (in fact, the issue with signals is mentioned in
  passing in a section about child watchers and directly contradicts earlier
  parts in that document).
  
  One could go on endlessly - ten years, no usable documentation.
  
  It is likely that differences between documentation, or the one or two
  things I had to guess, cause unanticipated problems with this adaptor.
  
  =item Fragile and inconsistent API
  
  The POE API is extremely inconsistent - sometimes you have to pass a
  session argument, sometimes it gets ignored, sometimes a session-specific
  method must not use a session argument.
  
  Error handling is sub-standard as well: even for programming mistakes,
  POE does not C<croak> but, in most cases, just sets C<$!> or simply does
  nothing at all, leading to fragile programs.
  
  Sometimes registering a handler uses the "eventname, parameter" ordering
  (timeouts), sometimes it is "parameter, eventname" (signals). There is
  little consistency overall.
  
  =item Lack of knowledge
  
     The IO::Poll event loop provides an alternative that theoretically
     scales better than select().
  
  The IO::Poll "event loop" (who in his right mind would call that an event
  loop) of course scales about identically (sometimes it is a bit faster,
  sometimes a bit slower) to select in theory, and also in practise, of
  course, as both are O(n) in the number of file descriptors, which is
  rather bad.
  
  This is just one place where it gets obvious how little the author of the
  POE manpage understands.
  
  =item No idle events
  
  The POE-recommended workaround to this is apparently to use
  C<fork>. Consequently, idle watchers will have to be emulated by AnyEvent.
  
  =item Questionable maintainer behaviour
  
  The author of POE is known to fabricate statements and post these to
  public mailinglists - apparently, spreading FUD about competing (in his
  eyes) projects or their maintainers is acceptable to him.
  
  This has (I believe) zero effects on the quality or usefulness of his
  code, but it does completely undermine his trustworthyness - so don't
  blindly believe anything he says, he might have just made it up to suit
  his needs (benchmark results, the names of my ten wifes, the length of my
  penis, etc. etc.). When in doubt, double-check - not just him, anybody
  actually.
  
  Example: L<http://www.nntp.perl.org/group/perl.perl5.porters/2012/01/msg182141.html>.
  I challenged him in that thread to provide evidence for his statement by giving at
  least two examples, but of course since he just made it up, he couldn't provide any evidence.
  
  =back
  
  On the good side, AnyEvent allows you to write your modules in a 100%
  POE-compatible way (bug-for-bug compatible even), without forcing your
  module to use POE - it is still open to better event models, of which
  there are plenty.
  
  Oh, and one other positive thing:
  
     RUNNING_IN_HELL
  
  POE knows about the nature of the beast!
  
  =cut
  
  package AnyEvent::Impl::POE;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use POE;
  
  # suppress an idiotic warning inside POE
  ${ POE::Kernel->new->[POE::Kernel::KR_RUN] } |= POE::Kernel::KR_RUN_CALLED;
  
  sub io {
     my ($class, %arg) = @_;
  
     # POE itself might do the right thing, but some POE backends don't,
     # so do the safe thing, it's not as if this will slow us down
     # any further *g*
     my ($fh, $pee) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, "select_read", "select_write";
  
     my $cb = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
  
     my $session = POE::Session->create (
        inline_states => {
           _start => sub { $_[KERNEL]->$pee ($fh => "ready") },
           ready  => sub { $cb->() },
           stop   => sub { $_[KERNEL]->$pee ($fh) },
        },
     );
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     my $after = delete $arg{after};
     my $ival  = delete $arg{interval};
     my $cb    = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
  
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              $_[KERNEL]->delay_set (timeout => $after);
           },
           timeout => $ival ? sub { $_[KERNEL]->delay_set (timeout => $ival); $cb->() } : $cb,
           stop => sub {
              $_[KERNEL]->alarm_remove_all;
           },
        },
     );
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub signal {
     my ($class, %arg) = @_;
     my $signal = AnyEvent::Base::sig2name delete $arg{signal};
     my $cb     = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              # I suck - POE
           },
           start => sub {
              $_[KERNEL]->sig ($signal => "catch");
              $_[KERNEL]->refcount_increment ($_[SESSION]->ID => "poe");
           },
           catch => sub {
              $cb->();
              $_[KERNEL]->sig_handled;
           },
           stop => sub {
              $_[KERNEL]->refcount_decrement ($_[SESSION]->ID => "poe");
              $_[KERNEL]->sig ($signal);
           },
        },
     );
     POE::Kernel->call ($session, "start");
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub child {
     my ($class, %arg) = @_;
     my $pid = delete $arg{pid};
     my $cb  = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              # I suck - POE
           },
           start => sub {
              $_[KERNEL]->sig (CHLD => "child");
              $_[KERNEL]->refcount_increment ($_[SESSION]->ID => "poe");
           },
           child => sub {
              my ($rpid, $status) = @_[ARG1, ARG2];
  
              $cb->($rpid, $status) if $rpid == $pid || $pid == 0;
           },
           stop => sub {
              $_[KERNEL]->refcount_decrement ($_[SESSION]->ID => "poe");
              $_[KERNEL]->sig ("CHLD");
           },
        },
     );
     # newer POE versions lose signals unless we call ->sig early.
     POE::Kernel->call ($session, "start");
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub DESTROY {
     POE::Kernel->call (${${$_[0]}}, "stop");
  }
  
  #sub loop {
  #   POE::Kernel->run;
  #}
  
  sub _poll {
     POE::Kernel->loop_do_timeslice;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     POE::Kernel->loop_do_timeslice until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<POE>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_POE

$fatpacked{"AnyEvent/Impl/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_PERL';
  =head1 NAME
  
  AnyEvent::Impl::Perl - AnyEvent adaptor for AnyEvent's pure perl AnyEvent::Loop
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use AnyEvent::Loop;
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent in case no other
  event loop could be found or loaded.
  
  If you want to use this module instead of autoloading another event loop
  you can simply load L<AnyEvent::Loop> before creating the first watcher.
  
  Naturally, it supports all features of AnyEvent.
  
  See L<AnyEvent::Loop> for more details on performance characteristics.
  
  =cut
  
  package AnyEvent::Impl::Perl;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Loop;
  
  our $VERSION = $AnyEvent::VERSION;
  
  # time() is provided via AnyEvent::Base
  
  *AE::now        = \&AnyEvent::Loop::now;
  *AE::now_update = \&AnyEvent::Loop::now_update;
  *AE::io         = \&AnyEvent::Loop::io;
  *AE::timer      = \&AnyEvent::Loop::timer;
  *AE::idle       = \&AnyEvent::Loop::idle;
  *_poll          = \&AnyEvent::Loop::one_event;
  *loop           = \&AnyEvent::Loop::run; # compatibility with AnyEvent < 6.0
  *now_update     = \&AnyEvent::Loop::now_update;
  
  sub now { $AnyEvent::Loop::NOW }
  
  sub AnyEvent::CondVar::Base::_wait {
     AnyEvent::Loop::one_event until exists $_[0]{_ae_sent};
  }
  
  sub io {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::io $arg{fh}, $arg{poll} eq "w", $arg{cb}
  }
  
  sub timer {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::timer $arg{after}, $arg{interval}, $arg{cb}
  }
  
  sub idle {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::idle $arg{cb}
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_PERL

$fatpacked{"AnyEvent/Impl/Qt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_QT';
  =head1 NAME
  
  AnyEvent::Impl::Qt - AnyEvent adaptor for Qt
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Qt;
    
     my $app = Qt::Application \@ARGV; # REQUIRED!
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have
  to do anything to make Qt work with AnyEvent except by loading Qt
  before creating the first AnyEvent watcher I<and instantiating the
  Qt::Application object>. Failure to do so will result in segfaults,
  which is why this model doesn't work as a default model and will not be
  autoprobed (but it will be autodetected when the main program uses Qt).
  
  Qt suffers from the same limitations as Event::Lib and Tk, the workaround
  is also the same (duplicating file descriptors).
  
  Qt doesn't support idle events, so they are being emulated.
  
  Avoid Qt if you can.
  
  =cut
  
  package AnyEvent::Impl::Qt::Io;
  
  use Qt;
  use Qt::isa qw(Qt::SocketNotifier); # Socket? what where they smoking
  use Qt::slots cb => [];
  
  sub NEW {
     my ($class, $fh, $mode, $cb) = @_;
     shift->SUPER::NEW (fileno $fh, $mode);
     this->{fh} = $fh;
     this->{cb} = $cb;
     this->connect (this, SIGNAL "activated(int)", SLOT "cb()");
  }
  
  sub cb {
     this->setEnabled (0); # required according to the docs. heavy smoking required.
     this->{cb}->();
     this->setEnabled (1);
  }
  
  package AnyEvent::Impl::Qt::Timer;
  
  use Qt;
  use Qt::isa qw(Qt::Timer);
  use Qt::slots cb => [];
  
  # having to go through these contortions just to get a timer event is
  # considered an advantage over other gui toolkits how?
  
  sub NEW {
     my ($class, $after, $interval, $cb) = @_;
     shift->SUPER::NEW ();
     this->{interval} = $interval;
     this->{cb}       = $cb;
     this->connect (this, SIGNAL "timeout()", SLOT "cb()");
     this->start ($after, 1);
  }
  
  sub cb {
     this->start (this->{interval}, 1) if defined this->{interval};
     this->{cb}->();
  }
  
  package AnyEvent::Impl::Qt;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Qt;
  
  use AnyEvent::Impl::Qt::Timer;
  use AnyEvent::Impl::Qt::Io;
  
  our $app = Qt::Application \@ARGV; # REQUIRED!
  
  sub io {
     my ($class, %arg) = @_;
  
     # work around these bugs in Qt:
     # - adding a callback might destroy other callbacks
     # - only one callback per fd/poll combination
     my ($fh, $qt) = AnyEvent::_dupfh $arg{poll}, $arg{fh},
                        Qt::SocketNotifier::Read (), Qt::SocketNotifier::Write ();
  
     AnyEvent::Impl::Qt::Io $fh, $qt, $arg{cb}
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     # old Qt treats 0 timeout as "idle"
     AnyEvent::Impl::Qt::Timer
        $arg{after} * 1000 || 1,
        $arg{interval} ? $arg{interval} * 1000 || 1 : undef,
        $arg{cb}
  }
  
  # newer Qt have no idle mode for timers anymore...
  #sub idle {
  #   my ($class, %arg) = @_;
  #   
  #   AnyEvent::Impl::Qt::Timer 0, 0, $arg{cb}
  #}
  
  #sub loop {
  #   Qt::app->exec;
  #}
  
  sub _poll {
     Qt::app->processOneEvent;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Qt::app->processOneEvent until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Qt>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_QT

$fatpacked{"AnyEvent/Impl/Tk.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_TK';
  =head1 NAME
  
  AnyEvent::Impl::Tk - AnyEvent adaptor for Tk
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Tk;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Tk work with AnyEvent except by loading Tk before
  creating the first AnyEvent watcher.
  
  Tk is buggy. Tk is extremely buggy. Tk is so unbelievably buggy that
  for each bug reported and fixed, you get one new bug followed by
  reintroduction of the old bug in a later revision. It is also basically
  unmaintained: the maintainers are not even interested in improving
  the situation - reporting bugs is considered rude, and fixing bugs is
  considered changing holy code, so it's apparently better to leave it
  broken.
  
  I regularly run out of words to describe how bad it really is.
  
  To work around some of the many, many bugs in Tk that don't get fixed,
  this adaptor dup()'s all filehandles that get passed into its I/O
  watchers, so if you register a read and a write watcher for one fh,
  AnyEvent will create two additional file descriptors (and handles).
  
  This creates a high overhead and is slow, but seems to work around most
  known bugs in L<Tk::fileevent> on 32 bit architectures (Tk seems to be
  terminally broken on 64 bit, do not expect more than 10 or so watchers to
  work on 64 bit machines).
  
  Do not expect these workarounds to avoid segfaults and crashes inside Tk.
  
  Note also that Tk event ids wrap around after 2**32 or so events, which on
  my machine can happen within less than 12 hours, after which Tk will stomp
  on random other events and kill them. So don't run Tk programs for more
  than an hour or so.
  
  To be able to access the Tk event loop, this module creates a main
  window and withdraws it immediately. This might cause flickering on some
  platforms, but Tk perversely requires a window to be able to wait for file
  handle readyness notifications. This window is always created (in this
  version of AnyEvent) and can be accessed as C<$AnyEvent::Impl::Tk::mw>.
  
  =cut
  
  package AnyEvent::Impl::Tk;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Tk ();
  
  our $mw = new MainWindow -title => "AnyEvent Dummy Window";
  $mw->withdraw;
  
  END { undef $mw }
  
  sub io {
     my (undef, %arg) = @_;
  
     # work around these bugs in Tk:
     # - removing a callback will destroy other callbacks
     # - removing a callback might crash
     # - adding a callback might destroy other callbacks
     # - only one callback per fh
     # - only one callback per fh/poll combination
     my ($fh, $tk) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, "readable", "writable";
  
     $mw->fileevent ($fh, $tk => $arg{cb});
  
     bless [$fh, $tk], "AnyEvent::Impl::Tk::io"
  }
  
  sub AnyEvent::Impl::Tk::io::DESTROY {
     my ($fh, $tk) = @{$_[0]};
  
     # work around another bug: watchers don't get removed when
     # the fh is closed, contrary to documentation. also, trying
     # to unregister a read callback will make it impossible
     # to remove the write callback.
     # if your program segfaults here then you need to destroy
     # your watchers before program exit. sorry, no way around
     # that.
     $mw->fileevent ($fh, $tk => "");
  }
  
  sub timer {
     my (undef, %arg) = @_;
     
     my $after = $arg{after} < 0 ? 0 : $arg{after} * 1000;
     my $cb = $arg{cb};
     my $id;
  
     if ($arg{interval}) {
        my $ival = $arg{interval} * 1000;
        my $rcb = sub {
           $id = Tk::after $mw, $ival, [$_[0], $_[0]];
           &$cb;
        };
        $id = Tk::after $mw, $after, [$rcb, $rcb];
     } else {
        # tk blesses $cb, thus the extra indirection
        $id = Tk::after $mw, $after, sub { &$cb };
     }
  
     bless \\$id, "AnyEvent::Impl::Tk::after"
  }
  
  sub idle {
     my (undef, %arg) = @_;
  
     my $cb = $arg{cb};
     my $id;
     my $rcb = sub {
        # in their endless stupidity, they decided to give repeating idle watchers
        # strictly higher priority than timers :/
        $id = Tk::after $mw, 0 => [sub {
           $id = Tk::after $mw, idle => [$_[0], $_[0]];
        }, $_[0]];
        &$cb;
     };
  
     $id = Tk::after $mw, idle => [$rcb, $rcb];
     bless \\$id, "AnyEvent::Impl::Tk::after"
  }
  
  sub AnyEvent::Impl::Tk::after::DESTROY {
     Tk::after $mw, cancel => $${$_[0]};
  }
  
  #sub loop {
  #   Tk::MainLoop;
  #}
  
  sub _poll {
     Tk::DoOneEvent (0);
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Tk::DoOneEvent (0) until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Tk>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_TK

$fatpacked{"AnyEvent/Impl/UV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_UV';
  =head1 NAME
  
  AnyEvent::Impl::UV - AnyEvent adaptor for UV
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use UV;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make UV work with AnyEvent except by loading UV before
  creating the first AnyEvent watcher.
  
  =cut
  
  package AnyEvent::Impl::UV;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use UV 0.24;
  use Scalar::Util qw(weaken);
  
  sub warnlog {
     my $err = UV::last_error;
  
     AnyEvent::log warn => "returned $_[0]: "
                           . UV::err_name ($err) . "($err): "
                           . UV::strerror ($err);
  
     @_
  }
  
  # https://github.com/joyent/libuv/issues/680
  # https://github.com/joyent/libuv/blob/dc1ea27c736f0d21c7160c790bcd1b113d20abd9/include/uv.h#L1277
  my %io_watchers;
  
  sub io_watcher_cb {
     my $slaves = shift;
     my (undef, $events) = @_;
     return unless defined $slaves;
  
     foreach my $entry (keys %$slaves) {
        my $slave = $slaves->{$entry};
        $slave->{cb}(@_) if $slave->{mode} & $events;
     }
  }
  
  sub AnyEvent::Impl::UV::io_slave::new {
     bless { parent => $_[1] }, $_[0]
  }
  
  sub AnyEvent::Impl::UV::io_slave::DESTROY {
     my $self   = $_[0];
     my $master = $self->{parent};
  
     delete $master->{slaves}{$self};
     if (keys %{$master->{slaves}} == 0) {
        if (defined $master->{w}) {
           my $rc = UV::poll_stop $master->{w};
           warnlog $rc if $rc;
        }
        delete $io_watchers{$master->{fd}};
        return;
     }
  
     my $mode = 0;
     foreach my $entry (keys %{$master->{slaves}}) {
        $mode |= $master->{slaves}{$entry}{mode};
     }
  
     if ($master->{mode} != $mode) {
        $master->{mode} = $mode;
        my $rc = UV::poll_start $master->{w}, $master->{mode}, sub {
           io_watcher_cb $master->{slaves}, @_;
        };
        warnlog $rc if $rc;
     }
  }
  
  sub io {
     my ($class, %arg) = @_;
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $master = $io_watchers{$fd} ||= { fd => $fd };
  
     unless (defined $master->{w}) {
        $master->{w} = UV::poll_init $fd;
        return warnlog $master->{w} unless defined $master->{w};
        $master->{slaves} = {};
     }
  
     my $slave = AnyEvent::Impl::UV::io_slave->new ($master);
     weaken ($master->{slaves}->{$slave} = $slave);
  
     $slave->{mode}  = $arg{poll} eq "r" ? UV::READABLE : UV::WRITABLE;
     $master->{mode} = 0 unless defined $master->{mode};
     $slave->{cb}    = $arg{cb};
  
     unless ($master->{mode} & $slave->{mode}) {
        $master->{mode} |= $slave->{mode};
        my $rc = UV::poll_start $master->{w}, $master->{mode}, sub {
           io_watcher_cb $master->{slaves}, @_;
        };
        warnlog $rc if $rc;
     }
  
     $slave
  }
  
  sub AnyEvent::Impl::UV::handle::new {
     my ($class, $w, $start, $stop, @args) = @_;
     return warnlog $w unless defined $w;
  
     my $rc = $start->($w, @args);
     warnlog $rc if $rc;
  
     bless { w => $w, stop => $stop }, $class
  }
  
  sub AnyEvent::Impl::UV::handle::DESTROY {
     my $h  = $_[0];
     return unless $h->{w};
     my $rc = $h->{stop}($h->{w});
     warnlog $rc if $rc;
     UV::close $h->{w};
  }
  
  sub idle {
     my ($class, %arg) = @_;
  
     AnyEvent::Impl::UV::handle->new (
        UV::timer_init,
        \&UV::idle_start,
        \&UV::idle_stop,
        $arg{cb}
     );
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     AnyEvent::Impl::UV::handle->new (
        UV::timer_init,
        \&UV::timer_start,
        \&UV::timer_stop,
        $arg{after} * 1000, $arg{interval} * 1000, $arg{cb}
     );
  }
  
  sub now { UV::now }
  
  sub _poll {
     UV::run UV::RUN_ONCE;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     UV::run UV::RUN_NOWAIT until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<UV>.
  
  =head1 AUTHOR
  
   Mike Lowell <mikedotlowell@gmail.com>
  
  =cut
  
  1
  
ANYEVENT_IMPL_UV

$fatpacked{"AnyEvent/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOG';
  =head1 NAME
  
  AnyEvent::Log - simple logging "framework"
  
  =head1 SYNOPSIS
  
  Simple uses:
  
     use AnyEvent;
  
     AE::log fatal => "No config found, cannot continue!"; # never returns
     AE::log alert => "The battery died!";
     AE::log crit  => "The battery is too hot!";
     AE::log error => "Division by zero attempted.";
     AE::log warn  => "Couldn't delete the file.";
     AE::log note  => "Attempted to create config, but config already exists.";
     AE::log info  => "File soandso successfully deleted.";
     AE::log debug => "the function returned 3";
     AE::log trace => "going to call function abc";
  
  Log level overview:
  
     LVL NAME      SYSLOG   PERL  NOTE
      1  fatal     emerg    exit  system unusable, aborts program!
      2  alert                    failure in primary system
      3  critical  crit           failure in backup system
      4  error     err      die   non-urgent program errors, a bug
      5  warn      warning        possible problem, not necessarily error
      6  note      notice         unusual conditions
      7  info                     normal messages, no action required
      8  debug                    debugging messages for development
      9  trace                    copious tracing output
  
  "Complex" uses (for speed sensitive code, e.g. trace/debug messages):
  
     use AnyEvent::Log;
  
     my $tracer = AnyEvent::Log::logger trace => \my $trace;
  
     $tracer->("i am here") if $trace;
     $tracer->(sub { "lots of data: " . Dumper $self }) if $trace;
  
  Configuration (also look at the EXAMPLES section):
  
     # set default logging level to suppress anything below "notice"
     # i.e. enable logging at "notice" or above - the default is to
     # to not log anything at all.
     $AnyEvent::Log::FILTER->level ("notice");
  
     # set logging for the current package to errors and higher only
     AnyEvent::Log::ctx->level ("error");
  
     # enable logging for the current package, regardless of global logging level
     AnyEvent::Log::ctx->attach ($AnyEvent::Log::LOG);
  
     # enable debug logging for module some::mod and enable logging by default
     (AnyEvent::Log::ctx "some::mod")->level ("debug");
     (AnyEvent::Log::ctx "some::mod")->attach ($AnyEvent::Log::LOG);
  
     # send all critical and higher priority messages to syslog,
     # regardless of (most) other settings
     $AnyEvent::Log::COLLECT->attach (new AnyEvent::Log::Ctx
        level         => "critical",
        log_to_syslog => "user",
     );
  
  =head1 DESCRIPTION
  
  This module implements a relatively simple "logging framework". It doesn't
  attempt to be "the" logging solution or even "a" logging solution for
  AnyEvent - AnyEvent simply creates logging messages internally, and this
  module more or less exposes the mechanism, with some extra spiff to allow
  using it from other modules as well.
  
  Remember that the default verbosity level is C<4> (C<error>), so only
  errors and more important messages will be logged, unless you set
  C<PERL_ANYEVENT_VERBOSE> to a higher number before starting your program
  (C<AE_VERBOSE=5> is recommended during development), or change the logging
  level at runtime with something like:
  
     use AnyEvent::Log;
     $AnyEvent::Log::FILTER->level ("info");
  
  The design goal behind this module was to keep it simple (and small),
  but make it powerful enough to be potentially useful for any module,
  and extensive enough for the most common tasks, such as logging to
  multiple targets, or being able to log into a database.
  
  The module is also usable before AnyEvent itself is initialised, in which
  case some of the functionality might be reduced.
  
  The amount of documentation might indicate otherwise, but the runtime part
  of the module is still just below 300 lines of code.
  
  =head1 LOGGING LEVELS
  
  Logging levels in this module range from C<1> (highest priority) to C<9>
  (lowest priority). Note that the lowest numerical value is the highest
  priority, so when this document says "higher priority" it means "lower
  numerical value".
  
  Instead of specifying levels by name you can also specify them by aliases:
  
     LVL NAME      SYSLOG   PERL  NOTE
      1  fatal     emerg    exit  system unusable, aborts program!
      2  alert                    failure in primary system
      3  critical  crit           failure in backup system
      4  error     err      die   non-urgent program errors, a bug
      5  warn      warning        possible problem, not necessarily error
      6  note      notice         unusual conditions
      7  info                     normal messages, no action required
      8  debug                    debugging messages for development
      9  trace                    copious tracing output
  
  As you can see, some logging levels have multiple aliases - the first one
  is the "official" name, the second one the "syslog" name (if it differs)
  and the third one the "perl" name, suggesting (only!) that you log C<die>
  messages at C<error> priority. The NOTE column tries to provide some
  rationale on how to chose a logging level.
  
  As a rough guideline, levels 1..3 are primarily meant for users of the
  program (admins, staff), and are the only ones logged to STDERR by
  default. Levels 4..6 are meant for users and developers alike, while
  levels 7..9 are usually meant for developers.
  
  You can normally only log a message once at highest priority level (C<1>,
  C<fatal>), because logging a fatal message will also quit the program - so
  use it sparingly :)
  
  For example, a program that finds an unknown switch on the commandline
  might well use a fatal logging level to tell users about it - the "system"
  in this case would be the program, or module.
  
  Some methods also offer some extra levels, such as C<0>, C<off>, C<none>
  or C<all> - these are only valid for the methods that documented them.
  
  =head1 LOGGING FUNCTIONS
  
  The following functions allow you to log messages. They always use the
  caller's package as a "logging context". Also, the main logging function,
  C<log>, is aliased to C<AnyEvent::log> and C<AE::log> when the C<AnyEvent>
  module is loaded.
  
  =over 4
  
  =cut
  
  package AnyEvent::Log;
  
  use Carp ();
  use POSIX ();
  
  # layout of a context
  #       0       1         2        3        4,    5
  # [$title, $level, %$slaves, &$logcb, &$fmtcb, $cap]
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  #use AnyEvent::Util (); need to load this in a delayed fashion, as it uses AE::log
  
  our $VERSION = $AnyEvent::VERSION;
  
  our ($COLLECT, $FILTER, $LOG);
  
  our ($now_int, $now_str1, $now_str2);
  
  # Format Time, not public - yet?
  sub format_time($) {
     my $i = int $_[0];
     my $f = sprintf "%06d", 1e6 * ($_[0] - $i);
  
     ($now_int, $now_str1, $now_str2) = ($i, split /\x01/, POSIX::strftime "%Y-%m-%d %H:%M:%S.\x01 %z", localtime $i)
        if $now_int != $i;
  
     "$now_str1$f$now_str2"
  }
  
  our %CTX; # all package contexts
  
  # creates a default package context object for the given package
  sub _pkg_ctx($) {
     my $ctx = bless [$_[0], (1 << 10) - 1 - 1, {}], "AnyEvent::Log::Ctx";
  
     # link "parent" package
     my $parent = $_[0] =~ /^(.+)::/
        ? $CTX{$1} ||= &_pkg_ctx ("$1")
        : $COLLECT;
  
     $ctx->[2]{$parent+0} = $parent;
  
     $ctx
  }
  
  =item AnyEvent::Log::log $level, $msg[, @args]
  
  Requests logging of the given C<$msg> with the given log level, and
  returns true if the message was logged I<somewhere>.
  
  For loglevel C<fatal>, the program will abort.
  
  If only a C<$msg> is given, it is logged as-is. With extra C<@args>, the
  C<$msg> is interpreted as an sprintf format string.
  
  The C<$msg> should not end with C<\n>, but may if that is convenient for
  you. Also, multiline messages are handled properly.
  
  Last not least, C<$msg> might be a code reference, in which case it is
  supposed to return the message. It will be called only then the message
  actually gets logged, which is useful if it is costly to create the
  message in the first place.
  
  This function takes care of saving and restoring C<$!> and C<$@>, so you
  don't have to.
  
  Whether the given message will be logged depends on the maximum log level
  and the caller's package. The return value can be used to ensure that
  messages or not "lost" - for example, when L<AnyEvent::Debug> detects a
  runtime error it tries to log it at C<die> level, but if that message is
  lost it simply uses warn.
  
  Note that you can (and should) call this function as C<AnyEvent::log> or
  C<AE::log>, without C<use>-ing this module if possible (i.e. you don't
  need any additional functionality), as those functions will load the
  logging module on demand only. They are also much shorter to write.
  
  Also, if you optionally generate a lot of debug messages (such as when
  tracing some code), you should look into using a logger callback and a
  boolean enabler (see C<logger>, below).
  
  Example: log something at error level.
  
     AE::log error => "something";
  
  Example: use printf-formatting.
  
     AE::log info => "%5d %-10.10s %s", $index, $category, $msg;
  
  Example: only generate a costly dump when the message is actually being logged.
  
     AE::log debug => sub { require Data::Dump; Data::Dump::dump \%cache };
  
  =cut
  
  # also allow syslog equivalent names
  our %STR2LEVEL = (
     fatal    => 1, emerg    => 1, exit => 1,
     alert    => 2,
     critical => 3, crit     => 3,
     error    => 4, err      => 4, die  => 4,
     warn     => 5, warning  => 5,
     note     => 6, notice   => 6,
     info     => 7,
     debug    => 8,
     trace    => 9,
  );
  
  our $TIME_EXACT;
  
  sub exact_time($) {
     $TIME_EXACT = shift;
     *_ts = $AnyEvent::MODEL
        ? $TIME_EXACT ? \&AE::now : \&AE::time
        : sub () { $TIME_EXACT ? do { require Time::HiRes; Time::HiRes::time () } : time };
  }
  
  BEGIN {
     exact_time 0;
  }
  
  AnyEvent::post_detect {
     exact_time $TIME_EXACT;
  };
  
  our @LEVEL2STR = qw(0 fatal alert crit error warn note info debug trace);
  
  # time, ctx, level, msg
  sub default_format($$$$) {
     my $ts = format_time $_[0];
     my $ct = " ";
  
     my @res;
  
     for (split /\n/, sprintf "%-5s %s: %s", $LEVEL2STR[$_[2]], $_[1][0], $_[3]) {
        push @res, "$ts$ct$_\n";
        $ct = " + ";
     }
  
     join "", @res
  }
  
  sub fatal_exit() {
     exit 1;
  }
  
  sub _log {
     my ($ctx, $level, $format, @args) = @_;
  
     $level = $level > 0 && $level <= 9
              ? $level+0
              : $STR2LEVEL{$level} || Carp::croak "$level: not a valid logging level, caught";
  
     my $mask = 1 << $level;
  
     my ($success, %seen, @ctx, $now, @fmt);
  
     do
        {
           # if !ref, then it's a level number
           if (!ref $ctx) {
              $level = $ctx;
           } elsif ($ctx->[1] & $mask and !$seen{$ctx+0}++) {
              # logging/recursing into this context
  
              # level cap
              if ($ctx->[5] > $level) {
                 push @ctx, $level; # restore level when going up in tree
                 $level = $ctx->[5];
              }
  
              # log if log cb
              if ($ctx->[3]) {
                 # logging target found
  
                 local ($!, $@);
  
                 # now get raw message, unless we have it already
                 unless ($now) {
                    $format = $format->() if ref $format;
                    $format = sprintf $format, @args if @args;
                    $format =~ s/\n$//;
                    $now = _ts;
                 };
  
                 # format msg
                 my $str = $ctx->[4]
                    ? $ctx->[4]($now, $_[0], $level, $format)
                    : ($fmt[$level] ||= default_format $now, $_[0], $level, $format);
  
                 $success = 1;
  
                 $ctx->[3]($str)
                    or push @ctx, values %{ $ctx->[2] }; # not consumed - propagate
              } else {
                 push @ctx, values %{ $ctx->[2] }; # not masked - propagate
              }
           }
        }
     while $ctx = pop @ctx;
  
     fatal_exit if $level <= 1;
  
     $success
  }
  
  sub log($$;@) {
     _log
        $CTX{ (caller)[0] } ||= _pkg_ctx +(caller)[0],
        @_;
  }
  
  =item $logger = AnyEvent::Log::logger $level[, \$enabled]
  
  Creates a code reference that, when called, acts as if the
  C<AnyEvent::Log::log> function was called at this point with the given
  level. C<$logger> is passed a C<$msg> and optional C<@args>, just as with
  the C<AnyEvent::Log::log> function:
  
     my $debug_log = AnyEvent::Log::logger "debug";
  
     $debug_log->("debug here");
     $debug_log->("%06d emails processed", 12345);
     $debug_log->(sub { $obj->as_string });
  
  The idea behind this function is to decide whether to log before actually
  logging - when the C<logger> function is called once, but the returned
  logger callback often, then this can be a tremendous speed win.
  
  Despite this speed advantage, changes in logging configuration will
  still be reflected by the logger callback, even if configuration changes
  I<after> it was created.
  
  To further speed up logging, you can bind a scalar variable to the logger,
  which contains true if the logger should be called or not - if it is
  false, calling the logger can be safely skipped. This variable will be
  updated as long as C<$logger> is alive.
  
  Full example:
  
     # near the init section
     use AnyEvent::Log;
  
     my $debug_log = AnyEvent:Log::logger debug => \my $debug;
  
     # and later in your program
     $debug_log->("yo, stuff here") if $debug;
  
     $debug and $debug_log->("123");
  
  =cut
  
  our %LOGGER;
  
  # re-assess logging status for all loggers
  sub _reassess {
     local $SIG{__DIE__};
     my $die = sub { die };
  
     for (@_ ? $LOGGER{$_[0]} : values %LOGGER) {
        my ($ctx, $level, $renabled) = @$_;
  
        # to detect whether a message would be logged, we actually
        # try to log one and die. this isn't fast, but we can be
        # sure that the logging decision is correct :)
  
        $$renabled = !eval {
           _log $ctx, $level, $die;
  
           1
        };
     }
  }
  
  sub _logger {
     my ($ctx, $level, $renabled) = @_;
  
     $$renabled = 1;
  
     my $logger = [$ctx, $level, $renabled];
  
     $LOGGER{$logger+0} = $logger;
  
     _reassess $logger+0;
  
     require AnyEvent::Util unless $AnyEvent::Util::VERSION;
     my $guard = AnyEvent::Util::guard (sub {
        # "clean up"
        delete $LOGGER{$logger+0};
     });
  
     sub {
        $guard if 0; # keep guard alive, but don't cause runtime overhead
  
        _log $ctx, $level, @_
           if $$renabled;
     }
  }
  
  sub logger($;$) {
     _logger
        $CTX{ (caller)[0] } ||= _pkg_ctx +(caller)[0],
        @_
  }
  
  =item AnyEvent::Log::exact_time $on
  
  By default, C<AnyEvent::Log> will use C<AE::now>, i.e. the cached
  eventloop time, for the log timestamps. After calling this function with a
  true value it will instead resort to C<AE::time>, i.e. fetch the current
  time on each log message. This only makes a difference for event loops
  that actually cache the time (such as L<EV> or L<AnyEvent::Loop>).
  
  This setting can be changed at any time by calling this function.
  
  Since C<AnyEvent::Log> has to work even before the L<AnyEvent> has been
  initialised, this switch will also decide whether to use C<CORE::time> or
  C<Time::HiRes::time> when logging a message before L<AnyEvent> becomes
  available.
  
  =item AnyEvent::Log::format_time $timestamp
  
  Formats a timestamp as returned by C<< AnyEvent->now >> or C<<
  AnyEvent->time >> or many other functions in the same way as
  C<AnyEvent::Log> does.
  
  In your main program (as opposed to in your module) you can override
  the default timestamp display format by loading this module and then
  redefining this function.
  
  Most commonly, this function can be used in formatting callbacks.
  
  =item AnyEvent::Log::default_format $time, $ctx, $level, $msg
  
  Format a log message using the given timestamp, logging context, log level
  and log message.
  
  This is the formatting function used to format messages when no custom
  function is provided.
  
  In your main program (as opposed to in your module) you can override the
  default message format by loading this module and then redefining this
  function.
  
  =item AnyEvent::Log::fatal_exit()
  
  This is the function that is called after logging a C<fatal> log
  message. It must not return.
  
  The default implementation simply calls C<exit 1>.
  
  In your main program (as opposed to in your module) you can override
  the fatal exit function by loading this module and then redefining this
  function. Make sure you don't return.
  
  =back
  
  =head1 LOGGING CONTEXTS
  
  This module associates every log message with a so-called I<logging
  context>, based on the package of the caller. Every perl package has its
  own logging context.
  
  A logging context has three major responsibilities: filtering, logging and
  propagating the message.
  
  For the first purpose, filtering, each context has a set of logging
  levels, called the log level mask. Messages not in the set will be ignored
  by this context (masked).
  
  For logging, the context stores a formatting callback (which takes the
  timestamp, context, level and string message and formats it in the way
  it should be logged) and a logging callback (which is responsible for
  actually logging the formatted message and telling C<AnyEvent::Log>
  whether it has consumed the message, or whether it should be propagated).
  
  For propagation, a context can have any number of attached I<slave
  contexts>. Any message that is neither masked by the logging mask nor
  masked by the logging callback returning true will be passed to all slave
  contexts.
  
  Each call to a logging function will log the message at most once per
  context, so it does not matter (much) if there are cycles or if the
  message can arrive at the same context via multiple paths.
  
  =head2 DEFAULTS
  
  By default, all logging contexts have an full set of log levels ("all"), a
  disabled logging callback and the default formatting callback.
  
  Package contexts have the package name as logging title by default.
  
  They have exactly one slave - the context of the "parent" package. The
  parent package is simply defined to be the package name without the last
  component, i.e. C<AnyEvent::Debug::Wrapped> becomes C<AnyEvent::Debug>,
  and C<AnyEvent> becomes ... C<$AnyEvent::Log::COLLECT> which is the
  exception of the rule - just like the "parent" of any single-component
  package name in Perl is C<main>, the default slave of any top-level
  package context is C<$AnyEvent::Log::COLLECT>.
  
  Since perl packages form only an approximate hierarchy, this slave
  context can of course be removed.
  
  All other (anonymous) contexts have no slaves and an empty title by
  default.
  
  When the module is loaded it creates the C<$AnyEvent::Log::LOG> logging
  context that simply logs everything via C<warn>, without propagating
  anything anywhere by default.  The purpose of this context is to provide
  a convenient place to override the global logging target or to attach
  additional log targets. It's not meant for filtering.
  
  It then creates the C<$AnyEvent::Log::FILTER> context whose
  purpose is to suppress all messages with priority higher
  than C<$ENV{PERL_ANYEVENT_VERBOSE}>. It then attached the
  C<$AnyEvent::Log::LOG> context to it. The purpose of the filter context
  is to simply provide filtering according to some global log level.
  
  Finally it creates the top-level package context C<$AnyEvent::Log::COLLECT>
  and attaches the C<$AnyEvent::Log::FILTER> context to it, but otherwise
  leaves it at default config. Its purpose is simply to collect all log
  messages system-wide.
  
  The hierarchy is then:
  
     any package, eventually -> $COLLECT -> $FILTER -> $LOG
  
  The effect of all this is that log messages, by default, wander up to the
  C<$AnyEvent::Log::COLLECT> context where all messages normally end up,
  from there to C<$AnyEvent::Log::FILTER> where log messages with lower
  priority then C<$ENV{PERL_ANYEVENT_VERBOSE}> will be filtered out and then
  to the C<$AnyEvent::Log::LOG> context to be passed to C<warn>.
  
  This makes it easy to set a global logging level (by modifying $FILTER),
  but still allow other contexts to send, for example, their debug and trace
  messages to the $LOG target despite the global logging level, or to attach
  additional log targets that log messages, regardless of the global logging
  level.
  
  It also makes it easy to modify the default warn-logger ($LOG) to
  something that logs to a file, or to attach additional logging targets
  (such as loggign to a file) by attaching it to $FILTER.
  
  =head2 CREATING/FINDING/DESTROYING CONTEXTS
  
  =over 4
  
  =item $ctx = AnyEvent::Log::ctx [$pkg]
  
  This function creates or returns a logging context (which is an object).
  
  If a package name is given, then the context for that package is
  returned. If it is called without any arguments, then the context for the
  callers package is returned (i.e. the same context as a C<AE::log> call
  would use).
  
  If C<undef> is given, then it creates a new anonymous context that is not
  tied to any package and is destroyed when no longer referenced.
  
  =cut
  
  sub ctx(;$) {
     my $pkg = @_ ? shift : (caller)[0];
  
     ref $pkg
        ? $pkg
        : defined $pkg
           ? $CTX{$pkg} ||= AnyEvent::Log::_pkg_ctx $pkg
           : bless [undef, (1 << 10) - 1 - 1], "AnyEvent::Log::Ctx"
  }
  
  =item AnyEvent::Log::reset
  
  Resets all package contexts and recreates the default hierarchy if
  necessary, i.e. resets the logging subsystem to defaults, as much as
  possible. This process keeps references to contexts held by other parts of
  the program intact.
  
  This can be used to implement config-file (re-)loading: before loading a
  configuration, reset all contexts.
  
  =cut
  
  our $ORIG_VERBOSE = $AnyEvent::VERBOSE;
  $AnyEvent::VERBOSE = 9;
  
  sub reset {
     # hard to kill complex data structures
     # we "recreate" all package loggers and reset the hierarchy
     while (my ($k, $v) = each %CTX) {
        @$v = ($k, (1 << 10) - 1 - 1, { });
  
        $v->attach ($k =~ /^(.+)::/ ? $CTX{$1} : $AnyEvent::Log::COLLECT);
     }
  
     @$_ = ($_->[0], (1 << 10) - 1 - 1)
        for $LOG, $FILTER, $COLLECT;
  
     #$LOG->slaves;
     $LOG->title ('$AnyEvent::Log::LOG');
     $LOG->log_to_warn;
  
     $FILTER->slaves ($LOG);
     $FILTER->title ('$AnyEvent::Log::FILTER');
     $FILTER->level ($ORIG_VERBOSE);
  
     $COLLECT->slaves ($FILTER);
     $COLLECT->title ('$AnyEvent::Log::COLLECT');
  
     _reassess;
  }
  
  # override AE::log/logger
  *AnyEvent::log    = *AE::log    = \&log;
  *AnyEvent::logger = *AE::logger = \&logger;
  
  # convert AnyEvent loggers to AnyEvent::Log loggers
  $_->[0] = ctx $_->[0] # convert "pkg" to "ctx"
     for values %LOGGER;
  
  # create the default logger contexts
  $LOG     = ctx undef;
  $FILTER  = ctx undef;
  $COLLECT = ctx undef;
  
  AnyEvent::Log::reset;
  
  # hello, CPAN, please catch me
  package AnyEvent::Log::LOG;
  package AE::Log::LOG;
  package AnyEvent::Log::FILTER;
  package AE::Log::FILTER;
  package AnyEvent::Log::COLLECT;
  package AE::Log::COLLECT;
  
  package AnyEvent::Log::Ctx;
  
  =item $ctx = new AnyEvent::Log::Ctx methodname => param...
  
  This is a convenience constructor that makes it simpler to construct
  anonymous logging contexts.
  
  Each key-value pair results in an invocation of the method of the same
  name as the key with the value as parameter, unless the value is an
  arrayref, in which case it calls the method with the contents of the
  array. The methods are called in the same order as specified.
  
  Example: create a new logging context and set both the default logging
  level, some slave contexts and a logging callback.
  
     $ctx = new AnyEvent::Log::Ctx
        title   => "dubious messages",
        level   => "error",
        log_cb  => sub { print STDOUT shift; 0 },
        slaves  => [$ctx1, $ctx, $ctx2],
     ;
  
  =back
  
  =cut
  
  sub new {
     my $class = shift;
  
     my $ctx = AnyEvent::Log::ctx undef;
  
     while (@_) {
        my ($k, $v) = splice @_, 0, 2;
        $ctx->$k (ref $v eq "ARRAY" ? @$v : $v);
     }
  
     bless $ctx, $class # do we really support subclassing, hmm?
  }
  
  
  =head2 CONFIGURING A LOG CONTEXT
  
  The following methods can be used to configure the logging context.
  
  =over 4
  
  =item $ctx->title ([$new_title])
  
  Returns the title of the logging context - this is the package name, for
  package contexts, and a user defined string for all others.
  
  If C<$new_title> is given, then it replaces the package name or title.
  
  =cut
  
  sub title {
     $_[0][0] = $_[1] if @_ > 1;
     $_[0][0]
  }
  
  =back
  
  =head3 LOGGING LEVELS
  
  The following methods deal with the logging level set associated with the
  log context.
  
  The most common method to use is probably C<< $ctx->level ($level) >>,
  which configures the specified and any higher priority levels.
  
  All functions which accept a list of levels also accept the special string
  C<all> which expands to all logging levels.
  
  =over 4
  
  =item $ctx->levels ($level[, $level...)
  
  Enables logging for the given levels and disables it for all others.
  
  =item $ctx->level ($level)
  
  Enables logging for the given level and all lower level (higher priority)
  ones. In addition to normal logging levels, specifying a level of C<0> or
  C<off> disables all logging for this level.
  
  Example: log warnings, errors and higher priority messages.
  
     $ctx->level ("warn");
     $ctx->level (5); # same thing, just numeric
  
  =item $ctx->enable ($level[, $level...])
  
  Enables logging for the given levels, leaving all others unchanged.
  
  =item $ctx->disable ($level[, $level...])
  
  Disables logging for the given levels, leaving all others unchanged.
  
  =item $ctx->cap ($level)
  
  Caps the maximum priority to the given level, for all messages logged
  to, or passing through, this context. That is, while this doesn't affect
  whether a message is logged or passed on, the maximum priority of messages
  will be limited to the specified level - messages with a higher priority
  will be set to the specified priority.
  
  Another way to view this is that C<< ->level >> filters out messages with
  a too low priority, while C<< ->cap >> modifies messages with a too high
  priority.
  
  This is useful when different log targets have different interpretations
  of priority. For example, for a specific command line program, a wrong
  command line switch might well result in a C<fatal> log message, while the
  same message, logged to syslog, is likely I<not> fatal to the system or
  syslog facility as a whole, but more likely a mere C<error>.
  
  This can be modeled by having a stderr logger that logs messages "as-is"
  and a syslog logger that logs messages with a level cap of, say, C<error>,
  or, for truly system-critical components, actually C<critical>.
  
  =cut
  
  sub _lvl_lst {
     map {
        $_ > 0 && $_ <= 9 ? $_+0
        : $_ eq "all"     ? (1 .. 9)
        : $STR2LEVEL{$_} || Carp::croak "$_: not a valid logging level, caught"
     } @_
  }
  
  sub _lvl {
     $_[0] =~ /^(?:0|off|none)$/ ? 0 : (_lvl_lst $_[0])[-1]
  }
  
  our $NOP_CB = sub { 0 };
  
  sub levels {
     my $ctx = shift;
     $ctx->[1] = 0;
     $ctx->[1] |= 1 << $_
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub level {
     my $ctx = shift;
     $ctx->[1] = ((1 << &_lvl) - 1) << 1;
     AnyEvent::Log::_reassess;
  }
  
  sub enable {
     my $ctx = shift;
     $ctx->[1] |= 1 << $_
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub disable {
     my $ctx = shift;
     $ctx->[1] &= ~(1 << $_)
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub cap {
     my $ctx = shift;
     $ctx->[5] = &_lvl;
  }
  
  =back
  
  =head3 SLAVE CONTEXTS
  
  The following methods attach and detach another logging context to a
  logging context.
  
  Log messages are propagated to all slave contexts, unless the logging
  callback consumes the message.
  
  =over 4
  
  =item $ctx->attach ($ctx2[, $ctx3...])
  
  Attaches the given contexts as slaves to this context. It is not an error
  to add a context twice (the second add will be ignored).
  
  A context can be specified either as package name or as a context object.
  
  =item $ctx->detach ($ctx2[, $ctx3...])
  
  Removes the given slaves from this context - it's not an error to attempt
  to remove a context that hasn't been added.
  
  A context can be specified either as package name or as a context object.
  
  =item $ctx->slaves ($ctx2[, $ctx3...])
  
  Replaces all slaves attached to this context by the ones given.
  
  =cut
  
  sub attach {
     my $ctx = shift;
  
     $ctx->[2]{$_+0} = $_
        for map { AnyEvent::Log::ctx $_ } @_;
     AnyEvent::Log::_reassess;
  }
  
  sub detach {
     my $ctx = shift;
  
     delete $ctx->[2]{$_+0}
        for map { AnyEvent::Log::ctx $_ } @_;
     AnyEvent::Log::_reassess;
  }
  
  sub slaves {
     undef $_[0][2];
     &attach;
     AnyEvent::Log::_reassess;
  }
  
  =back
  
  =head3 LOG TARGETS
  
  The following methods configure how the logging context actually does
  the logging (which consists of formatting the message and printing it or
  whatever it wants to do with it).
  
  =over 4
  
  =item $ctx->log_cb ($cb->($str))
  
  Replaces the logging callback on the context (C<undef> disables the
  logging callback).
  
  The logging callback is responsible for handling formatted log messages
  (see C<fmt_cb> below) - normally simple text strings that end with a
  newline (and are possibly multiline themselves).
  
  It also has to return true iff it has consumed the log message, and false
  if it hasn't. Consuming a message means that it will not be sent to any
  slave context. When in doubt, return C<0> from your logging callback.
  
  Example: a very simple logging callback, simply dump the message to STDOUT
  and do not consume it.
  
     $ctx->log_cb (sub { print STDERR shift; 0 });
  
  You can filter messages by having a log callback that simply returns C<1>
  and does not do anything with the message, but this counts as "message
  being logged" and might not be very efficient.
  
  Example: propagate all messages except for log levels "debug" and
  "trace". The messages will still be generated, though, which can slow down
  your program.
  
     $ctx->levels ("debug", "trace");
     $ctx->log_cb (sub { 1 }); # do not log, but eat debug and trace messages
  
  =item $ctx->fmt_cb ($fmt_cb->($timestamp, $orig_ctx, $level, $message))
  
  Replaces the formatting callback on the context (C<undef> restores the
  default formatter).
  
  The callback is passed the (possibly fractional) timestamp, the original
  logging context (object, not title), the (numeric) logging level and
  the raw message string and needs to return a formatted log message. In
  most cases this will be a string, but it could just as well be an array
  reference that just stores the values.
  
  If, for some reason, you want to use C<caller> to find out more about the
  logger then you should walk up the call stack until you are no longer
  inside the C<AnyEvent::Log> package.
  
  To implement your own logging callback, you might find the
  C<AnyEvent::Log::format_time> and C<AnyEvent::Log::default_format>
  functions useful.
  
  Example: format the message just as AnyEvent::Log would, by letting
  AnyEvent::Log do the work. This is a good basis to design a formatting
  callback that only changes minor aspects of the formatting.
  
     $ctx->fmt_cb (sub {
        my ($time, $ctx, $lvl, $msg) = @_;
  
        AnyEvent::Log::default_format $time, $ctx, $lvl, $msg
     });
  
  Example: format just the raw message, with numeric log level in angle
  brackets.
  
     $ctx->fmt_cb (sub {
        my ($time, $ctx, $lvl, $msg) = @_;
  
        "<$lvl>$msg\n"
     });
  
  Example: return an array reference with just the log values, and use
  C<PApp::SQL::sql_exec> to store the message in a database.
  
     $ctx->fmt_cb (sub { \@_ });
     $ctx->log_cb (sub {
        my ($msg) = @_;
  
        sql_exec "insert into log (when, subsys, prio, msg) values (?, ?, ?, ?)",
                 $msg->[0] + 0,
                 "$msg->[1]",
                 $msg->[2] + 0,
                 "$msg->[3]";
  
        0
     });
  
  =item $ctx->log_to_warn
  
  Sets the C<log_cb> to simply use C<CORE::warn> to report any messages
  (usually this logs to STDERR).
  
  =item $ctx->log_to_file ($path)
  
  Sets the C<log_cb> to log to a file (by appending), unbuffered. The
  function might return before the log file has been opened or created.
  
  =item $ctx->log_to_path ($path)
  
  Same as C<< ->log_to_file >>, but opens the file for each message. This
  is much slower, but allows you to change/move/rename/delete the file at
  basically any time.
  
  Needless(?) to say, if you do not want to be bitten by some evil person
  calling C<chdir>, the path should be absolute. Doesn't help with
  C<chroot>, but hey...
  
  =item $ctx->log_to_syslog ([$facility])
  
  Logs all messages via L<Sys::Syslog>, mapping C<trace> to C<debug> and
  all the others in the obvious way. If specified, then the C<$facility> is
  used as the facility (C<user>, C<auth>, C<local0> and so on). The default
  facility is C<user>.
  
  Note that this function also sets a C<fmt_cb> - the logging part requires
  an array reference with [$level, $str] as input.
  
  =cut
  
  sub log_cb {
     my ($ctx, $cb) = @_;
  
     $ctx->[3] = $cb;
  }
  
  sub fmt_cb {
     my ($ctx, $cb) = @_;
  
     $ctx->[4] = $cb;
  }
  
  sub log_to_warn {
     my ($ctx, $path) = @_;
  
     $ctx->log_cb (sub {
        warn shift;
        0
     });
  }
  
  # this function is a good example of why threads are a must,
  # simply for priority inversion.
  sub _log_to_disk {
     # eval'uating this at runtime saves 220kb rss - perl has become
     # an insane memory waster.
     eval q{ # poor man's autoloading {}
        sub _log_to_disk {
           my ($ctx, $path, $keepopen) = @_;
  
           my $fh;
           my @queue;
           my $delay;
           my $disable;
  
           use AnyEvent::IO ();
  
           my $kick = sub {
              undef $delay;
              return unless @queue;
              $delay = 1;
  
              # we pass $kick to $kick, so $kick itself doesn't keep a reference to $kick.
              my $kick = shift;
  
              # write one or more messages
              my $write = sub {
                 # we write as many messages as have been queued
                 my $data = join "", @queue;
                 @queue = ();
  
                 AnyEvent::IO::aio_write $fh, $data, sub {
                    $disable = 1;
                    @_
                       ? ($_[0] == length $data or AE::log 4 => "unable to write to logfile '$path': short write")
                       :                           AE::log 4 => "unable to write to logfile '$path': $!";
                    undef $disable;
  
                    if ($keepopen) {
                       $kick->($kick);
                    } else {
                       AnyEvent::IO::aio_close ($fh, sub {
                          undef $fh;
                          $kick->($kick);
                       });
                    }
                 };
              };
  
              if ($fh) {
                 $write->();
              } else {
                 AnyEvent::IO::aio_open
                    $path,
                    AnyEvent::IO::O_CREAT | AnyEvent::IO::O_WRONLY | AnyEvent::IO::O_APPEND,
                    0666,
                    sub {
                       $fh = shift
                          or do {
                             $disable = 1;
                             AE::log 4 => "unable to open logfile '$path': $!";
                             undef $disable;
                             return;
                          };
  
                       $write->();
                    }
                 ;
              }
           };
  
           $ctx->log_cb (sub {
              return if $disable;
              push @queue, shift;
              $kick->($kick) unless $delay;
              0
           });
  
           $kick->($kick) if $keepopen; # initial open
        };
     };
     die if $@;
     &_log_to_disk
  }
  
  sub log_to_file {
     my ($ctx, $path) = @_;
  
     _log_to_disk $ctx, $path, 1;
  }
  
  sub log_to_path {
     my ($ctx, $path) = @_;
  
     _log_to_disk $ctx, $path, 0;
  }
  
  sub log_to_syslog {
     my ($ctx, $facility) = @_;
  
     require Sys::Syslog;
  
     $ctx->fmt_cb (sub {
        my $str = $_[3];
        $str =~ s/\n(?=.)/\n+ /g;
  
        [$_[2], "($_[1][0]) $str"]
     });
  
     $facility ||= "user";
  
     $ctx->log_cb (sub {
        my $lvl = $_[0][0] < 9 ? $_[0][0] : 8;
  
        Sys::Syslog::syslog ("$facility|" . ($lvl - 1), $_)
           for split /\n/, $_[0][1];
  
        0
     });
  }
  
  =back
  
  =head3 MESSAGE LOGGING
  
  These methods allow you to log messages directly to a context, without
  going via your package context.
  
  =over 4
  
  =item $ctx->log ($level, $msg[, @params])
  
  Same as C<AnyEvent::Log::log>, but uses the given context as log context.
  
  Example: log a message in the context of another package.
  
     (AnyEvent::Log::ctx "Other::Package")->log (warn => "heely bo");
  
  =item $logger = $ctx->logger ($level[, \$enabled])
  
  Same as C<AnyEvent::Log::logger>, but uses the given context as log
  context.
  
  =cut
  
  *log    = \&AnyEvent::Log::_log;
  *logger = \&AnyEvent::Log::_logger;
  
  =back
  
  =cut
  
  package AnyEvent::Log;
  
  =head1 CONFIGURATION VIA $ENV{PERL_ANYEVENT_LOG}
  
  Logging can also be configured by setting the environment variable
  C<PERL_ANYEVENT_LOG> (or C<AE_LOG>).
  
  The value consists of one or more logging context specifications separated
  by C<:> or whitespace. Each logging specification in turn starts with a
  context name, followed by C<=>, followed by zero or more comma-separated
  configuration directives, here are some examples:
  
     # set default logging level
     filter=warn
  
     # log to file instead of to stderr
     log=file=/tmp/mylog
  
     # log to file in addition to stderr
     log=+%file:%file=file=/tmp/mylog
  
     # enable debug log messages, log warnings and above to syslog
     filter=debug:log=+%warnings:%warnings=warn,syslog=LOG_LOCAL0
  
     # log trace messages (only) from AnyEvent::Debug to file
     AnyEvent::Debug=+%trace:%trace=only,trace,file=/tmp/tracelog
  
  A context name in the log specification can be any of the following:
  
  =over 4
  
  =item C<collect>, C<filter>, C<log>
  
  Correspond to the three predefined C<$AnyEvent::Log::COLLECT>,
  C<AnyEvent::Log::FILTER> and C<$AnyEvent::Log::LOG> contexts.
  
  =item C<%name>
  
  Context names starting with a C<%> are anonymous contexts created when the
  name is first mentioned. The difference to package contexts is that by
  default they have no attached slaves.
  
  This makes it possible to create new log contexts that can be refered to
  multiple times by name within the same log specification.
  
  =item a perl package name
  
  Any other string references the logging context associated with the given
  Perl C<package>. In the unlikely case where you want to specify a package
  context that matches on of the other context name forms, you can add a
  C<::> to the package name to force interpretation as a package.
  
  =back
  
  The configuration specifications can be any number of the following:
  
  =over 4
  
  =item C<stderr>
  
  Configures the context to use Perl's C<warn> function (which typically
  logs to C<STDERR>). Works like C<log_to_warn>.
  
  =item C<file=>I<path>
  
  Configures the context to log to a file with the given path. Works like
  C<log_to_file>.
  
  =item C<path=>I<path>
  
  Configures the context to log to a file with the given path. Works like
  C<log_to_path>.
  
  =item C<syslog> or C<syslog=>I<expr>
  
  Configures the context to log to syslog. If I<expr> is given, then it is
  evaluated in the L<Sys::Syslog> package, so you could use:
  
     log=syslog=LOG_LOCAL0
  
  =item C<nolog>
  
  Configures the context to not log anything by itself, which is the
  default. Same as C<< $ctx->log_cb (undef) >>.
  
  =item C<cap=>I<level>
  
  Caps logging messages entering this context at the given level, i.e.
  reduces the priority of messages with higher priority than this level. The
  default is C<0> (or C<off>), meaning the priority will not be touched.
  
  =item C<0> or C<off>
  
  Sets the logging level of the context to C<0>, i.e. all messages will be
  filtered out.
  
  =item C<all>
  
  Enables all logging levels, i.e. filtering will effectively be switched
  off (the default).
  
  =item C<only>
  
  Disables all logging levels, and changes the interpretation of following
  level specifications to enable the specified level only.
  
  Example: only enable debug messages for a context.
  
     context=only,debug
  
  =item C<except>
  
  Enables all logging levels, and changes the interpretation of following
  level specifications to disable that level. Rarely used.
  
  Example: enable all logging levels except fatal and trace (this is rather
  nonsensical).
  
     filter=exept,fatal,trace
  
  =item C<level>
  
  Enables all logging levels, and changes the interpretation of following
  level specifications to be "that level or any higher priority
  message". This is the default.
  
  Example: log anything at or above warn level.
  
     filter=warn
  
     # or, more verbose
     filter=only,level,warn
  
  =item C<1>..C<9> or a logging level name (C<error>, C<debug> etc.)
  
  A numeric loglevel or the name of a loglevel will be interpreted according
  to the most recent C<only>, C<except> or C<level> directive. By default,
  specifying a logging level enables that and any higher priority messages.
  
  =item C<+>I<context>
  
  Attaches the named context as slave to the context.
  
  =item C<+>
  
  A lone C<+> detaches all contexts, i.e. clears the slave list from the
  context. Anonymous (C<%name>) contexts have no attached slaves by default,
  but package contexts have the parent context as slave by default.
  
  Example: log messages from My::Module to a file, do not send them to the
  default log collector.
  
     My::Module=+,file=/tmp/mymodulelog
  
  =back
  
  Any character can be escaped by prefixing it with a C<\> (backslash), as
  usual, so to log to a file containing a comma, colon, backslash and some
  spaces in the filename, you would do this:
  
     PERL_ANYEVENT_LOG='log=file=/some\ \:file\ with\,\ \\-escapes'
  
  Since whitespace (which includes newlines) is allowed, it is fine to
  specify multiple lines in C<PERL_ANYEVENT_LOG>, e.g.:
  
     PERL_ANYEVENT_LOG="
        filter=warn
        AnyEvent::Debug=+%trace
        %trace=only,trace,+log
     " myprog
  
  Also, in the unlikely case when you want to concatenate specifications,
  use whitespace as separator, as C<::> will be interpreted as part of a
  module name, an empty spec with two separators:
  
     PERL_ANYEVENT_LOG="$PERL_ANYEVENT_LOG MyMod=debug"
  
  =cut
  
  for (my $spec = $ENV{PERL_ANYEVENT_LOG}) {
     my %anon;
  
     my $pkg = sub {
        $_[0] eq "log"              ? $LOG
        : $_[0] eq "filter"         ? $FILTER
        : $_[0] eq "collect"        ? $COLLECT
        : $_[0] =~ /^%(.+)$/        ? ($anon{$1} ||= do { my $ctx = ctx undef; $ctx->[0] = $_[0]; $ctx })
        : $_[0] =~ /^(.*?)(?:::)?$/ ? ctx "$1" # egad :/
        : die # never reached?
     };
  
     /\G[[:space:]]+/gc; # skip initial whitespace
  
     while (/\G((?:[^:=[:space:]]+|::|\\.)+)=/gc) {
        my $ctx = $pkg->($1);
        my $level = "level";
  
        while (/\G((?:[^,:[:space:]]+|::|\\.)+)/gc) {
           for ("$1") {
              if ($_ eq "stderr"               ) { $ctx->log_to_warn;
              } elsif (/^file=(.+)/            ) { $ctx->log_to_file ("$1");
              } elsif (/^path=(.+)/            ) { $ctx->log_to_path ("$1");
              } elsif (/^syslog(?:=(.*))?/     ) { require Sys::Syslog; $ctx->log_to_syslog ("$1");
              } elsif ($_ eq "nolog"           ) { $ctx->log_cb (undef);
              } elsif (/^cap=(.+)/             ) { $ctx->cap ("$1");
              } elsif (/^\+(.+)$/              ) { $ctx->attach ($pkg->("$1"));
              } elsif ($_ eq "+"               ) { $ctx->slaves;
              } elsif ($_ eq "off" or $_ eq "0") { $ctx->level (0);
              } elsif ($_ eq "all"             ) { $ctx->level ("all");
              } elsif ($_ eq "level"           ) { $ctx->level ("all"); $level = "level";
              } elsif ($_ eq "only"            ) { $ctx->level ("off"); $level = "enable";
              } elsif ($_ eq "except"          ) { $ctx->level ("all"); $level = "disable";
              } elsif (/^\d$/                  ) { $ctx->$level ($_);
              } elsif (exists $STR2LEVEL{$_}   ) { $ctx->$level ($_);
              } else                             { die "PERL_ANYEVENT_LOG ($spec): parse error at '$_'\n";
              }
           }
  
           /\G,/gc or last;
        }
  
        /\G[:[:space:]]+/gc or last;
     }
  
     /\G[[:space:]]+/gc; # skip trailing whitespace
  
     if (/\G(.+)/g) {
        die "PERL_ANYEVENT_LOG ($spec): parse error at '$1'\n";
     }
  }
  
  =head1 EXAMPLES
  
  This section shows some common configurations, both as code, and as
  C<PERL_ANYEVENT_LOG> string.
  
  =over 4
  
  =item Setting the global logging level.
  
  Either put C<PERL_ANYEVENT_VERBOSE=><number> into your environment before
  running your program, use C<PERL_ANYEVENT_LOG> or modify the log level of
  the root context at runtime:
  
     PERL_ANYEVENT_VERBOSE=5 ./myprog
  
     PERL_ANYEVENT_LOG=log=warn
  
     $AnyEvent::Log::FILTER->level ("warn");
  
  =item Append all messages to a file instead of sending them to STDERR.
  
  This is affected by the global logging level.
  
     $AnyEvent::Log::LOG->log_to_file ($path);
  
     PERL_ANYEVENT_LOG=log=file=/some/path
  
  =item Write all messages with priority C<error> and higher to a file.
  
  This writes them only when the global logging level allows it, because
  it is attached to the default context which is invoked I<after> global
  filtering.
  
     $AnyEvent::Log::FILTER->attach (
        new AnyEvent::Log::Ctx log_to_file => $path);
  
     PERL_ANYEVENT_LOG=filter=+%filelogger:%filelogger=file=/some/path
  
  This writes them regardless of the global logging level, because it is
  attached to the toplevel context, which receives all messages I<before>
  the global filtering.
  
     $AnyEvent::Log::COLLECT->attach (
        new AnyEvent::Log::Ctx log_to_file => $path);
  
     PERL_ANYEVENT_LOG=%filelogger=file=/some/path:collect=+%filelogger
  
  In both cases, messages are still written to STDERR.
  
  =item Additionally log all messages with C<warn> and higher priority to
  C<syslog>, but cap at C<error>.
  
  This logs all messages to the default log target, but also logs messages
  with priority C<warn> or higher (and not filtered otherwise) to syslog
  facility C<user>. Messages with priority higher than C<error> will be
  logged with level C<error>.
  
     $AnyEvent::Log::LOG->attach (
        new AnyEvent::Log::Ctx
           level  => "warn",
           cap    => "error",
           syslog => "user",
     );
  
     PERL_ANYEVENT_LOG=log=+%syslog:%syslog=warn,cap=error,syslog
  
  =item Write trace messages (only) from L<AnyEvent::Debug> to the default logging target(s).
  
  Attach the C<$AnyEvent::Log::LOG> context to the C<AnyEvent::Debug>
  context - this simply circumvents the global filtering for trace messages.
  
     my $debug = AnyEvent::Debug->AnyEvent::Log::ctx;
     $debug->attach ($AnyEvent::Log::LOG);
  
     PERL_ANYEVENT_LOG=AnyEvent::Debug=+log
  
  This of course works for any package, not just L<AnyEvent::Debug>, but
  assumes the log level for AnyEvent::Debug hasn't been changed from the
  default.
  
  =back
  
  =head1 ASYNCHRONOUS DISK I/O
  
  This module uses L<AnyEvent::IO> to actually write log messages (in
  C<log_to_file> and C<log_to_path>), so it doesn't block your program when
  the disk is busy and a non-blocking L<AnyEvent::IO> backend is available.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_LOG

$fatpacked{"AnyEvent/Loop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOOP';
  =head1 NAME
  
  AnyEvent::Loop - AnyEvent's Pure-Perl event loop
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     # use AnyEvent::Loop;
    
     # this module gets loaded automatically when no other loop can be found
  
     # Explicit use:
     use AnyEvent::Loop;
     use AnyEvent;
  
     ...
  
     AnyEvent::Loop::run; # run the event loop
  
  =head1 DESCRIPTION
  
  This module provides an event loop for AnyEvent in case no other event
  loop could be found or loaded. You don't have to do anything to make it
  work with AnyEvent except by possibly loading it before creating the first
  AnyEvent watcher.
  
  This module is I<not> some loop abstracion used by AnyEvent, but just
  another event loop like EV or Glib, just written in pure perl and
  delivered with AnyEvent, so AnyEvent always works, even in the absence of
  any other backend.
  
  If you want to use this module instead of autoloading a potentially better
  event loop you can simply load it (and no other event loops) before
  creating the first watcher.
  
  As for performance, this module is on par with (and usually faster than)
  most select/poll-based C event modules such as Event or Glib (it does not
  even come close to EV, though), with respect to I/O watchers. Timers are
  handled less optimally, but for many common tasks, it is still on par with
  event loops written in C.
  
  This event loop has been optimised for the following use cases:
  
  =over 4
  
  =item monotonic clock is available
  
  This module will use the POSIX monotonic clock option (if it can be
  detected at runtime) or the POSIX C<times> function (if the resolution
  is at least 100Hz), in which case it will not suffer adversely from time
  jumps.
  
  If no monotonic clock is available, this module will not attempt to
  correct for time jumps in any way.
  
  The clock chosen will be reported if the environment variable
  C<$PERL_ANYEVENT_VERBOSE> is set to 8 or higher.
  
  =item any number of watchers on one fd
  
  Supporting a large number of watchers per fd is purely a dirty benchmark
  optimisation not relevant in practise. The more common case of having one
  watcher per fd/poll combo is special-cased, however, and therefore fast,
  too.
  
  =item relatively few active fds per C<select> call
  
  This module expects that only a tiny amount of fds is active at any one
  time. This is relatively typical of larger servers (but not the case where
  C<select> traditionally is fast), at the expense of the "dense activity
  case" where most of the fds are active (which suits C<select>).
  
  The optimal implementation of the "dense" case is not much faster, though,
  so the module should behave very well in most cases, subject to the bad
  scalability of C<select> in the presence of a large number of inactive
  file descriptors.
  
  =item lots of timer changes/iteration, or none at all
  
  This module sorts the timer list using perl's C<sort>, even though a total
  ordering is not required for timers internally.
  
  This sorting is expensive, but means sorting can be avoided unless the
  timer list has changed in a way that requires a new sort.
  
  This means that adding lots of timers is very efficient, as well as not
  changing the timers. Advancing timers (e.g. recreating a timeout watcher
  on activity) is also relatively efficient, for example, if you have a
  large number of timeout watchers that time out after 10 seconds, then the
  timer list will be sorted only once every 10 seconds.
  
  This should not have much of an impact unless you have hundreds or
  thousands of timers, though, or your timers have very small timeouts.
  
  =back
  
  =head1 FUNCTIONS
  
  The only user-visible functions provided by this module loop related -
  watchers are created via the normal AnyEvent mechanisms.
  
  =over 4
  
  =item AnyEvent::Loop::run
  
  Run the event loop, usually the last thing done in the main program when
  you want to use the pure-perl backend.
  
  =item AnyEvent::Loop::one_event
  
  Blocks until at least one new event has been received by the operating
  system, whether or not it was AnyEvent-related.
  
  =back
  
  =cut
  
  package AnyEvent::Loop;
  
  use Scalar::Util qw(weaken);
  use List::Util ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  
  our $VERSION = $AnyEvent::VERSION;
  
  our ($NOW, $MNOW);
  
  sub MAXWAIT() { 3600 } # never sleep for longer than this many seconds
  
  BEGIN {
     local $SIG{__DIE__}; # protect us against the many broken __DIE__ handlers out there
     my $time_hires = eval "use Time::HiRes (); 1";
     my $clk_tck    = eval "use POSIX (); POSIX::sysconf (POSIX::_SC_CLK_TCK ())";
     my $round; # actual granularity
  
     if ($time_hires && eval "&Time::HiRes::clock_gettime (Time::HiRes::CLOCK_MONOTONIC ())") {
        AE::log 8 => "Using CLOCK_MONOTONIC as timebase.";
        *_update_clock = sub {
           $NOW  = &Time::HiRes::time;
           $MNOW = Time::HiRes::clock_gettime (&Time::HiRes::CLOCK_MONOTONIC);
        };
  
     } elsif (100 <= $clk_tck && $clk_tck <= 1000000 && eval { (POSIX::times ())[0] != -1 }) { # -1 is also a valid return value :/
        AE::log 8 => "Using POSIX::times (monotonic) as timebase.";
        my $HZ1 = 1 / $clk_tck;
  
        my $last = (POSIX::times ())[0];
        my $next;
        *_update_clock = sub {
           $NOW  = time; # d'oh
  
           $next = (POSIX::times ())[0];
           # we assume 32 bit signed on wrap but 64 bit will never wrap
           $last -= 4294967296 if $last > $next; # 0x100000000, but perl has problems with big hex constants
           $MNOW += ($next - $last) * $HZ1;
           $last = $next;
        };
  
        $round = $HZ1;
  
     } elsif (eval "use Time::HiRes (); 1") {
        AE::log 8 => "Using Time::HiRes::time (non-monotonic) clock as timebase.";
        *_update_clock = sub {
           $NOW = $MNOW = &Time::HiRes::time;
        };
  
     } else {
        AE::log fatal => "Unable to find sub-second time source (is this really perl 5.8.0 or later?)";
     }
  
     $round = 0.001 if $round < 0.001; # 1ms is enough for us
     $round -= $round * 1e-2; # 0.1 => 0.099
     eval "sub ROUNDUP() { $round }";
  }
  
  _update_clock;
  
  # rely on AnyEvent:Base::time to provide time
  sub now       () { $NOW          }
  sub now_update() { _update_clock }
  
  # fds[0] is for read, fds[1] is for write watchers
  # fds[poll][V] is the bitmask for select
  # fds[poll][W][fd] contains a list of i/o watchers
  # an I/O watcher is a blessed arrayref containing [fh, poll(0/1), callback, queue-index]
  # the queue-index is simply the index in the [W] array, which is only used to improve
  # benchmark results in the synthetic "many watchers on one fd" benchmark.
  my @fds = ([], []);
  sub V() { 0 }
  sub W() { 1 }
  
  my $need_sort = 1e300; # when to re-sort timer list
  my @timer; # list of [ abs-timeout, Timer::[callback] ]
  my @idle;  # list of idle callbacks
  
  # the pure perl mainloop
  sub one_event {
     _update_clock;
  
     # first sort timers if required (slow)
     if ($MNOW >= $need_sort) {
        $need_sort = 1e300;
        @timer = sort { $a->[0] <=> $b->[0] } @timer;
     }
  
     # handle all pending timers
     if (@timer && $timer[0][0] <= $MNOW) {
        do {
           my $timer = shift @timer;
           $timer->[1] && $timer->[1]($timer);
        } while @timer && $timer[0][0] <= $MNOW;
  
     } else {
        # poll for I/O events, we do not do this when there
        # were any pending timers to ensure that one_event returns
        # quickly when some timers have been handled
        my ($wait, @vec, $fds)
           = (@timer && $timer[0][0] < $need_sort ? $timer[0][0] : $need_sort) - $MNOW;
  
        $wait = $wait < MAXWAIT ? $wait + ROUNDUP : MAXWAIT;
        $wait = 0 if @idle;
  
        $fds = CORE::select
          $vec[0] = $fds[0][V],
          $vec[1] = $fds[1][V],
          AnyEvent::WIN32 ? $vec[2] = $fds[1][V] : undef,
          $wait;
  
        _update_clock;
  
        if ($fds > 0) {
           # buggy microshit windows errornously sets exceptfds instead of writefds
           $vec[1] |= $vec[2] if AnyEvent::WIN32;
  
           # prefer write watchers, because they might reduce memory pressure.
           for (1, 0) {
              my $fds = $fds[$_];
  
              # we parse the bitmask by first expanding it into
              # a string of bits
              for (unpack "b*", $vec[$_]) {
                 # and then repeatedly matching a regex against it
                 while (/1/g) {
                    # and use the resulting string position as fd
                    $_ && $_->[2]()
                       for @{ $fds->[W][(pos) - 1] || [] };
                 }
              }
           }
        } elsif (AnyEvent::WIN32 && $fds && $! == AnyEvent::Util::WSAEINVAL) {
           # buggy microshit windoze asks us to route around it
           CORE::select undef, undef, undef, $wait if $wait;
        } elsif (!@timer || $timer[0][0] > $MNOW && !$fds) {
           $$$_ && $$$_->() for @idle = grep $$$_, @idle;
        }
     }
  }
  
  sub run {
     one_event while 1;
  }
  
  sub io($$$) {
     my ($fd, $write, $cb) = @_;
  
     defined ($fd = fileno $fd)
        or $fd = $_[0];
  
     my $self = bless [
        $fd,
        $write,
        $cb,
        # q-idx
     ], "AnyEvent::Loop::io";
  
     my $fds = $fds[$self->[1]];
  
     # add watcher to fds structure
     my $q = $fds->[W][$fd] ||= [];
  
     (vec $fds->[V], $fd, 1) = 1;
  
     $self->[3] = @$q;
     push @$q, $self;
     weaken $q->[-1];
  
     $self
  }
  
  sub AnyEvent::Loop::io::DESTROY {
     my ($self) = @_;
  
     my $fds = $fds[$self->[1]];
  
     # remove watcher from fds structure
     my $fd = $self->[0];
  
     if (@{ $fds->[W][$fd] } == 1) {
        delete $fds->[W][$fd];
        (vec $fds->[V], $fd, 1) = 0;
     } else {
        my $q = $fds->[W][$fd];
        my $last = pop @$q;
  
        if ($last != $self) {
           weaken ($q->[$self->[3]] = $last);
           $last->[3] = $self->[3];
        }
     }
  }
  
  sub timer($$$) {
     my ($after, $interval, $cb) = @_;
     
     my $self;
  
     if ($interval) {
        $self = [$MNOW + $after , sub {
           $_[0][0] = List::Util::max $_[0][0] + $interval, $MNOW;
           push @timer, $_[0];
           weaken $timer[-1];
           $need_sort = $_[0][0] if $_[0][0] < $need_sort;
           &$cb;
        }];
     } else {
        $self = [$MNOW + $after, $cb];
     }
  
     push @timer, $self;
     weaken $timer[-1];
     $need_sort = $self->[0] if $self->[0] < $need_sort;
  
     $self
  }
  
  sub idle($) {
     my $cb = shift;
  
     push @idle, \\$cb;
     weaken ${$idle[-1]};
  
     ${$idle[-1]}
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_LOOP

$fatpacked{"AnyEvent/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_SOCKET';
  =head1 NAME
  
  AnyEvent::Socket - useful IPv4 and IPv6 stuff. also unix domain sockets. and stuff.
  
  =head1 SYNOPSIS
  
     use AnyEvent::Socket;
     
     tcp_connect "gameserver.deliantra.net", 13327, sub {
        my ($fh) = @_
           or die "gameserver.deliantra.net connect failed: $!";
     
        # enjoy your filehandle
     };
     
     # a simple tcp server
     tcp_server undef, 8888, sub {
        my ($fh, $host, $port) = @_;
     
        syswrite $fh, "The internet is full, $host:$port. Go away!\015\012";
     };
  
  =head1 DESCRIPTION
  
  This module implements various utility functions for handling internet
  protocol addresses and sockets, in an as transparent and simple way as
  possible.
  
  All functions documented without C<AnyEvent::Socket::> prefix are exported
  by default.
  
  =over 4
  
  =cut
  
  package AnyEvent::Socket;
  
  use Carp ();
  use Errno ();
  use Socket qw(AF_INET AF_UNIX SOCK_STREAM SOCK_DGRAM SOL_SOCKET SO_REUSEADDR);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(guard AF_INET6);
  use AnyEvent::DNS ();
  
  use base 'Exporter';
  
  our @EXPORT = qw(
     getprotobyname
     parse_hostport format_hostport
     parse_ipv4 parse_ipv6
     parse_ip parse_address
     format_ipv4 format_ipv6
     format_ip format_address
     address_family
     inet_aton
     tcp_server
     tcp_connect
  );
  
  our $VERSION = $AnyEvent::VERSION;
  
  =item $ipn = parse_ipv4 $dotted_quad
  
  Tries to parse the given dotted quad IPv4 address and return it in
  octet form (or undef when it isn't in a parsable format). Supports all
  forms specified by POSIX (e.g. C<10.0.0.1>, C<10.1>, C<10.0x020304>,
  C<0x12345678> or C<0377.0377.0377.0377>).
  
  =cut
  
  sub parse_ipv4($) {
     $_[0] =~ /^      (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* )
                (?:\. (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* ) ){0,3}$/x
        or return undef;
  
     @_ = map /^0/ ? oct : $_, split /\./, $_[0];
  
     # check leading parts against range
     return undef if grep $_ >= 256, @_[0 .. @_ - 2];
  
     # check trailing part against range
     return undef if $_[-1] >= 2 ** (8 * (4 - $#_));
  
     pack "N", (pop)
               + ($_[0] << 24)
               + ($_[1] << 16)
               + ($_[2] <<  8);
  }
  
  =item $ipn = parse_ipv6 $textual_ipv6_address
  
  Tries to parse the given IPv6 address and return it in
  octet form (or undef when it isn't in a parsable format).
  
  Should support all forms specified by RFC 2373 (and additionally all IPv4
  forms supported by parse_ipv4). Note that scope-id's are not supported
  (and will not parse).
  
  This function works similarly to C<inet_pton AF_INET6, ...>.
  
  Example:
  
     print unpack "H*", parse_ipv6 "2002:5345::10.0.0.1";
     # => 2002534500000000000000000a000001
  
     print unpack "H*", parse_ipv6 "192.89.98.1";
     # => 00000000000000000000ffffc0596201
  
  =cut
  
  sub parse_ipv6($) {
     # quick test to avoid longer processing
     my $n = $_[0] =~ y/://;
  
     if ($n < 2 || $n > 8) {
        if (!$n && (my $ipn = parse_ipv4 $_[0])) {
           return "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff$ipn";
        }
        return undef;
     }
  
     my ($h, $t) = split /::/, $_[0], 2;
  
     unless (defined $t) {
        ($h, $t) = (undef, $h);
     }
  
     my @h = split /:/, $h, -1;
     my @t = split /:/, $t, -1;
  
     # check for ipv4 tail
     if (@t && $t[-1]=~ /\./) {
        return undef if $n > 6;
  
        my $ipn = parse_ipv4 pop @t
           or return undef;
  
        push @t, map +(sprintf "%x", $_), unpack "nn", $ipn;
     }
  
     # no :: then we need to have exactly 8 components
     return undef unless @h + @t == 8 || $_[0] =~ /::/;
  
     # now check all parts for validity
     return undef if grep !/^[0-9a-fA-F]{1,4}$/, @h, @t;
  
     # now pad...
     push @h, 0 while @h + @t < 8;
  
     # and done
     pack "n*", map hex, @h, @t
  }
  
  =item $token = parse_unix $hostname
  
  This function exists mainly for symmetry to the other C<parse_protocol>
  functions - it takes a hostname and, if it is C<unix/>, it returns a
  special address token, otherwise C<undef>.
  
  The only use for this function is probably to detect whether a hostname
  matches whatever AnyEvent uses for unix domain sockets.
  
  =cut
  
  sub parse_unix($) {
     $_[0] eq "unix/"
        ? pack "S", AF_UNIX
        : undef
  
  }
  
  =item $ipn = parse_address $ip
  
  Combines C<parse_ipv4>, C<parse_ipv6> and C<parse_unix> in one
  function. The address here refers to the host address (not socket address)
  in network form (binary).
  
  If the C<$text> is C<unix/>, then this function returns a special token
  recognised by the other functions in this module to mean "UNIX domain
  socket".
  
  If the C<$text> to parse is a plain IPv4 or mapped IPv4 in IPv6 address
  (:ffff::<ipv4>), then it will be treated as an IPv4 address and four
  octets will be returned. If you don't want that, you have to call
  C<parse_ipv4> and/or C<parse_ipv6> manually (the latter always returning a
  16 octet IPv6 address for mapped IPv4 addresses).
  
  Example:
  
     print unpack "H*", parse_address "10.1.2.3";
     # => 0a010203
  
  =item $ipn = AnyEvent::Socket::aton $ip
  
  Same as C<parse_address>, but not exported (think C<Socket::inet_aton> but
  I<without> name resolution).
  
  =cut
  
  sub parse_address($) {
     for (&parse_ipv6) {
        if ($_) {
           s/^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff//;
           return $_
        } else {
           return &parse_unix
        }
     }
  }
  
  *aton = \&parse_address;
  
  =item ($name, $aliases, $proto) = getprotobyname $name
  
  Works like the builtin function of the same name, except it tries hard to
  work even on broken platforms (well, that's windows), where getprotobyname
  is traditionally very unreliable.
  
  Example: get the protocol number for TCP (usually 6)
  
     my $proto = getprotobyname "tcp";
  
  =cut
  
  # microsoft can't even get getprotobyname working (the etc/protocols file
  # gets lost fairly often on windows), so we have to hardcode some common
  # protocol numbers ourselves.
  our %PROTO_BYNAME;
  
  $PROTO_BYNAME{tcp}  = Socket::IPPROTO_TCP () if defined &Socket::IPPROTO_TCP;
  $PROTO_BYNAME{udp}  = Socket::IPPROTO_UDP () if defined &Socket::IPPROTO_UDP;
  $PROTO_BYNAME{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
  
  sub getprotobyname($) {
     my $name = lc shift;
  
     defined (my $proton = $PROTO_BYNAME{$name} || (getprotobyname $name)[2])
        or return;
  
     ($name, uc $name, $proton)
  }
  
  =item ($host, $service) = parse_hostport $string[, $default_service]
  
  Splitting a string of the form C<hostname:port> is a common
  problem. Unfortunately, just splitting on the colon makes it hard to
  specify IPv6 addresses and doesn't support the less common but well
  standardised C<[ip literal]> syntax.
  
  This function tries to do this job in a better way, it supports (at
  least) the following formats, where C<port> can be a numerical port
  number of a service name, or a C<name=port> string, and the C< port> and
  C<:port> parts are optional. Also, everywhere where an IP address is
  supported a hostname or unix domain socket address is also supported (see
  C<parse_unix>), and strings starting with C</> will also be interpreted as
  unix domain sockets.
  
     hostname:port    e.g. "www.linux.org", "www.x.de:443", "www.x.de:https=443",
     ipv4:port        e.g. "198.182.196.56", "127.1:22"
     ipv6             e.g. "::1", "affe::1"
     [ipv4or6]:port   e.g. "[::1]", "[10.0.1]:80"
     [ipv4or6] port   e.g. "[127.0.0.1]", "[www.x.org] 17"
     ipv4or6 port     e.g. "::1 443", "10.0.0.1 smtp"
     unix/:path       e.g. "unix/:/path/to/socket"
     /path            e.g. "/path/to/socket"
  
  It also supports defaulting the service name in a simple way by using
  C<$default_service> if no service was detected. If neither a service was
  detected nor a default was specified, then this function returns the
  empty list. The same happens when a parse error was detected, such as a
  hostname with a colon in it (the function is rather forgiving, though).
  
  Example:
  
    print join ",", parse_hostport "localhost:443";
    # => "localhost,443"
  
    print join ",", parse_hostport "localhost", "https";
    # => "localhost,https"
  
    print join ",", parse_hostport "[::1]";
    # => "," (empty list)
  
    print join ",", parse_hostport "/tmp/debug.sock";
    # => "unix/", "/tmp/debug.sock"
  
  =cut
  
  sub parse_hostport($;$) {
     my ($host, $port);
  
     for ("$_[0]") { # work on a copy, just in case, and also reset pos
  
        # shortcut for /path
        return ("unix/", $_)
           if m%^/%;
  
        # parse host, special cases: "ipv6" or "ipv6[#p ]port"
        unless (
           ($host) = /^\s* ([0-9a-fA-F:]*:[0-9a-fA-F:]*:[0-9a-fA-F\.:]*)/xgc
           and parse_ipv6 $host
        ) {
           /^\s*/xgc;
  
           if (/^ \[ ([^\[\]]+) \]/xgc) {
              $host = $1;
           } elsif (/^ ([^\[\]:\ ]+) /xgc) {
              $host = $1;
           } else {
              return;
           }
        }
  
        # parse port
        if (/\G (?:\s+|:|\#) ([^:[:space:]]+) \s*$/xgc) {
           $port = $1;
        } elsif (/\G\s*$/gc && length $_[1]) {
           $port = $_[1];
        } else {
           return;
        }
  
     }
  
     # hostnames must not contain :'s
     return if $host =~ /:/ && !parse_ipv6 $host;
  
     ($host, $port)
  }
  
  =item $string = format_hostport $host, $port
  
  Takes a host (in textual form) and a port and formats in unambigiously in
  a way that C<parse_hostport> can parse it again. C<$port> can be C<undef>.
  
  =cut
  
  sub format_hostport($;$) {
     my ($host, $port) = @_;
  
     $port = ":$port"  if length $port;
     $host = "[$host]" if $host =~ /:/;
  
     "$host$port"
  }
  
  =item $sa_family = address_family $ipn
  
  Returns the address family/protocol-family (AF_xxx/PF_xxx, in one value :)
  of the given host address in network format.
  
  =cut
  
  sub address_family($) {
     4 == length $_[0]
        ? AF_INET
        : 16 == length $_[0]
           ? AF_INET6
           : unpack "S", $_[0]
  }
  
  =item $text = format_ipv4 $ipn
  
  Expects a four octet string representing a binary IPv4 address and returns
  its textual format. Rarely used, see C<format_address> for a nicer
  interface.
  
  =item $text = format_ipv6 $ipn
  
  Expects a sixteen octet string representing a binary IPv6 address and
  returns its textual format. Rarely used, see C<format_address> for a
  nicer interface.
  
  =item $text = format_address $ipn
  
  Covnvert a host address in network format (e.g. 4 octets for IPv4 or 16
  octets for IPv6) and convert it into textual form.
  
  Returns C<unix/> for UNIX domain sockets.
  
  This function works similarly to C<inet_ntop AF_INET || AF_INET6, ...>,
  except it automatically detects the address type.
  
  Returns C<undef> if it cannot detect the type.
  
  If the C<$ipn> is a mapped IPv4 in IPv6 address (:ffff::<ipv4>), then just
  the contained IPv4 address will be returned. If you do not want that, you
  have to call C<format_ipv6> manually.
  
  Example:
  
     print format_address "\x01\x02\x03\x05";
     => 1.2.3.5
  
  =item $text = AnyEvent::Socket::ntoa $ipn
  
  Same as format_address, but not exported (think C<inet_ntoa>).
  
  =cut
  
  sub format_ipv4($) {
     join ".", unpack "C4", $_[0]
  }
  
  sub format_ipv6($) {
     if ($_[0] =~ /^\x00\x00\x00\x00\x00\x00\x00\x00/) {
        if (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 eq $_[0]) {
           return "::";
        } elsif (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 eq $_[0]) {
           return "::1";
        } elsif (v0.0.0.0.0.0.0.0.0.0.0.0 eq substr $_[0], 0, 12) {
           # v4compatible
           return "::" . format_ipv4 substr $_[0], 12;
        } elsif (v0.0.0.0.0.0.0.0.0.0.255.255 eq substr $_[0], 0, 12) {
           # v4mapped
           return "::ffff:" . format_ipv4 substr $_[0], 12;
        } elsif (v0.0.0.0.0.0.0.0.255.255.0.0 eq substr $_[0], 0, 12) {
           # v4translated
           return "::ffff:0:" . format_ipv4 substr $_[0], 12;
        }
     }
  
     my $ip = sprintf "%x:%x:%x:%x:%x:%x:%x:%x", unpack "n8", $_[0];
  
     # this is admittedly rather sucky
        $ip =~ s/(?:^|:) 0:0:0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)   0:0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)     0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)       0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)         0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)           0:0 (?:$|:)/::/x;
  
     $ip
  }
  
  sub format_address($) {
     if (4 == length $_[0]) {
        return &format_ipv4;
     } elsif (16 == length $_[0]) {
        return $_[0] =~ /^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff(....)$/s
           ? format_ipv4 $1
           : &format_ipv6;
     } elsif (AF_UNIX == address_family $_[0]) {
        return "unix/"
     } else {
        return undef
     }
  }
  
  *ntoa = \&format_address;
  
  =item inet_aton $name_or_address, $cb->(@addresses)
  
  Works similarly to its Socket counterpart, except that it uses a
  callback. Use the length to distinguish between ipv4 and ipv6 (4 octets
  for IPv4, 16 for IPv6), or use C<format_address> to convert it to a more
  readable format.
  
  Note that C<resolve_sockaddr>, while initially a more complex interface,
  resolves host addresses, IDNs, service names and SRV records and gives you
  an ordered list of socket addresses to try and should be preferred over
  C<inet_aton>.
  
  Example.
  
     inet_aton "www.google.com", my $cv = AE::cv;
     say unpack "H*", $_
        for $cv->recv;
     # => d155e363
     # => d155e367 etc.
  
     inet_aton "ipv6.google.com", my $cv = AE::cv;
     say unpack "H*", $_
        for $cv->recv;
     # => 20014860a00300000000000000000068
  
  =cut
  
  sub inet_aton {
     my ($name, $cb) = @_;
  
     if (my $ipn = &parse_ipv4) {
        $cb->($ipn);
     } elsif (my $ipn = &parse_ipv6) {
        $cb->($ipn);
     } elsif ($name eq "localhost") { # rfc2606 et al.
        $cb->(v127.0.0.1, v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1);
     } else {
        require AnyEvent::DNS unless $AnyEvent::DNS::VERSION;
  
        my $ipv4 = $AnyEvent::PROTOCOL{ipv4};
        my $ipv6 = $AnyEvent::PROTOCOL{ipv6};
  
        my @res;
  
        my $cv = AE::cv {
           $cb->(map @$_, reverse @res);
        };
  
        $cv->begin;
  
        if ($ipv4) {
           $cv->begin;
           AnyEvent::DNS::a ($name, sub {
              $res[$ipv4] = [map { parse_ipv4 $_ } @_];
              $cv->end;
           });
        };
  
        if ($ipv6) {
           $cv->begin;
           AnyEvent::DNS::aaaa ($name, sub {
              $res[$ipv6] = [map { parse_ipv6 $_ } @_];
              $cv->end;
           });
        };
  
        $cv->end;
     }
  }
  
  BEGIN {
     *sockaddr_family = $Socket::VERSION >= 1.75
        ? \&Socket::sockaddr_family
        : # for 5.6.x, we need to do something much more horrible
          (Socket::pack_sockaddr_in 0x5555, "\x55\x55\x55\x55"
             | eval { Socket::pack_sockaddr_un "U" }) =~ /^\x00/
             ? sub { unpack "xC", $_[0] }
             : sub { unpack "S" , $_[0] };
  }
  
  # check for broken platforms with an extra field in sockaddr structure
  # kind of a rfc vs. bsd issue, as usual (ok, normally it's a
  # unix vs. bsd issue, a iso C vs. bsd issue or simply a
  # correctness vs. bsd issue.)
  my $pack_family = 0x55 == sockaddr_family ("\x55\x55")
                    ? "xC" : "S";
  
  =item $sa = AnyEvent::Socket::pack_sockaddr $service, $host
  
  Pack the given port/host combination into a binary sockaddr
  structure. Handles both IPv4 and IPv6 host addresses, as well as UNIX
  domain sockets (C<$host> == C<unix/> and C<$service> == absolute
  pathname).
  
  Example:
  
     my $bind = AnyEvent::Socket::pack_sockaddr 43, v195.234.53.120;
     bind $socket, $bind
        or die "bind: $!";
  
  =cut
  
  sub pack_sockaddr($$) {
     my $af = address_family $_[1];
  
     if ($af == AF_INET) {
        Socket::pack_sockaddr_in $_[0], $_[1]
     } elsif ($af == AF_INET6) {
        pack "$pack_family nL a16 L",
           AF_INET6,
           $_[0], # port
           0,     # flowinfo
           $_[1], # addr
           0      # scope id
     } elsif ($af == AF_UNIX) {
        Socket::pack_sockaddr_un $_[0]
     } else {
        Carp::croak "pack_sockaddr: invalid host";
     }
  }
  
  =item ($service, $host) = AnyEvent::Socket::unpack_sockaddr $sa
  
  Unpack the given binary sockaddr structure (as used by bind, getpeername
  etc.) into a C<$service, $host> combination.
  
  For IPv4 and IPv6, C<$service> is the port number and C<$host> the host
  address in network format (binary).
  
  For UNIX domain sockets, C<$service> is the absolute pathname and C<$host>
  is a special token that is understood by the other functions in this
  module (C<format_address> converts it to C<unix/>).
  
  =cut
  
  # perl contains a bug (imho) where it requires that the kernel always returns
  # sockaddr_un structures of maximum length (which is not, AFAICS, required
  # by any standard). try to 0-pad structures for the benefit of those platforms.
  # unfortunately, the IO::Async author chose to break Socket again in version
  # 2.011 - it now contains a bogus length check, so we disable the workaround.
  
  my $sa_un_zero = $Socket::VERSION >= 2.011
     ? ""
     : eval { Socket::pack_sockaddr_un "" };
  
  $sa_un_zero ^= $sa_un_zero;
  
  sub unpack_sockaddr($) {
     my $af = sockaddr_family $_[0];
  
     if ($af == AF_INET) {
        Socket::unpack_sockaddr_in $_[0]
     } elsif ($af == AF_INET6) {
        unpack "x2 n x4 a16", $_[0]
     } elsif ($af == AF_UNIX) {
        ((Socket::unpack_sockaddr_un $_[0] ^ $sa_un_zero), pack "S", AF_UNIX)
     } else {
        Carp::croak "unpack_sockaddr: unsupported protocol family $af";
     }
  }
  
  =item AnyEvent::Socket::resolve_sockaddr $node, $service, $proto, $family, $type, $cb->([$family, $type, $proto, $sockaddr], ...)
  
  Tries to resolve the given nodename and service name into protocol families
  and sockaddr structures usable to connect to this node and service in a
  protocol-independent way. It works remotely similar to the getaddrinfo
  posix function.
  
  For internet addresses, C<$node> is either an IPv4 or IPv6 address, an
  internet hostname (DNS domain name or IDN), and C<$service> is either
  a service name (port name from F</etc/services>) or a numerical port
  number. If both C<$node> and C<$service> are names, then SRV records
  will be consulted to find the real service, otherwise they will be
  used as-is. If you know that the service name is not in your services
  database, then you can specify the service in the format C<name=port>
  (e.g. C<http=80>).
  
  If a host cannot be found via DNS, then it will be looked up in
  F</etc/hosts> (or the file specified via C<< $ENV{PERL_ANYEVENT_HOSTS}
  >>). If they are found, the addresses there will be used. The effect is as
  if entries from F</etc/hosts> would yield C<A> and C<AAAA> records for the
  host name unless DNS already had records for them.
  
  For UNIX domain sockets, C<$node> must be the string C<unix/> and
  C<$service> must be the absolute pathname of the socket. In this case,
  C<$proto> will be ignored.
  
  C<$proto> must be a protocol name, currently C<tcp>, C<udp> or
  C<sctp>. The default is currently C<tcp>, but in the future, this function
  might try to use other protocols such as C<sctp>, depending on the socket
  type and any SRV records it might find.
  
  C<$family> must be either C<0> (meaning any protocol is OK), C<4> (use
  only IPv4) or C<6> (use only IPv6). The default is influenced by
  C<$ENV{PERL_ANYEVENT_PROTOCOLS}>.
  
  C<$type> must be C<SOCK_STREAM>, C<SOCK_DGRAM> or C<SOCK_SEQPACKET> (or
  C<undef> in which case it gets automatically chosen to be C<SOCK_STREAM>
  unless C<$proto> is C<udp>).
  
  The callback will receive zero or more array references that contain
  C<$family, $type, $proto> for use in C<socket> and a binary
  C<$sockaddr> for use in C<connect> (or C<bind>).
  
  The application should try these in the order given.
  
  Example:
  
     resolve_sockaddr "google.com", "http", 0, undef, undef, sub { ... };
  
  =cut
  
  our %HOSTS;          # $HOSTS{$nodename}[$ipv6] = [@aliases...]
  our @HOSTS_CHECKING; # callbacks to call when hosts have been loaded
  our $HOSTS_MTIME;
  
  sub _parse_hosts($) {
     %HOSTS = ();
  
     for (split /\n/, $_[0]) {
        s/#.*$//;
        s/^[ \t]+//;
        y/A-Z/a-z/;
  
        my ($addr, @aliases) = split /[ \t]+/;
        next unless @aliases;
  
        if (my $ip = parse_ipv4 $addr) {
           ($ip) = $ip =~ /^(.*)$/s if AnyEvent::TAINT;
           push @{ $HOSTS{$_}[0] }, $ip
              for @aliases;
        } elsif (my $ip = parse_ipv6 $addr) {
           ($ip) = $ip =~ /^(.*)$/s if AnyEvent::TAINT;
           push @{ $HOSTS{$_}[1] }, $ip
              for @aliases;
        }
     }
  }
  
  # helper function - unless dns delivered results, check and parse hosts, then call continuation code
  sub _load_hosts_unless(&$@) {
     my ($cont, $cv, @dns) = @_;
  
     if (@dns) {
        $cv->end;
     } else {
        my $etc_hosts = length $ENV{PERL_ANYEVENT_HOSTS} ? $ENV{PERL_ANYEVENT_HOSTS}
                        : AnyEvent::WIN32                ? "$ENV{SystemRoot}/system32/drivers/etc/hosts"
                        :                                  "/etc/hosts";
  
        push @HOSTS_CHECKING, sub {
           $cont->();
           $cv->end;
        };
  
        unless ($#HOSTS_CHECKING) {
           # we are not the first, so we actually have to do the work
           require AnyEvent::IO;
  
           AnyEvent::IO::aio_stat ($etc_hosts, sub {
              if ((stat _)[9] ne $HOSTS_MTIME) {
                 AE::log 8 => "(re)loading $etc_hosts.";
                 $HOSTS_MTIME = (stat _)[9];
                 # we might load a newer version of hosts,but that's a harmless race,
                 # as the next call will just load it again.
                 AnyEvent::IO::aio_load ($etc_hosts, sub {
                    _parse_hosts $_[0];
                    (shift @HOSTS_CHECKING)->() while @HOSTS_CHECKING;
                 });
              } else {
                 (shift @HOSTS_CHECKING)->() while @HOSTS_CHECKING;
              }
           });
        }
     }
  }
  
  sub resolve_sockaddr($$$$$$) {
     my ($node, $service, $proto, $family, $type, $cb) = @_;
  
     if ($node eq "unix/") {
        return $cb->() if $family || $service !~ /^\//; # no can do
  
        return $cb->([AF_UNIX, defined $type ? $type : SOCK_STREAM, 0, Socket::pack_sockaddr_un $service]);
     }
  
     unless (AF_INET6) {
        $family != 6
           or return $cb->();
  
        $family = 4;
     }
  
     $cb->() if $family == 4 && !$AnyEvent::PROTOCOL{ipv4};
     $cb->() if $family == 6 && !$AnyEvent::PROTOCOL{ipv6};
  
     $family ||= 4 unless $AnyEvent::PROTOCOL{ipv6};
     $family ||= 6 unless $AnyEvent::PROTOCOL{ipv4};
  
     $proto ||= "tcp";
     $type  ||= $proto eq "udp" ? SOCK_DGRAM : SOCK_STREAM;
  
     my $proton = AnyEvent::Socket::getprotobyname $proto
        or Carp::croak "$proto: protocol unknown";
  
     my $port;
  
     if ($service =~ /^(\S+)=(\d+)$/) {
        ($service, $port) = ($1, $2);
     } elsif ($service =~ /^\d+$/) {
        ($service, $port) = (undef, $service);
     } else {
        $port = (getservbyname $service, $proto)[2]
                or Carp::croak "$service/$proto: service unknown";
     }
  
     # resolve a records / provide sockaddr structures
     my $resolve = sub {
        my @target = @_;
  
        my @res;
        my $cv = AE::cv {
           $cb->(
              map $_->[2],
              sort {
                 $AnyEvent::PROTOCOL{$b->[1]} <=> $AnyEvent::PROTOCOL{$a->[1]}
                    or $a->[0] <=> $b->[0]
              }
              @res
           )
        };
  
        $cv->begin;
        for my $idx (0 .. $#target) {
           my ($node, $port) = @{ $target[$idx] };
  
           if (my $noden = parse_address $node) {
              my $af = address_family $noden;
  
              if ($af == AF_INET && $family != 6) {
                 push @res, [$idx, "ipv4", [AF_INET, $type, $proton,
                             pack_sockaddr $port, $noden]]
              }
  
              if ($af == AF_INET6 && $family != 4) {
                 push @res, [$idx, "ipv6", [AF_INET6, $type, $proton,
                             pack_sockaddr $port, $noden]]
              }
           } else {
              $node =~ y/A-Z/a-z/;
  
              # a records
              if ($family != 6) {
                 $cv->begin;
                 AnyEvent::DNS::a $node, sub {
                    push @res, [$idx, "ipv4", [AF_INET, $type, $proton, pack_sockaddr $port, parse_ipv4 $_]]
                       for @_;
  
                    # dns takes precedence over hosts
                    _load_hosts_unless {
                       push @res,
                          map [$idx, "ipv4", [AF_INET, $type, $proton, pack_sockaddr $port, $_]],
                             @{ ($HOSTS{$node} || [])->[0] };
                    } $cv, @_;
                 };
              }
  
              # aaaa records
              if ($family != 4) {
                 $cv->begin;
                 AnyEvent::DNS::aaaa $node, sub {
                    push @res, [$idx, "ipv6", [AF_INET6, $type, $proton, pack_sockaddr $port, parse_ipv6 $_]]
                       for @_;
  
                    _load_hosts_unless {
                       push @res,
                          map [$idx + 0.5, "ipv6", [AF_INET6, $type, $proton, pack_sockaddr $port, $_]],
                             @{ ($HOSTS{$node} || [])->[1] }
                    } $cv, @_;
                 };
              }
           }
        }
        $cv->end;
     };
  
     $node = AnyEvent::Util::idn_to_ascii $node
        if $node =~ /[^\x00-\x7f]/;
  
     # try srv records, if applicable
     if ($node eq "localhost") {
        $resolve->(["127.0.0.1", $port], ["::1", $port]);
     } elsif (defined $service && !parse_address $node) {
        AnyEvent::DNS::srv $service, $proto, $node, sub {
           my (@srv) = @_;
  
           if (@srv) {
              # the only srv record has "." ("" here) => abort
              $srv[0][2] ne "" || $#srv
                 or return $cb->();
  
              # use srv records then
              $resolve->(
                 map ["$_->[3].", $_->[2]],
                    grep $_->[3] ne ".",
                       @srv
              );
           } else {
              # no srv records, continue traditionally
              $resolve->([$node, $port]);
           }
        };
     } else {
        # most common case
        $resolve->([$node, $port]);
     }
  }
  
  =item $guard = tcp_connect $host, $service, $connect_cb[, $prepare_cb]
  
  This is a convenience function that creates a TCP socket and makes a
  100% non-blocking connect to the given C<$host> (which can be a DNS/IDN
  hostname or a textual IP address, or the string C<unix/> for UNIX domain
  sockets) and C<$service> (which can be a numeric port number or a service
  name, or a C<servicename=portnumber> string, or the pathname to a UNIX
  domain socket).
  
  If both C<$host> and C<$port> are names, then this function will use SRV
  records to locate the real target(s).
  
  In either case, it will create a list of target hosts (e.g. for multihomed
  hosts or hosts with both IPv4 and IPv6 addresses) and try to connect to
  each in turn.
  
  After the connection is established, then the C<$connect_cb> will be
  invoked with the socket file handle (in non-blocking mode) as first, and
  the peer host (as a textual IP address) and peer port as second and third
  arguments, respectively. The fourth argument is a code reference that you
  can call if, for some reason, you don't like this connection, which will
  cause C<tcp_connect> to try the next one (or call your callback without
  any arguments if there are no more connections). In most cases, you can
  simply ignore this argument.
  
     $cb->($filehandle, $host, $port, $retry)
  
  If the connect is unsuccessful, then the C<$connect_cb> will be invoked
  without any arguments and C<$!> will be set appropriately (with C<ENXIO>
  indicating a DNS resolution failure).
  
  The callback will I<never> be invoked before C<tcp_connect> returns, even
  if C<tcp_connect> was able to connect immediately (e.g. on unix domain
  sockets).
  
  The file handle is perfect for being plugged into L<AnyEvent::Handle>, but
  can be used as a normal perl file handle as well.
  
  Unless called in void context, C<tcp_connect> returns a guard object that
  will automatically cancel the connection attempt when it gets destroyed
  - in which case the callback will not be invoked. Destroying it does not
  do anything to the socket after the connect was successful - you cannot
  "uncall" a callback that has been invoked already.
  
  Sometimes you need to "prepare" the socket before connecting, for example,
  to C<bind> it to some port, or you want a specific connect timeout that
  is lower than your kernel's default timeout. In this case you can specify
  a second callback, C<$prepare_cb>. It will be called with the file handle
  in not-yet-connected state as only argument and must return the connection
  timeout value (or C<0>, C<undef> or the empty list to indicate the default
  timeout is to be used).
  
  Note to the poor Microsoft Windows users: Windows (of course) doesn't
  correctly signal connection errors, so unless your event library works
  around this, failed connections will simply hang. The only event libraries
  that handle this condition correctly are L<EV> and L<Glib>. Additionally,
  AnyEvent works around this bug with L<Event> and in its pure-perl
  backend. All other libraries cannot correctly handle this condition. To
  lessen the impact of this windows bug, a default timeout of 30 seconds
  will be imposed on windows. Cygwin is not affected.
  
  Simple Example: connect to localhost on port 22.
  
     tcp_connect localhost => 22, sub {
        my $fh = shift
           or die "unable to connect: $!";
        # do something
     };
  
  Complex Example: connect to www.google.com on port 80 and make a simple
  GET request without much error handling. Also limit the connection timeout
  to 15 seconds.
  
     tcp_connect "www.google.com", "http",
        sub {
           my ($fh) = @_
              or die "unable to connect: $!";
  
           my $handle; # avoid direct assignment so on_eof has it in scope.
           $handle = new AnyEvent::Handle
              fh     => $fh,
              on_error => sub {
                 AE::log error => $_[2];
                 $_[0]->destroy;
              },
              on_eof => sub {
                 $handle->destroy; # destroy handle
                 AE::log info => "Done.";
              };
  
           $handle->push_write ("GET / HTTP/1.0\015\012\015\012");
  
           $handle->push_read (line => "\015\012\015\012", sub {
              my ($handle, $line) = @_;
  
              # print response header
              print "HEADER\n$line\n\nBODY\n";
  
              $handle->on_read (sub {
                 # print response body
                 print $_[0]->rbuf;
                 $_[0]->rbuf = "";
              });
           });
        }, sub {
           my ($fh) = @_;
           # could call $fh->bind etc. here
  
           15
        };
  
  Example: connect to a UNIX domain socket.
  
     tcp_connect "unix/", "/tmp/.X11-unix/X0", sub {
        ...
     }
  
  =cut
  
  sub tcp_connect($$$;$) {
     my ($host, $port, $connect, $prepare) = @_;
  
     # see http://cr.yp.to/docs/connect.html for some tricky aspects
     # also http://advogato.org/article/672.html
  
     my %state = ( fh => undef );
  
     # name/service to type/sockaddr resolution
     resolve_sockaddr $host, $port, 0, 0, undef, sub {
        my @target = @_;
  
        $state{next} = sub {
           return unless exists $state{fh};
  
           my $errno = $!;
           my $target = shift @target
              or return AE::postpone {
                 return unless exists $state{fh};
                 %state = ();
                 $! = $errno;
                 $connect->();
              };
  
           my ($domain, $type, $proto, $sockaddr) = @$target;
  
           # socket creation
           socket $state{fh}, $domain, $type, $proto
              or return $state{next}();
  
           AnyEvent::fh_unblock $state{fh};
           
           my $timeout = $prepare && $prepare->($state{fh});
  
           $timeout ||= 30 if AnyEvent::WIN32;
  
           $state{to} = AE::timer $timeout, 0, sub {
              $! = Errno::ETIMEDOUT;
              $state{next}();
           } if $timeout;
  
           # now connect
           if (
              (connect $state{fh}, $sockaddr)
              || ($! == Errno::EINPROGRESS # POSIX
                  || $! == Errno::EWOULDBLOCK
                  # WSAEINPROGRESS intentionally not checked - it means something else entirely
                  || $! == AnyEvent::Util::WSAEINVAL # not convinced, but doesn't hurt
                  || $! == AnyEvent::Util::WSAEWOULDBLOCK)
           ) {
              $state{ww} = AE::io $state{fh}, 1, sub {
                 # we are connected, or maybe there was an error
                 if (my $sin = getpeername $state{fh}) {
                    my ($port, $host) = unpack_sockaddr $sin;
  
                    delete $state{ww}; delete $state{to};
  
                    my $guard = guard { %state = () };
  
                    $connect->(delete $state{fh}, format_address $host, $port, sub {
                       $guard->cancel;
                       $state{next}();
                    });
                 } else {
                    if ($! == Errno::ENOTCONN) {
                       # dummy read to fetch real error code if !cygwin
                       sysread $state{fh}, my $buf, 1;
  
                       # cygwin 1.5 continously reports "ready' but never delivers
                       # an error with getpeername or sysread.
                       # cygwin 1.7 only reports readyness *once*, but is otherwise
                       # the same, which is actually more broken.
                       # Work around both by using unportable SO_ERROR for cygwin.
                       $! = (unpack "l", getsockopt $state{fh}, Socket::SOL_SOCKET(), Socket::SO_ERROR()) || Errno::EAGAIN
                          if AnyEvent::CYGWIN && $! == Errno::EAGAIN;
                    }
  
                    return if $! == Errno::EAGAIN; # skip spurious wake-ups
  
                    delete $state{ww}; delete $state{to};
  
                    $state{next}();
                 }
              };
           } else {
              $state{next}();
           }
        };
  
        $! = Errno::ENXIO;
        $state{next}();
     };
  
     defined wantarray && guard { %state = () }
  }
  
  =item $guard = tcp_server $host, $service, $accept_cb[, $prepare_cb]
  
  Create and bind a stream socket to the given host address and port, set
  the SO_REUSEADDR flag (if applicable) and call C<listen>. Unlike the name
  implies, this function can also bind on UNIX domain sockets.
  
  For internet sockets, C<$host> must be an IPv4 or IPv6 address (or
  C<undef>, in which case it binds either to C<0> or to C<::>, depending
  on whether IPv4 or IPv6 is the preferred protocol, and maybe to both in
  future versions, as applicable).
  
  To bind to the IPv4 wildcard address, use C<0>, to bind to the IPv6
  wildcard address, use C<::>.
  
  The port is specified by C<$service>, which must be either a service name
  or a numeric port number (or C<0> or C<undef>, in which case an ephemeral
  port will be used).
  
  For UNIX domain sockets, C<$host> must be C<unix/> and C<$service> must be
  the absolute pathname of the socket. This function will try to C<unlink>
  the socket before it tries to bind to it, and will try to unlink it after
  it stops using it. See SECURITY CONSIDERATIONS, below.
  
  For each new connection that could be C<accept>ed, call the C<<
  $accept_cb->($fh, $host, $port) >> with the file handle (in non-blocking
  mode) as first, and the peer host and port as second and third arguments
  (see C<tcp_connect> for details).
  
  Croaks on any errors it can detect before the listen.
  
  In non-void context, this function returns a guard object whose lifetime
  it tied to the TCP server: If the object gets destroyed, the server will
  be stopped and the listening socket will be cleaned up/unlinked (already
  accepted connections will not be affected).
  
  When called in void-context, AnyEvent will keep the listening socket alive
  internally. In this case, there is no guarantee that the listening socket
  will be cleaned up or unlinked.
  
  In all cases, when the function returns to the caller, the socket is bound
  and in listening state.
  
  If you need more control over the listening socket, you can provide a
  C<< $prepare_cb->($fh, $host, $port) >>, which is called just before the
  C<listen ()> call, with the listen file handle as first argument, and IP
  address and port number of the local socket endpoint as second and third
  arguments.
  
  It should return the length of the listen queue (or C<0> for the default).
  
  Note to IPv6 users: RFC-compliant behaviour for IPv6 sockets listening on
  C<::> is to bind to both IPv6 and IPv4 addresses by default on dual-stack
  hosts. Unfortunately, only GNU/Linux seems to implement this properly, so
  if you want both IPv4 and IPv6 listening sockets you should create the
  IPv6 socket first and then attempt to bind on the IPv4 socket, but ignore
  any C<EADDRINUSE> errors.
  
  Example: bind on some TCP port on the local machine and tell each client
  to go away.
  
     tcp_server undef, undef, sub {
        my ($fh, $host, $port) = @_;
  
        syswrite $fh, "The internet is full, $host:$port. Go away!\015\012";
     }, sub {
        my ($fh, $thishost, $thisport) = @_;
        AE::log info => "Bound to $thishost, port $thisport.";
     };
  
  Example: bind a server on a unix domain socket.
  
     tcp_server "unix/", "/tmp/mydir/mysocket", sub {
        my ($fh) = @_;
     };
  
  =item $guard = AnyEvent::Socket::tcp_bind $host, $service, $done_cb[, $prepare_cb]
  
  Same as C<tcp_server>, except it doesn't call C<accept> in a loop for you
  but simply passes the listen socket to the C<$done_cb>. This is useful
  when you want to have a convenient set up for your listen socket, but want
  to do the C<accept>'ing yourself, for example, in another process.
  
  In case of an error, C<tcp_bind> either croaks, or passes C<undef> to the
  C<$done_cb>.
  
  In non-void context, a guard will be returned. It will clean up/unlink the
  listening socket when destroyed. In void context, no automatic clean up
  might be performed.
  
  =cut
  
  sub _tcp_bind($$$;$) {
     my ($host, $service, $done, $prepare) = @_;
  
     $host = $AnyEvent::PROTOCOL{ipv4} < $AnyEvent::PROTOCOL{ipv6} && AF_INET6
             ? "::" : "0"
        unless defined $host;
  
     my $ipn = parse_address $host
        or Carp::croak "tcp_bind: cannot parse '$host' as host address";
  
     my $af = address_family $ipn;
  
     my %state;
  
     # win32 perl is too stupid to get this right :/
     Carp::croak "tcp_bind: AF_UNIX address family not supported on win32"
        if AnyEvent::WIN32 && $af == AF_UNIX;
  
     socket my $fh, $af, SOCK_STREAM, 0
        or Carp::croak "tcp_bind: $!";
  
     $state{fh} = $fh;
  
     if ($af == AF_INET || $af == AF_INET6) {
        setsockopt $fh, SOL_SOCKET, SO_REUSEADDR, 1
           or Carp::croak "tcp_bind: so_reuseaddr: $!"
              unless AnyEvent::WIN32; # work around windows bug
  
        unless ($service =~ /^\d*$/) {
           $service = (getservbyname $service, "tcp")[2]
                      or Carp::croak "tcp_bind: unknown service '$service'"
        }
     } elsif ($af == AF_UNIX) {
        unlink $service;
     }
  
     bind $fh, pack_sockaddr $service, $ipn
        or Carp::croak "tcp_bind: $!";
  
     if ($af == AF_UNIX and defined wantarray) {
        # this is racy, but is not designed to be foolproof, just best-effort
        my $ino = (lstat $service)[1];
        $state{unlink} = guard {
           unlink $service
              if (lstat $service)[1] == $ino;
        };
     }
  
     AnyEvent::fh_unblock $fh;
  
     my $len;
  
     if ($prepare) {
        my ($service, $host) = unpack_sockaddr getsockname $fh;
        $len = $prepare && $prepare->($fh, format_address $host, $service);
     }
     
     $len ||= 128;
  
     listen $fh, $len
        or Carp::croak "tcp_bind: $!";
  
     $done->(\%state);
  
     defined wantarray
        ? guard { %state = () } # clear fh, unlink
        : ()
  }
  
  sub tcp_bind($$$;$) {
     my ($host, $service, $done, $prepare) = @_;
  
     _tcp_bind $host, $service, sub {
        $done->(delete shift->{fh});
     }, $prepare
  }
  
  sub tcp_server($$$;$) {
     my ($host, $service, $accept, $prepare) = @_;
  
     _tcp_bind $host, $service, sub {
        my $rstate = shift;
  
        $rstate->{aw} = AE::io $rstate->{fh}, 0, sub {
           # this closure keeps $state alive
           while ($rstate->{fh} && (my $peer = accept my $fh, $rstate->{fh})) {
              AnyEvent::fh_unblock $fh; # POSIX requires inheritance, the outside world does not
  
              my ($service, $host) = unpack_sockaddr $peer;
              $accept->($fh, format_address $host, $service);
           }
        };
     }, $prepare
  }
  
  =item tcp_nodelay $fh, $enable
  
  Enables (or disables) the C<TCP_NODELAY> socket option (also known as
  Nagle's algorithm). Returns false on error, true otherwise.
  
  =cut
  
  sub tcp_nodelay($$) {
     my $onoff = int ! ! $_[1];
  
     setsockopt $_[0], Socket::IPPROTO_TCP (), Socket::TCP_NODELAY (), $onoff
  }
  
  =item tcp_congestion $fh, $algorithm
  
  Sets the tcp congestion avoidance algorithm (via the C<TCP_CONGESTION>
  socket option). The default is OS-specific, but is usually
  C<reno>. Typical other available choices include C<cubic>, C<lp>, C<bic>,
  C<highspeed>, C<htcp>, C<hybla>, C<illinois>, C<scalable>, C<vegas>,
  C<veno>, C<westwood> and C<yeah>.
  
  =cut
  
  sub tcp_congestion($$) {
     defined TCP_CONGESTION
        ? setsockopt $_[0], Socket::IPPROTO_TCP (), TCP_CONGESTION, "$_[1]"
        : undef
  }
  
  =back
  
  =head1 SECURITY CONSIDERATIONS
  
  This module is quite powerful, with with power comes the ability to abuse
  as well: If you accept "hostnames" and ports from untrusted sources,
  then note that this can be abused to delete files (host=C<unix/>). This
  is not really a problem with this module, however, as blindly accepting
  any address and protocol and trying to bind a server or connect to it is
  harmful in general.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_SOCKET

$fatpacked{"AnyEvent/Strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_STRICT';
  =head1 NAME
  
  AnyEvent::Strict - force strict mode on for the whole process
  
  =head1 SYNOPSIS
  
     use AnyEvent::Strict;
     # strict mode now switched on
  
  =head1 DESCRIPTION
  
  This module implements AnyEvent's strict mode.
  
  Loading it makes AnyEvent check all arguments to AnyEvent-methods, at the
  expense of being slower (often the argument checking takes longer than the
  actual function). It also wraps all callbacks to check for modifications
  of C<$_>, which indicates a programming bug inside the watcher callback.
  
  Normally, you don't load this module yourself but instead use it
  indirectly via the C<PERL_ANYEVENT_STRICT> environment variable (see
  L<AnyEvent>). However, this module can be loaded manually at any time.
  
  =cut
  
  package AnyEvent::Strict;
  
  use Carp qw(confess);
  use Errno ();
  use POSIX ();
  
  $Carp::Internal{AE}               = 1;
  $Carp::Internal{AnyEvent::Strict} = 1;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  AnyEvent::_isa_hook 1 => "AnyEvent::Strict", 1;
  
  BEGIN {
     if (defined &Internals::SvREADONLY) {
        # readonly available (at least 5.8.9+, working better in 5.10.1+)
        *wrap = sub {
           my $cb = shift;
  
           sub {
              local $_;
              Internals::SvREADONLY $_, 1;
              &$cb;
           }
        };
     } else {
        # or not :/
        my $magic = []; # a unique magic value
  
        *wrap = sub {
           my $cb = shift;
  
           sub {
              local $_ = $magic;
  
              &$cb;
  
              if (!ref $_ || $_ != $magic) {
                 require AnyEvent::Debug;
                 die "callback $cb (" . AnyEvent::Debug::cb2str ($cb) . ") modified \$_ without restoring it.\n";
              }
           }
        };
     }
  }
  
  our (@FD_INUSE, $FD_I);
  our $FD_CHECK_W = AE::timer 4, 4, sub {
     my $cnt = (@FD_INUSE < 100 * 10 ? int @FD_INUSE * 0.1 : 100) || 10;
  
     if ($FD_I <= 0) {
        #pop @FD_INUSE while @FD_INUSE && !$FD_INUSE[-1];
        $FD_I = @FD_INUSE
           or return; # empty
     }
  
     $cnt = $FD_I if $cnt > $FD_I;
  
     eval {
        do {
           !$FD_INUSE[--$FD_I]
              or (POSIX::lseek $FD_I, 0, 1) != -1
              or $! != Errno::EBADF
              or die;
        } while --$cnt;
        1
     } or AE::log crit => "File descriptor $FD_I registered with AnyEvent but prematurely closed, event loop might malfunction.";
  };
  
  sub io {
     my $class = shift;
     my (%arg, $fh, $cb, $fd) = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->io called with illegal cb argument '$arg{cb}'";
     $cb = wrap delete $arg{cb};
   
     $arg{poll} =~ /^[rw]$/
        or confess "AnyEvent->io called with illegal poll argument '$arg{poll}'";
  
     $fh = delete $arg{fh};
  
     if ($fh =~ /^\s*\d+\s*$/) {
        $fd = $fh;
        ($fh) = AnyEvent::_dupfh $arg{poll}, $fh;
     } else {
        defined eval { $fd = fileno $fh }
           or confess "AnyEvent->io called with illegal fh argument '$fh'";
     }
  
     -f $fh
        and confess "AnyEvent->io called with fh argument pointing to a file";
  
     delete $arg{poll};
   
     confess "AnyEvent->io called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     ++$FD_INUSE[$fd];
  
     bless [
        $fd,
        $class->SUPER::io (@_, cb => $cb)
     ], "AnyEvent::Strict::io";
  }
  
  sub AnyEvent::Strict::io::DESTROY {
     --$FD_INUSE[$_[0][0]];
  }
  
  sub timer {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->timer called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     exists $arg{after}
        or confess "AnyEvent->timer called without mandatory 'after' parameter";
     delete $arg{after};
   
     !$arg{interval} or $arg{interval} > 0
        or confess "AnyEvent->timer called with illegal interval argument '$arg{interval}'";
     delete $arg{interval};
   
     confess "AnyEvent->timer called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::timer (@_, cb => $cb)
  }
  
  sub signal {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->signal called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     defined AnyEvent::Base::sig2num $arg{signal} and $arg{signal} == 0
        or confess "AnyEvent->signal called with illegal signal name '$arg{signal}'";
     delete $arg{signal};
   
     confess "AnyEvent->signal called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::signal (@_, cb => $cb)
  }
  
  sub child {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->child called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     $arg{pid} =~ /^-?\d+$/
        or confess "AnyEvent->child called with malformed pid value '$arg{pid}'";
     delete $arg{pid};
   
     confess "AnyEvent->child called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::child (@_, cb => $cb)
  }
  
  sub idle {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->idle called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     confess "AnyEvent->idle called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::idle (@_, cb => $cb)
  }
  
  sub condvar {
     my $class = shift;
     my %arg = @_;
  
     !exists $arg{cb} or ref $arg{cb}
        or confess "AnyEvent->condvar called with illegal cb argument '$arg{cb}'";
     my @cb = exists $arg{cb} ? (cb => wrap delete $arg{cb}) : ();
   
     confess "AnyEvent->condvar called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::condvar (@cb);
  }
  
  sub time {
     my $class = shift;
  
     @_
        and confess "AnyEvent->time wrongly called with paramaters";
  
     $class->SUPER::time (@_)
  }
  
  sub now {
     my $class = shift;
  
     @_
        and confess "AnyEvent->now wrongly called with paramaters";
  
     $class->SUPER::now (@_)
  }
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_STRICT

$fatpacked{"AnyEvent/TLS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_TLS';
  package AnyEvent::TLS;
  
  use Carp qw(croak);
  use Scalar::Util ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  
  use Net::SSLeay;
  
  =head1 NAME
  
  AnyEvent::TLS - SSLv2/SSLv3/TLSv1 contexts for use in AnyEvent::Handle
  
  =cut
  
  our $VERSION = $AnyEvent::VERSION;
  
  =head1 SYNOPSIS
  
     # via AnyEvent::Handle
  
     use AnyEvent;
     use AnyEvent::Handle;
     use AnyEvent::Socket;
  
     # simple https-client
     my $handle = new AnyEvent::Handle
        connect  => [$host, $port],
        tls      => "connect",
        tls_ctx  => { verify => 1, verify_peername => "https" },
        ...
  
     # simple ssl-server
     tcp_server undef, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh       => $fh,
           tls      => "accept",
           tls_ctx  => { cert_file => "my-server-keycert.pem" },
           ...
  
     # directly
  
     my $tls = new AnyEvent::TLS
        verify => 1,
        verify_peername => "ldaps",
        ca_file => "/etc/cacertificates.pem";
  
  =head1 DESCRIPTION
  
  This module is a helper module that implements TLS/SSL (Transport Layer
  Security/Secure Sockets Layer) contexts. A TLS context is a common set of
  configuration values for use in establishing TLS connections.
  
  For some quick facts about SSL/TLS, see the section of the same name near
  the end of the document.
  
  A single TLS context can be used for any number of TLS connections that
  wish to use the same certificates, policies etc.
  
  Note that this module is inherently tied to L<Net::SSLeay>, as this
  library is used to implement it. Since that perl module is rather ugly,
  and OpenSSL has a rather ugly license, AnyEvent might switch TLS providers
  at some future point, at which this API will change dramatically, at least
  in the Net::SSLeay-specific parts (most constructor arguments should still
  work, though).
  
  Although this module does not require a specific version of Net::SSLeay,
  many features will gradually stop working, or bugs will be introduced with
  old versions (verification might succeed when it shouldn't - this is a
  real security issue). Version 1.35 is recommended, 1.33 should work, 1.32
  might, and older versions are yours to keep.
  
  =head1 USAGE EXAMPLES
  
  See the L<AnyEvent::Handle> manpage, NONFREQUENTLY ASKED QUESTIONS, for
  some actual usage examples.
  
  =head1 PUBLIC METHODS AND FUNCTIONS
  
  =over 4
  
  =cut
  
  our $REF_IDX; # our session ex_data id
  
  # create temp file, populate it, and return a guard and filename
  sub _tmpfile($) {
     require File::Temp unless $File::Temp::VERSION;
  
     # File::Temp opens the file with mode 0600
     my ($fh, $path) = File::Temp::tempfile ("aetlsXXXXXXXXX", TMPDIR => 1, EXLOCK => 0);
     my $guard = AnyEvent::Util::guard { unlink $path };
  
     syswrite $fh, $_[0];
     close $fh;
  
     ($path, $guard)
  }
  
  our %DH_PARAMS = (
     # These are the DH parameters from "Assigned Number for SKIP Protocols"
     # (http://www.skip-vpn.org/spec/numbers.html).
     # (or http://web.archive.org/web/20011212141438/http://www.skip-vpn.org/spec/numbers.html#params)
     # See there for how they were generated.
     # Note that g might not be a generator,
     # but this is not a problem since p is a safe prime.
     skip512 => "MEYCQQD1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak|XUGfnHy9iUsiGSa6q6Jew1XpKgVfAgEC",
     skip1024 => "MIGHAoGBAPSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsY|jY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6|ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XpL3jHAgEC",
     skip2048 => "MIIBCAKCAQEA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadWoxTpj0BV|89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeSWc39uK50|T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0iP1YTknb|zSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF040zT9fBdX|Q6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQClCbAkbT|CD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwIBAg==",
     skip4096 => "MIICCAKCAgEA+hRyUsFN4VpJ1O8JLcCo/VWr19k3BCgJ4uk+d+KhehjdRqNDNyOQ|l/MOyQNQfWXPeGKmOmIig6Ev/nm6Nf9Z2B1h3R4hExf+zTiHnvVPeRBhjdQi81rt|Xeoh6TNrSBIKIHfUJWBh3va0TxxjQIs6IZOLeVNRLMqzeylWqMf49HsIXqbcokUS|Vt1BkvLdW48j8PPv5DsKRN3tloTxqDJGo9tKvj1Fuk74A+Xda1kNhB7KFlqMyN98|VETEJ6c7KpfOo30mnK30wqw3S8OtaIR/maYX72tGOno2ehFDkq3pnPtEbD2CScxc|alJC+EL7RPk5c/tgeTvCngvc1KZn92Y//EI7G9tPZtylj2b56sHtMftIoYJ9+ODM|sccD5Piz/rejE3Ome8EOOceUSCYAhXn8b3qvxVI1ddd1pED6FHRhFvLrZxFvBEM9|ERRMp5QqOaHJkM+Dxv8Cj6MqrCbfC4u+ZErxodzuusgDgvZiLF22uxMZbobFWyte|OvOzKGtwcTqO/1wV5gKkzu1ZVswVUQd5Gg8lJicwqRWyyNRczDDoG9jVDxmogKTH|AaqLulO7R8Ifa1SwF2DteSGVtgWEN8gDpN3RBmmPTDngyF2DHb5qmpnznwtFKdTL|KWbuHn491xNO25CQWMtem80uKw+pTnisBRF/454n1Jnhub144YRBoN8CAQI=",
  
     # generated on a linux desktop with openssl using /dev/urandom - entropy_avail was >= 3600 each time
     # the 8192 bit key took 25 hours to generate :/
     schmorp1024 => "MIGHAoGBAN+GjqAhNxLesSuGfDzYe6HdexXtHuxe85umshfPHfnmLSkGWl/FE27+|v+50mwY5XaNnCmo1VvGju4iTKxWoZTGgslUSc8KX197XWAXIpab8ESyg442if9Kr|vSOuu0fopwvvTOgHK8mkEWI4joU5G4/MQy+pnC5NIEVBP4HtGiTrAgEC",
     schmorp1539 => "MIHHAoHBByJzpVGUsXysX8w/+uuXRUCL9exhAixoHkaJU5lf4noJUtp9F0yr/5rb|hF8M9mSZJ+RlPyB+Zt37GPp1WQDO1+/2yZJX9kHE3+h5JCRoR8PKc2G+ts9jhM7r|CnTQ0z0b6s12Pusf+UhQPwLust4JAYE/LPuTK8yFiVx5L2a+aZhGMVlYN/12SEtY|jRl3lGXdZj9g8E2PzTQbA9CGy5dGIvz/ENTzTVleKuQ+80bzpVEPjZL9tv43Zc+l|MFLzxuE5uwIBAg==",
     schmorp2048 => "MIIBCAKCAQEAhR5Fn9h3Tgnc+q4o3CMkZtre3lLUyDT+1bf3aiVOt22JdDQndZLc|FeKz8AqliB3UIgNExc6oDtuG4znKPgklfOnHv/a9tl1AYQbV+QFM/E0jYl6oG8tF|Epgxezt1GCivvtu64ql0s213wr64QffNMt3hva8lNqK1PXfqp13PzzLzAVsfghrv|fMAX7/bYm1T5fAJdcah6FeZkKof+mqbs8HtRjfvrUF2npEM2WdupFu190vcwABnN|TTJheXCWv2BF2f9EEr61q3OUhSNWIThtZP+NKe2bACm1PebT0drAcaxKoMz9LjKr|y5onGs0TOuQ7JmhtZL45Zr4LwBcyTucLUwIBAg==",
     schmorp4096 => "MIICCAKCAgEA5WwA5lQg09YRYqc/JILCd2AfBmYBkF19wmCEJB8G3JhTxv8EGvYk|xyP2ecKVUvHTG8Xw/qpW8nRqzPIyV8QRf6YFYSf33Qnx2xYhcnqOumU3nfC0SNOL|/w2q1BA9BbHtW4574P+6hOQx9ftRtbtZ2HPKBMRcAKGjpYZiKopv0+UAM4NpEC2p|bfajp7pyVLeb/Aqm/oWP3L63wPlY1SDp+XRzrOAKB+/uLGqEwV0bBaxxGL29BpOp|O2z1ALGXiDCcLs9WTn9WqUhWDzUN6fahm53rd7zxwpFCb6K2YhaK0peG95jzSUJ8|aoL0KgWuC6v5+gPJHRu0HrQIdfAdN4VchqYOKE46uNNkQl8VJGu4RjYB7lFBpRwO|g2HCsGMo2X7BRmA1st66fh+JOd1smXMZG/2ozTOooL+ixcx4spNneg4aQerWl5cb|nWXKtPCp8yPzt/zoNzL3Fon2Ses3sNgMos0M/ZbnigScDxz84Ms6V/X8Z0L4m/qX|mL42dP40tgvmgqi6BdsBzcIWeHlEcIhmGcsEBxxKEg7gjb0OjjvatpUCJhmRrGjJ|LtMkBR68qr42OBMN/PBB4KPOWNUqTauXZajfCwYdbpvV24ZhtkcRdw1zisyARBSh|aTKW/GV8iLsUzlYN27LgVEwMwnWQaoecW6eOTNKGUURC3In6XZSvVzsCAQI=",
     schmorp8192 => "MIIECAKCBAEA/SAEbRSSLenVxoInHiltm/ztSwehGOhOiUKfzDcKlRBZHlCC9jBl|S/aeklM6Ucg8E6J2bnfoh6CAdnE/glQOn6CifhZr8X/rnlL9/eP+r9m+aiAw4l0D|MBd8BondbEqwTZthMmLtx0SslnevsFAZ1Cj8WgmUNaSPOukvJ1N7aQ98U+E99Pw3|VG8ANBydXqLqW2sogS8FtZoMbVywcQuaGmC7M6i3Akxe3CCSIpR/JkEZIytREBSC|CH+x3oW/w+wHzq3w8DGB9hqz1iMXqDMiPIMSdXC0DaIPokLnd7X8u6N14yCAco2h|P0gspD3J8pS2FpUY8ZTVjzbVCjhNNmTryBZAxHSWBuX4xYcCHUtfGlUe/IGLSVE1|xIdFpZUfvlvAJjVq0/TtDMg3r2JSXrhQVlr8MPJwSApDVr5kOBHT/uABio4z+5yR|PAvundznfyo9GGAWhIA36GQqsxSQfoRTjWssFoR/cu+9aomRwwOLkvObu8nCVVLH|nLdKDk5cIR0TvNs9HZ6ZmkzL7ah7cPzEKl7U6eE6yZLVYMNecnPLS6PSAIG4gxcq|CVQrrZjQLfTDrJn0OGgpShX85RaDsuiRtp2bpDZ23YDqdwr4wRjvIargjqc2zcF+|jIb7dUS6ci7bVG/CGOQUuiMWAiXZ3a1f343SMf9A05/sf1xwnMeco6STBLZ3X+PA|4urU+grtpWaFtS/fPD2ILn8nrJ3WuSKKUeSnVM46mmJQsOkyn7z8l3jNLB17GYKo|qc+0UuU/2PM9qtZdZElSM/ACLV2vdCuaibop4B9UIP9z3F8kfZ72+zKxpGiE+Bo1|x8SfG8FQw90mYIx+qZzJ8MCvc2wh+l4wDX5KxrhwvcouE2tHQlwfDgv/DiIXp173|hAmUCV0+bPRW8IIJvBODdAWtJe9hNwxj1FFYmPA7l4wa3gXV4I6tb+iO1MbwVjZ/|116tD5MdCo3JuSisgPYCHfkQccwEO0FHEuBbmfN+fQimQ8H0dePP8XctwbkplsB+|aLT5hYKmva/j9smEswgyHglPwc3WvZ+2DgKk7A7DHi7a2gDwCRQlHaXtNWx3992R|dfNgkSeB1CvGSQoo95WpC9ZoqGmcSlVqdetDU8iglPmfYTKO8aIPA6TuTQ/lQ0IW|90LQmqP23FwnNFiyqX8+rztLq4KVkTyeHIQwig6vFxgD8N+SbZCW2PPiB72TVF2U|WePU8MRTv1OIGBUBajF49k28HnZPSGlILHtFEkYkbPvomcE5ENnoejwzjktOTS5d|/R3SIOvCauOzadtzwTYOXT78ORaR1KI1cm8DzkkwJTd/Rrk07Q5vnvnSJQMwFUeH|PwJIgWBQf/GZ/OsDHmkbYR2ZWDClbKw2mwIBAg==",
  
     # finite field dhe parameters, some taken from firefox, some directly from RFC 7919
     ffdhe2048 => "MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaD ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg==",
     ffdhe3072 => "MIIBiAKCAYEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaDssbzSibBsu/6iGtCOGEfz9zeNVs7ZRkDW7w09N75nAI4YbRvydbmyQd62R0mkff37lmMsPrBhtkcrv4TCYUTknC0EwyTvEN5RPT9RFLi103TZPLiHnH1S/9croKrnJ32nuhtK8UiNjoNq8Uhl5sN6todv5pC1cRITgq80Gv6U93vPBsg7j/VnXwl5B0rZsYuN///////////AgEC",
     ffdhe4096 => "MIICCAKCAgEA///////////JD9qiIWjCNMTGYouA3BzRKQJOCIpnzHQCC76mOxObIlFKCHmONATd75UZs806QxswKwpt8l8UN0/hNW1tUcJF5IW1dmJefsb0TELppjftawv/XLb0Brft7jhr+1qJn6WunyQRfEsf5kkoZlHs5Fs9wgB8uKFjvwWY2kg2HFXTmmkWP6j9JM9fg2VdI9yjrZYcYvNWIIVSu57VKQdwlpZtZww1Tkq8mATxdGwIyhghfDKQXkYuNs474553LBgOhgObJ4Oi7Aeij7XFXfBvTFLJ3ivL9pVYFxg5lUl86pVq5RXSJhiY+gUQFXKOWoqqxC2tMxcNBFB6M6hVIavfHLpk7PuFBFjb7wqK6nFXXQYMfbOXD4Wm4eTHq/WujNsJM9cejJTgSiVhnc7j0iYa0u5r8S/6BtmKCGTYdgJzPshqZFIfKxgXeyAMu+EXV3phXWx3CYjAutlG4gjiT6B05asxQ9tb/OD9EI5LgtEgqSEIARpyPBKnh+bXiHGaEL26WyaZwycYavTiPBqUaDS2FQvaJYPpyirUTOjbu8LbBN6O+S6O/BQfvsqmKHxZR05rwF2ZspZPoJDDoiM7oYZRW+ftH2EpcM7i16+4G912IXBIHNAGkSfVsFqpk7TqmI2P3cGG/7fckKbAj030Nck0BjGZ//////////8CAQI=",
     ffdhe6144 =>
     "MIIDCAKCAwEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaDssbzSibBsu/6iGtCOGEfz9zeNVs7ZRkDW7w09N75nAI4YbRvydbmyQd62R0mkff37lmMsPrBhtkcrv4TCYUTknC0EwyTvEN5RPT9RFLi103TZPLiHnH1S/9croKrnJ32nuhtK8UiNjoNq8Uhl5sN6todv5pC1cRITgq80Gv6U93vPBsg7j/VnXwl5B0rZp4e8W5vUsMWTfT7eTDp5OWIV7asfV9C1p9tGHdjzx1VA0AEh/VbpX4xzHpxNciG77Qxiu1qHgEtnmgyqQdgCpGBMMRtx3j5ca0AOAkpmaMzy4t6Gh25PXFAADwqTs6p+Y0KzAqCkc3OyX3Pjsm1Wn+IpGtNtahR9EGC4caKAH5eDdkCC/1ktkUDbHpOZ30sOFMqOiO6RELK9T6mO7RUMpt2JMiRe91kscD9TLOOjDNMcBw6za0GV/zP7HGbH1w+TkYEHziBR/tM/bR3pSRx96mpaRC4VTIu22NA2KAO8JI1BRHjCr7B//njom5/sp+MGDAjw1h+ONoAd9m0dj5OS5Syu8GUxmUed8r5ku6qwCMqKBv2s6c5wSJhFoIK6NtYR6Z8vvnJCRtGLVOM1ysDdGrnf15iKSwxFWKoRlBdyC24VDOK5J9SNclbkReMzy3Vys70A+ydGBDGJysEWztx+dxrgNY/3UqOmtseaWKmlSbUMWHBpB1XDXk42tSkDjKc0OQOZf//////////AgEC",
     ffdhe8192 => "MIIECAKCBAEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaDssbzSibBsu/6iGtCOGEfz9zeNVs7ZRkDW7w09N75nAI4YbRvydbmyQd62R0mkff37lmMsPrBhtkcrv4TCYUTknC0EwyTvEN5RPT9RFLi103TZPLiHnH1S/9croKrnJ32nuhtK8UiNjoNq8Uhl5sN6todv5pC1cRITgq80Gv6U93vPBsg7j/VnXwl5B0rZp4e8W5vUsMWTfT7eTDp5OWIV7asfV9C1p9tGHdjzx1VA0AEh/VbpX4xzHpxNciG77Qxiu1qHgEtnmgyqQdgCpGBMMRtx3j5ca0AOAkpmaMzy4t6Gh25PXFAADwqTs6p+Y0KzAqCkc3OyX3Pjsm1Wn+IpGtNtahR9EGC4caKAH5eDdkCC/1ktkUDbHpOZ30sOFMqOiO6RELK9T6mO7RUMpt2JMiRe91kscD9TLOOjDNMcBw6za0GV/zP7HGbH1w+TkYEHziBR/tM/bR3pSRx96mpaRC4VTIu22NA2KAO8JI1BRHjCr7B//njom5/sp+MGDAjw1h+ONoAd9m0dj5OS5Syu8GUxmUed8r5ku6qwCMqKBv2s6c5wSJhFoIK6NtYR6Z8vvnJCRtGLVOM1ysDdGrnf15iKSwxFWKoRlBdyC24VDOK5J9SNclbkReMzy3Vys70A+ydGBDGJysEWztx+dxrgNY/3UqOmtseaWKmlSbUMWHBpB1XDXk42tSkDjKcz/RqqjatAEz2AMg4HkJaMdlRrmT9sj/OyVCdQ2h/62nt0cxeC4zDvfZLEO+GtjFCo6uIKVVbL3R8kyZlyywPHMAb1wIpOIg50q8F5FRQSseLdYKCKEbAujXDX1xZFgzARv2CUVQfxoychrAiu3CZh2pGDnRRqKkxCXA/7hwhfmw4JuUsUappHg5CPPyZ6eMWUMEhe2JIFs2tmpX51bgBlIjZwKCh/jB1pXfiMYP4HUo/L6RXHvyM4LqKT+i2hV3+crCmbt7S+6v75Yow+vq+HF1xqH4vdB74wf6G/qa7/eUwZ38Nl9EdSfeoRD0IIuUGqfRhTgEeKpSDj/iM1oyLt8XGQkz//////////wIBAg==",
  );
  
  =item $tls = new AnyEvent::TLS key => value...
  
  The constructor supports these arguments (all as key => value pairs).
  
  =over 4
  
  =item method => "SSLv2" | "SSLv3" | "TLSv1" | "TLSv1_1" | "TLSv1_2" | "any"
  
  The protocol parser to use. C<SSLv2>, C<SSLv3>, C<TLSv1>, C<TLSv1_1>
  and C<TLSv1_2> will use a parser for those protocols only (so will
  I<not> accept or create connections with/to other protocol versions),
  while C<any> (the default) uses a parser capable of all three
  protocols.
  
  The default is to use C<"any"> but disable SSLv2. This has the effect of
  sending a SSLv2 hello, indicating the support for SSLv3 and TLSv1, but not
  actually negotiating an (insecure) SSLv2 connection.
  
  Specifying a specific version is almost always wrong to use for a server
  speaking to a wide variety of clients (e.g. web browsers), and often wrong
  for a client. If you only want to allow a specific protocol version, use
  the C<sslv2>, C<sslv3>, C<tlsv1>, C<tlsv1_1> or C<tlsv1_2> arguments instead.
  
  For new services it is usually a good idea to enforce a C<TLSv1> method
  from the beginning.
  
  C<TLSv1_1> and C<TLSv1_2> require L<Net::SSLeay> >= 1.55 and OpenSSL
  >= 1.0.1. Check the L<Net::SSLeay> and OpenSSL documentations for more
  details.
  
  =item sslv2 => $enabled
  
  Enable or disable SSLv2 (normally I<disabled>).
  
  =item sslv3 => $enabled
  
  Enable or disable SSLv3 (normally I<enabled>).
  
  =item tlsv1 => $enabled
  
  Enable or disable TLSv1 (normally I<enabled>).
  
  =item tlsv1_1 => $enabled
  
  Enable or disable TLSv1_1 (normally I<enabled>).
  
  This requires L<Net::SSLeay> >= 1.55 and OpenSSL >= 1.0.1. Check the
  L<Net::SSLeay> and OpenSSL documentations for more details.
  
  =item tlsv1_2 => $enabled
  
  Enable or disable TLSv1_2 (normally I<enabled>).
  
  This requires L<Net::SSLeay> >= 1.55 and OpenSSL >= 1.0.1. Check the
  L<Net::SSLeay> and OpenSSL documentations for more details.
  
  =item verify => $enable
  
  Enable or disable peer certificate checking (default is I<disabled>, which
  is I<not recommended>).
  
  This is the "master switch" for all verify-related parameters and
  functions.
  
  If it is disabled, then no peer certificate verification will be done
  - the connection will be encrypted, but the peer certificate won't be
  verified against any known CAs, or whether it is still valid or not. No
  peername verification or custom verification will be done either.
  
  If enabled, then the peer certificate (required in client mode, optional
  in server mode, see C<verify_require_client_cert>) will be checked against
  its CA certificate chain - that means there must be a signing chain from
  the peer certificate to any of the CA certificates you trust locally, as
  specified by the C<ca_file> and/or C<ca_path> and/or C<ca_cert> parameters
  (or the system default CA repository, if all of those parameters are
  missing - see also the L<AnyEvent> manpage for the description of
  PERL_ANYEVENT_CA_FILE).
  
  Other basic checks, such as checking the validity period, will also be
  done, as well as optional peername/hostname/common name verification
  C<verify_peername>.
  
  An optional C<verify_cb> callback can also be set, which will be invoked
  with the verification results, and which can override the decision.
  
  =item verify_require_client_cert => $enable
  
  Enable or disable mandatory client certificates (default is
  I<disabled>). When this mode is enabled, then a client certificate will be
  required in server mode (a server certificate is mandatory, so in client
  mode, this switch has no effect).
  
  =item verify_peername => $scheme | $callback->($tls, $cert, $peername)
  
  TLS only protects the data that is sent - it cannot automatically verify
  that you are really talking to the right peer. The reason is that
  certificates contain a "common name" (and a set of possible alternative
  "names") that need to be checked against the peername (usually, but not
  always, the DNS name of the server) in a protocol-dependent way.
  
  This can be implemented by specifying a callback that has to verify that
  the actual C<$peername> matches the given certificate in C<$cert>.
  
  Since this can be rather hard to implement, AnyEvent::TLS offers a variety
  of predefined "schemes" (lifted from L<IO::Socket::SSL>) that are named
  like the protocols that use them:
  
  =over 4
  
  =item ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)
  
  Simple wildcards in subjectAltNames are possible, e.g. *.example.org
  matches www.example.org but not lala.www.example.org. If nothing from
  subjectAltNames matches, it checks against the common name, but there are
  no wildcards allowed.
  
  =item http (rfc2818)
  
  Extended wildcards in subjectAltNames are possible, e.g. *.example.org or
  even www*.example.org. Wildcards in the common name are not allowed. The
  common name will be only checked if no host names are given in
  subjectAltNames.
  
  =item smtp (rfc3207)
  
  This RFC isn't very useful in determining how to do verification so it
  just assumes that subjectAltNames are possible, but no wildcards are
  possible anywhere.
  
  =item [$wildcards_in_alt, $wildcards_in_cn, $check_cn]
  
  You can also specify a scheme yourself by using an array reference with
  three integers.
  
  C<$wildcards_in_alt> and C<$wildcards_in_cn> specify whether and where
  wildcards (C<*>) are allowed in subjectAltNames and the common name,
  respectively. C<0> means no wildcards are allowed, C<1> means they
  are allowed only as the first component (C<*.example.org>), and C<2>
  means they can be used anywhere (C<www*.example.org>), except that very
  dangerous matches will not be allowed (C<*.org> or C<*>).
  
  C<$check_cn> specifies if and how the common name field is checked: C<0>
  means it will be completely ignored, C<1> means it will only be used if
  no host names have been found in the subjectAltNames, and C<2> means the
  common name will always be checked against the peername.
  
  =back
  
  You can specify either the name of the parent protocol (recommended,
  e.g. C<http>, C<ldap>), the protocol name as usually used in URIs
  (e.g. C<https>, C<ldaps>) or the RFC (not recommended, e.g. C<rfc2995>,
  C<rfc3920>).
  
  This verification will only be done when verification is enabled (C<<
  verify => 1 >>).
  
  =item verify_cb => $callback->($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)
  
  Provide a custom peer verification callback used by TLS sessions,
  which is called with the result of any other verification (C<verify>,
  C<verify_peername>).
  
  This callback will only be called when verification is enabled (C<< verify
  => 1 >>).
  
  C<$tls> is the C<AnyEvent::TLS> object associated with the session,
  while C<$ref> is whatever the user associated with the session (usually
  an L<AnyEvent::Handle> object when used by AnyEvent::Handle).
  
  C<$depth> is the current verification depth - C<$depth = 0> means the
  certificate to verify is the peer certificate, higher levels are its CA
  certificate and so on. In most cases, you can just return C<$preverify_ok>
  if the C<$depth> is non-zero:
  
     verify_cb => sub {
        my ($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert) = @_;
  
        return $preverify_ok
           if $depth;
  
        # more verification
     },
  
  C<$preverify_ok> is true iff the basic verification of the certificates
  was successful (a valid CA chain must exist, the certificate has passed
  basic validity checks, peername verification succeeded).
  
  C<$x509_store_ctx> is the Net::SSLeay::X509_CTX> object.
  
  C<$cert> is the C<Net::SSLeay::X509> object representing the
  peer certificate, or zero if there was an error. You can call
  C<AnyEvent::TLS::certname $cert> to get a nice user-readable string to
  identify the certificate.
  
  The callback must return either C<0> to indicate failure, or C<1> to
  indicate success.
  
  =item verify_client_once => $enable
  
  Enable or disable skipping the client certificate verification on
  renegotiations (default is I<disabled>, the certificate will always be
  checked). Only makes sense in server mode.
  
  =item ca_file => $path
  
  If this parameter is specified and non-empty, it will be the path to a
  file with (server) CA certificates in PEM format that will be loaded. Each
  certificate will look like:
  
     -----BEGIN CERTIFICATE-----
     ... (CA certificate in base64 encoding) ...
     -----END CERTIFICATE-----
  
  You have to enable verify mode (C<< verify => 1 >>) for this parameter to
  have any effect.
  
  =item ca_path => $path
  
  If this parameter is specified and non-empty, it will be
  the path to a directory with hashed CA certificate files in
  PEM format. When the ca certificate is being verified, the
  certificate will be hashed and looked up in that directory (see
  L<http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html> for
  details)
  
  The certificates specified via C<ca_file> take precedence over the ones
  found in C<ca_path>.
  
  You have to enable verify mode (C<< verify => 1 >>) for this parameter to
  have any effect.
  
  =item ca_cert => $string
  
  In addition or instead of using C<ca_file> and/or C<ca_path>, you can
  also use C<ca_cert> to directly specify the CA certificates (there can be
  multiple) in PEM format, in a string.
  
  =item check_crl => $enable
  
  Enable or disable certificate revocation list checking. If enabled, then
  peer certificates will be checked against a list of revoked certificates
  issued by the CA. The revocation lists will be expected in the C<ca_path>
  directory.
  
  certificate verification will fail if this is enabled but no revocation
  list was found.
  
  This requires OpenSSL >= 0.9.7b. Check the OpenSSL documentation for more
  details.
  
  =item key_file => $path
  
  Path to the local private key file in PEM format (might be a combined
  certificate/private key file).
  
  The local certificate is used to authenticate against the peer - servers
  mandatorily need a certificate and key, clients can use a certificate and
  key optionally to authenticate, e.g. for log-in purposes.
  
  The key in the file should look similar this:
  
     -----BEGIN RSA PRIVATE KEY-----
     ...header data
     ... (key data in base64 encoding) ...
     -----END RSA PRIVATE KEY-----
  
  =item key => $string
  
  The private key string in PEM format (see C<key_file>, only one of
  C<key_file> or C<key> can be specified).
  
  The idea behind being able to specify a string is to avoid blocking in
  I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
  needed OpenSSL functionality, this is currently implemented by writing to
  a temporary file.
  
  =item cert_file => $path
  
  The path to the local certificate file in PEM format (might be a combined
  certificate/private key file, including chained certificates).
  
  The local certificate (and key) are used to authenticate against the
  peer - servers mandatorily need a certificate and key, clients can use
  certificate and key optionally to authenticate, e.g. for log-in purposes.
  
  The certificate in the file should look like this:
  
     -----BEGIN CERTIFICATE-----
     ... (certificate in base64 encoding) ...
     -----END CERTIFICATE-----
  
  If the certificate file or string contain both the certificate and
  private key, then there is no need to specify a separate C<key_file> or
  C<key>.
  
  Additional signing certifiates to send to the peer (in SSLv3 and newer)
  can be specified by appending them to the certificate proper: the order
  must be from issuer certificate over any intermediate CA certificates to
  the root CA.
  
  So the recommended ordering for a combined key/cert/chain file, specified
  via C<cert_file> or C<cert> looks like this:
  
    certificate private key
    client/server certificate
    ca 1, signing client/server certficate
    ca 2, signing ca 1
    ...
  
  =item cert => $string
  
  The local certificate in PEM format (might be a combined
  certificate/private key file). See C<cert_file>.
  
  The idea behind being able to specify a string is to avoid blocking in
  I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
  needed OpenSSL functionality, this is currently implemented by writing to
  a temporary file.
  
  =item cert_password => $string | $callback->($tls)
  
  The certificate password - if the certificate is password-protected, then
  you can specify its password here.
  
  Instead of providing a password directly (which is not so recommended),
  you can also provide a password-query callback. The callback will be
  called whenever a password is required to decode a local certificate, and
  is supposed to return the password.
  
  =item dh_file => $path
  
  Path to a file containing Diffie-Hellman parameters in PEM format, for
  use in servers. See also C<dh> on how to specify them directly, or use a
  pre-generated set.
  
  Diffie-Hellman key exchange generates temporary encryption keys that
  are not transferred over the connection, which means that even if the
  certificate key(s) are made public at a later time and a full dump of the
  connection exists, the key still cannot be deduced.
  
  These ciphers are only available with SSLv3 and later (which is the
  default with AnyEvent::TLS), and are only used in server/accept
  mode. Anonymous DH protocols are usually disabled by default, and usually
  not even compiled into the underlying library, as they provide no direct
  protection against man-in-the-middle attacks. The same is true for the
  common practise of self-signed certificates that you have to accept first,
  of course.
  
  =item dh => $string
  
  Specify the Diffie-Hellman parameters in PEM format directly as a string
  (see C<dh_file>), the default is C<ffdhe3072> unless C<dh_file> was
  specified.
  
  AnyEvent::TLS supports supports a number of precomputed DH parameters,
  since computing them is expensive. They are:
  
     # from RFC 7919 - recommended
     ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192
  
     # from "Assigned Number for SKIP Protocols"
     skip512, skip1024, skip2048, skip4096
  
     # from schmorp
     schmorp1024, schmorp1539, schmorp2048, schmorp4096, schmorp8192
  
  It is said that 2048 bit DH parameters are safe till 2030, and DH
  parameters shorter than 900 bits are totally insecure.
  
  To disable DH protocols completely, specify C<undef> as C<dh> parameter.
  
  =item dh_single_use => $enable
  
  Enables or disables "use only once" mode when using Diffie-Hellman key
  exchange. When enabled (default), each time a new key is exchanged a new
  Diffie-Hellman key is generated, which improves security as each key is
  only used once. When disabled, the key will be created as soon as the
  AnyEvent::TLS object is created and will be reused.
  
  All the DH parameters supplied with AnyEvent::TLS should be safe with
  C<dh_single_use> switched off, but YMMV.
  
  =item cipher_list => $string
  
  The list of ciphers to use, as a string (example:
  C<AES:ALL:!aNULL:!eNULL:+RC4:@STRENGTH>). The format
  of this string and its default value is documented at
  L<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>.
  
  =item session_ticket => $enable
  
  Enables or disables RC5077 support (Session Resumption without Server-Side
  State). The default is disabled for clients, as many (buggy) TLS/SSL
  servers choke on it, but enabled for servers.
  
  When enabled and supported by the server, a session ticket will be
  provided to the client, which allows fast resuming of connections.
  
  =item prepare => $coderef->($tls)
  
  If this argument is present, then it will be called with the new
  AnyEvent::TLS object after any other initialisation has bee done, in case
  you wish to fine-tune something...
  
  =cut
  
  #=item trust => $trust
  #
  #Sets the expected (root) certificate use on this context, i.e. what 
  #certificates to trust. The default is C<compat>, and the following strings
  #are supported:
  #
  #   compat          any certifictae will do
  #   ssl_client      only trust client certificates
  #   ssl_server      only trust server certificates
  #   email           only trust e-mail certificates
  #   object_sign     only trust signing (CA) certificates
  #   ocsp_sign       only trust ocsp signing certs
  #   ocsp_request    only trust ocsp request certs
  
  # purpose?
  
  #TODO
  # verify_depth?
  # reuse_ctx
  # session_cache_size
  # session_cache
  
  #=item debug => $level
  #
  #Enable or disable sending debugging output to STDERR. This is, as
  #the name says, mostly for debugging. The default is taken from the
  #C<PERL_ANYEVENT_TLS_DEBUG> environment variable.
  #
  #=cut
  
  =back
  
  =cut
  
  sub init ();
  
  #our %X509_TRUST = (
  #   compat       => 1,
  #   ssl_client   => 2,
  #   ssl_server   => 3,
  #   email        => 4,
  #   object_sign  => 5,
  #   ocsp_sign    => 6,
  #   ocsp_request => 7,
  #);
  
  BEGIN {
     eval 'sub _check_tls_gt_1 (){'
        . (($Net::SSLeay::VERSION >= 1.55 && Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x1000100f) * 1)
        . '}';
  
     # as of this writing, Net::SSLeay (1.85-2) has not been ported to OpenSSL 1.1,
     # but many distributions and users compile it against openssl 1.1, leading to
     # many symbols not being defined because they are now enums instead of macros
     # and have different prefixes.
     # The only one we use is SSL_ST_OK, or TLS_ST_OK, which should be available
     # as Net::SSLeay::ST_OK. If it is not callable, we define it to be 1, which
     # hopefully will not change.
     eval 'Net::SSLeay::ST_OK (); 1'
        or *Net::SSLeay::ST_OK = sub () { 1 };
  }
  
  our %SSL_METHODS = (
     any     => \&Net::SSLeay::CTX_new,
     sslv23  => \&Net::SSLeay::CTX_new, # deliberately undocumented
     sslv2   => \&Net::SSLeay::CTX_v2_new,
     sslv3   => \&Net::SSLeay::CTX_v3_new,
     tlsv1   => \&Net::SSLeay::CTX_tlsv1_new,
  );
  
  # Add TLSv1_1 and TLSv1_2 if Net::SSLeay and openssl allow them
  if (_check_tls_gt_1) {
     $SSL_METHODS{tlsv1_1} = \&Net::SSLeay::CTX_tlsv1_1_new;
     $SSL_METHODS{tlsv1_2} = \&Net::SSLeay::CTX_tlsv1_2_new;
  } else {
     for my $method (qw(tlsv1_1 tlsv1_2)) {
        $SSL_METHODS{$method} = sub { croak "AnyEvent::TLS method '$method' requires openssl v1.0.1 and Net::SSLeay 1.55 or higher" };
     }
  }
  
  sub new {
     my ($class, %arg) = @_;
  
     init unless $REF_IDX;
  
     my $method = lc $arg{method} || "any";
  
     my $ctx = ($SSL_METHODS{$method}
                || croak "'$method' is not a valid AnyEvent::TLS method (must be one of @{[ sort keys %SSL_METHODS ]})")->();
  
     my $self = bless { ctx => $ctx }, $class; # to make sure it's destroyed if we croak
  
     my $op = Net::SSLeay::OP_ALL ();
  
     $op |= Net::SSLeay::OP_NO_SSLv2      () unless $arg{sslv2};
     $op |= Net::SSLeay::OP_NO_SSLv3      () if exists $arg{sslv3} && !$arg{sslv3};
     $op |= Net::SSLeay::OP_NO_TLSv1      () if exists $arg{tlsv1} && !$arg{tlsv1};
     $op |= Net::SSLeay::OP_NO_TLSv1_1    () if exists $arg{tlsv1_1} && !$arg{tlsv1_1} && _check_tls_gt_1;
     $op |= Net::SSLeay::OP_NO_TLSv1_2    () if exists $arg{tlsv1_2} && !$arg{tlsv1_2} && _check_tls_gt_1;
     $op |= Net::SSLeay::OP_SINGLE_DH_USE () if !exists $arg{dh_single_use} || $arg{dh_single_use};
  
     Net::SSLeay::CTX_set_options ($ctx, $op);
  
     Net::SSLeay::CTX_set_cipher_list ($ctx, $arg{cipher_list})
        or croak "'$arg{cipher_list}' was not accepted as a valid cipher list by AnyEvent::TLS"
           if exists $arg{cipher_list};
  
     my ($dh_bio, $dh_file);
  
     if (exists $arg{dh_file}) {
        $dh_file = $arg{dh_file};
  
        $dh_bio = Net::SSLeay::BIO_new_file ($dh_file, "r")
           or croak "$dh_file: failed to open DH parameter file: $!";
     } else {
        $arg{dh} = "ffdhe3072" unless exists $arg{dh};
  
        if (defined $arg{dh}) {
           $dh_file = "dh string";
  
           if ($arg{dh} =~ /^\w+$/) {
              $dh_file = "dh params $arg{dh}";
              $arg{dh} = "-----BEGIN DH PARAMETERS-----\n"
                       . (join "\n", unpack "(a74)*", $DH_PARAMS{$arg{dh}}) . "\n"
                       . "-----END DH PARAMETERS-----";
              $arg{dh} =~ s/\|/\n/g;
           }
  
           $dh_bio = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
           Net::SSLeay::BIO_write ($dh_bio, $arg{dh});
        }
     }
  
     if ($dh_bio) {
        my $dh = Net::SSLeay::PEM_read_bio_DHparams ($dh_bio);
        Net::SSLeay::BIO_free ($dh_bio);
        $dh or croak "$dh_file: failed to parse DH parameters - not PEM format?";
        my $rv = Net::SSLeay::CTX_set_tmp_dh ($ctx, $dh);
        Net::SSLeay::DH_free ($dh);
        $rv or croak "$dh_file: failed to set DH parameters";
     }
  
     if ($arg{verify}) {
        $self->{verify_mode} = Net::SSLeay::VERIFY_PEER ();
  
        $self->{verify_mode} |= Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT ()
           if $arg{verify_require_client_cert};
  
        $self->{verify_mode} |= Net::SSLeay::VERIFY_CLIENT_ONCE ()
           if $arg{verify_client_once};
  
     } else {
        $self->{verify_mode} = Net::SSLeay::VERIFY_NONE ();
     }
  
     $self->{verify_peername} = $arg{verify_peername}
        if exists $arg{verify_peername};
  
     $self->{verify_cb} = $arg{verify_cb}
        if exists $arg{verify_cb};
  
     $self->{session_ticket} = $arg{session_ticket}
        if exists $arg{session_ticket};
  
     $self->{debug} = $ENV{PERL_ANYEVENT_TLS_DEBUG}
        if length $ENV{PERL_ANYEVENT_TLS_DEBUG};
  
     $self->{debug} = $arg{debug}
        if exists $arg{debug};
  
     my $pw = $arg{cert_password};
     Net::SSLeay::CTX_set_default_passwd_cb ($ctx, ref $pw ? $pw : sub { $pw });
  
     if ($self->{verify_mode}) {
        if (exists $arg{ca_file} or exists $arg{ca_path} or exists $arg{ca_cert}) {
           # either specified: use them
           if (exists $arg{ca_cert}) {
              my ($ca_file, $g1) = _tmpfile delete $arg{ca_cert};
              Net::SSLeay::CTX_load_verify_locations ($ctx, $ca_file, undef);
           }
           if (exists $arg{ca_file} or exists $arg{ca_path}) {
              Net::SSLeay::CTX_load_verify_locations ($ctx, $arg{ca_file}, $arg{ca_path});
           }
        } elsif (length $ENV{PERL_ANYEVENT_CA_FILE} or length $ENV{PERL_ANYEVENT_CA_PATH}) {
           Net::SSLeay::CTX_load_verify_locations (
              $ctx,
              $ENV{PERL_ANYEVENT_CA_FILE},
              $ENV{PERL_ANYEVENT_CA_PATH},
           );
        } else {
           # else fall back to defaults
           Net::SSLeay::CTX_set_default_verify_paths ($ctx);
        }
     }
  
     if (exists $arg{cert} or exists $arg{cert_file}) {
        my ($g1, $g2);
  
        if (exists $arg{cert}) {
           croak "specifying both cert_file and cert is not allowed"
              if exists $arg{cert_file};
  
          ($arg{cert_file}, $g1) = _tmpfile delete $arg{cert};
        }
  
        if (exists $arg{key} or exists $arg{key_file}) {
           if (exists $arg{key}) {
              croak "specifying both key_file and key is not allowed"
                 if exists $arg{key_file};
             ($arg{key_file}, $g2) = _tmpfile delete $arg{key};
           }
        } else {
           $arg{key_file} = $arg{cert_file};
        }
  
        Net::SSLeay::CTX_use_PrivateKey_file
              ($ctx, $arg{key_file}, Net::SSLeay::FILETYPE_PEM ())
           or croak "$arg{key_file}: failed to load local private key (key_file or key)";
  
        Net::SSLeay::CTX_use_certificate_chain_file ($ctx, $arg{cert_file})
           or croak "$arg{cert_file}: failed to use local certificate chain (cert_file or cert)";
     }
  
     if ($arg{check_crl}) {
        Net::SSLeay::OPENSSL_VERSION_NUMBER () >= 0x00090702f
           or croak "check_crl requires openssl v0.9.7b or higher";
  
        Net::SSLeay::X509_STORE_set_flags (
           Net::SSLeay::CTX_get_cert_store ($ctx),
           Net::SSLeay::X509_V_FLAG_CRL_CHECK ());
     }
  
     Net::SSLeay::CTX_set_read_ahead ($ctx, 1);
  
     $arg{prepare}->($self)
        if $arg{prepare};
  
     $self
  }
  
  =item $tls = new_from_ssleay AnyEvent::TLS $ctx
  
  This constructor takes an existing L<Net::SSLeay> SSL_CTX object
  (which is just an integer) and converts it into an C<AnyEvent::TLS>
  object. This only works because AnyEvent::TLS is currently implemented
  using Net::SSLeay. As this is such a horrible perl module and OpenSSL has
  such an annoying license, this might change in the future, in which case
  this method might vanish.
  
  =cut
  
  sub new_from_ssleay {
     my ($class, $ctx) = @_;
  
     bless { ctx => $ctx }, $class
  }
  
  =item $ctx = $tls->ctx
  
  Returns the actual L<Net::SSLeay::CTX> object (just an integer).
  
  =cut
  
  sub ctx {
     $_[0]{ctx}
  }
  
  sub verify_hostname($$$);
  
  sub _verify_hostname {
     my ($self, $cn, $cert) = @_;
     
     return 1
        unless defined $cn;
  
     return 1
        unless exists $self->{verify_peername} && "none" ne lc $self->{verify_peername};
  
     return $self->{verify_peername}->($self, $cn, $cert)
        if ref $self->{verify_peername} && "ARRAY" ne ref $self->{verify_peername};
  
     verify_hostname $cn, $cert, $self->{verify_peername}
  }
  
  sub verify {
     my ($self, $session, $ref, $cn, $preverify_ok, $x509_store_ctx) = @_;
  
     my $cert = $x509_store_ctx
        ? Net::SSLeay::X509_STORE_CTX_get_current_cert ($x509_store_ctx)
        : undef;
     my $depth = Net::SSLeay::X509_STORE_CTX_get_error_depth ($x509_store_ctx);
  
     $preverify_ok &&= $self->_verify_hostname ($cn, $cert)
        unless $depth;
  
     $preverify_ok = $self->{verify_cb}->($self, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)
        if $self->{verify_cb};
  
     $preverify_ok
  }
  
  #=item $ssl = $tls->_get_session ($mode[, $ref])
  #
  #Creates a new Net::SSLeay::SSL session object, puts it into C<$mode>
  #(C<accept> or C<connect>) and optionally associates it with the given
  #C<$ref>. If C<$mode> is already a C<Net::SSLeay::SSL> object, then just
  #associate data with it.
  #
  #=cut
  
  #our %REF_MAP;
  our $TLS_SNI_WARNED;
  
  sub _get_session($$;$$) {
     my ($self, $mode, $ref, $cn) = @_;
  
     my $session;
  
     if ($mode eq "accept") {
        $session = Net::SSLeay::new ($self->{ctx});
        Net::SSLeay::set_accept_state ($session);
  
        Net::SSLeay::set_options ($session, eval { Net::SSLeay::OP_NO_TICKET () })
           unless $self->{session_ticket} || !exists $self->{session_ticket};
  
     } elsif ($mode eq "connect") {
        $session = Net::SSLeay::new ($self->{ctx});
  
        if (defined &Net::SSLeay::set_tlsext_host_name) {
           Net::SSLeay::set_tlsext_host_name ($session, $cn)
              if length $cn;
        } else {
           AE::log 6 => "TLS SNI not supported by your Net::SSLeay module, connecting without"
              unless $TLS_SNI_WARNED++;
        }
  
        Net::SSLeay::set_connect_state ($session);
  
        Net::SSLeay::set_options ($session, eval { Net::SSLeay::OP_NO_TICKET () })
           unless $self->{session_ticket};
     } else {
        croak "'$mode': unsupported TLS mode (must be either 'connect' or 'accept')"
     }
  
  #   # associate data
  #   Net::SSLeay::set_ex_data ($session, $REF_IDX, $ref+0);
  #   Scalar::Util::weaken ($REF_MAP{$ref+0} = $ref)
  #      if ref $ref;
     
     if ($self->{debug}) {
        #d# Net::SSLeay::set_info_callback ($session, 50000);
     }
  
     if ($self->{verify_mode}) {
        Scalar::Util::weaken $self;
        Scalar::Util::weaken $ref;
  
        # we have to provide a dummy callbacks as at least Net::SSLeay <= 1.35
        # try to call it even if specified as 0 or undef.
        Net::SSLeay::set_verify
           $session,
           $self->{verify_mode},
           sub { $self->verify ($session, $ref, $cn, @_) };
     }
  
     $session
  }
  
  sub _put_session($$) {
     my ($self, $session) = @_;
  
     # clear callback, if any
     # this leaks memoryin Net::SSLeay up to at least 1.35, but there
     # apparently is no other way.
     Net::SSLeay::set_verify $session, 0, undef;
  
  #   # disassociate data
  #   delete $REF_MAP{Net::SSLeay::get_ex_data ($session, $REF_IDX)};
  
     Net::SSLeay::free ($session);
  }
  
  #sub _ref($) {
  #   $REF_MAP{Net::SSLeay::get_ex_data ($_[0], $REF_IDX)}
  #}
  
  sub DESTROY {
     my ($self) = @_;
  
     # better be safe than sorry with net-ssleay
     Net::SSLeay::CTX_set_default_passwd_cb ($self->{ctx});
  
     Net::SSLeay::CTX_free ($self->{ctx});
  }
  
  =item AnyEvent::TLS::init
  
  AnyEvent::TLS does on-demand initialisation, and normally there is no need to call an initialise
  function.
  
  As initialisation might take some time (to read e.g. C</dev/urandom>), this
  could be annoying in some highly interactive programs. In that case, you can
  call C<AnyEvent::TLS::init> to make sure there will be no costly initialisation
  later. It is harmless to call C<AnyEvent::TLS::init> multiple times.
  
  =cut
  
  sub init() {
     return if $REF_IDX;
  
     AE::log 5 => "Net::SSLeay versions older than 1.33 might malfunction."
        if $Net::SSLeay::VERSION < 1.33;
  
     Net::SSLeay::load_error_strings ();
     Net::SSLeay::SSLeay_add_ssl_algorithms ();
     Net::SSLeay::randomize ();
  
     $REF_IDX = Net::SSLeay::get_ex_new_index (0, 0, 0, 0, 0)
        until $REF_IDX; # Net::SSLeay uses id #0 for its own stuff without allocating it
  }
  
  =item $certname = AnyEvent::TLS::certname $x509
  
  Utility function that returns a user-readable string identifying the X509
  certificate object.
  
  =cut
  
  sub certname {
     $_[0]
        ? Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_issuer_name ($_[0]))
          . Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_subject_name ($_[0]))
        : undef
  }
  
  our %CN_SCHEME = (
     # each tuple is [$cn_wildcards, $alt_wildcards, $check_cn]
     # where *_wildcards is 0 for none allowed, 1 for allowed at beginning and 2 for allowed everywhere
     # and check_cn is 0 for do not check, 1 for check when no alternate dns names and 2 always
     # all of this is from IO::Socket::SSL
  
     rfc4513 => [0, 1, 2],
     rfc2818 => [0, 2, 1],
     rfc3207 => [0, 0, 2], # see IO::Socket::SSL, rfc seems unclear
     none    => [],        # do not check
  
     ldap    => "rfc4513",                    ldaps => "ldap",
     http    => "rfc2818",                    https => "http",
     smtp    => "rfc3207",                    smtps => "smtp",
  
     xmpp    => "rfc3920", rfc3920 => "http",
     pop3    => "rfc2595", rfc2595 => "ldap", pop3s => "pop3",
     imap    => "rfc2595", rfc2595 => "ldap", imaps => "imap",
     acap    => "rfc2595", rfc2595 => "ldap",
     nntp    => "rfc4642", rfc4642 => "ldap", nntps => "nntp",
     ftp     => "rfc4217", rfc4217 => "http", ftps  => "ftp" ,
  );
  
  sub match_cn($$$) {
     my ($name, $cn, $type) = @_;
  
     # remove leading and trailing garbage
     for ($name, $cn) {
        s/[\x00-\x1f]+$//;
        s/^[\x00-\x1f]+//;
     }
  
     my $pattern;
  
     ### IMPORTANT!
     # we accept only a single wildcard and only for a single part of the FQDN
     # e.g *.example.org does match www.example.org but not bla.www.example.org
     # The RFCs are in this regard unspecific but we don't want to have to
     # deal with certificates like *.com, *.co.uk or even *
     # see also http://nils.toedtmann.net/pub/subjectAltName.txt
     if ($type == 2 and $name =~m{^([^.]*)\*(.+)} ) {
        $pattern = qr{^\Q$1\E[^.]*\Q$2\E$}i;
     } elsif ($type == 1 and $name =~m{^\*(\..+)$} ) {
        $pattern = qr{^[^.]*\Q$1\E$}i;
     } else {
        $pattern = qr{^\Q$name\E$}i;
     }
  
     $cn =~ $pattern
  }
  
  # taken verbatim from IO::Socket::SSL, then changed to take advantage of
  # AnyEvent utilities.
  sub verify_hostname($$$) {
     my ($cn, $cert, $scheme) = @_;
  
     while (!ref $scheme) {
        $scheme = $CN_SCHEME{$scheme}
           or return 1;
     }
  
     my $cert_cn =
        Net::SSLeay::X509_NAME_get_text_by_NID (
           Net::SSLeay::X509_get_subject_name ($cert), Net::SSLeay::NID_commonName ());
  
     my @cert_alt = Net::SSLeay::X509_get_subjectAltNames ($cert);
  
     # rfc2460 - convert to network byte order
     require AnyEvent::Socket;
     my $ip = AnyEvent::Socket::parse_address ($cn);
  
     my $alt_dns_count;
  
     while (my ($type, $name) = splice @cert_alt, 0, 2) {
        if ($type == Net::SSLeay::GEN_IPADD ()) {
           # $name is already packed format (inet_xton)
           return 1 if $ip eq $name;
        } elsif ($type == Net::SSLeay::GEN_DNS ()) {
           $alt_dns_count++;
  
           return 1 if match_cn $name, $cn, $scheme->[1];
        }
     }
  
     if ($scheme->[2] == 2
         || ($scheme->[2] == 1 && !$alt_dns_count)) {
        return 1 if match_cn $cert_cn, $cn, $scheme->[0];
     }
  
     0
  }
  
  =back
  
  =head1 SSL/TLS QUICK FACTS
  
  Here are some quick facts about TLS/SSL that might help you:
  
  =over 4
  
  =item * A certificate is the public key part, a key is the private key part.
  
  While not strictly true, certificates are the things you can hand around
  publicly as a kind of identity, while keys should really be kept private,
  as proving that you have the private key is usually interpreted as being
  the entity behind the certificate.
  
  =item * A certificate is signed by a CA (Certificate Authority).
  
  By signing, the CA basically claims that the certificate it signs
  really belongs to the identity named in it, verified according to the
  CA policies. For e.g. HTTPS, the CA usually makes some checks that the
  hostname mentioned in the certificate really belongs to the company/person
  that requested the signing and owns the domain.
  
  =item * CAs can be certified by other CAs.
  
  Or by themselves - a certificate that is signed by a CA that is itself
  is called a self-signed certificate, a trust chain of length zero. When
  you find a certificate signed by another CA, which is in turn signed by
  another CA you trust, you have a trust chain of depth two.
  
  =item * "Trusting" a CA means trusting all certificates it has signed.
  
  If you "trust" a CA certificate, then all certificates signed by it are
  automatically considered trusted as well.
  
  =item * A successfully verified certificate means that you can be
  reasonably sure that whoever you are talking with really is who he claims
  he is.
  
  By verifying certificates against a number of CAs that you trust (meaning
  it is signed directly or indirectly by such a CA), you can find out that
  the other side really is whoever he claims, according to the CA policies,
  and your belief in the integrity of the CA.
  
  =item * Verifying the certificate signature is not everything.
  
  Even when the certificate is correct, it might belong to somebody else: if
  www.attacker.com can make your computer believe that it is really called
  www.mybank.com (by making your DNS server believe this for example),
  then it could send you the certificate for www.attacker.com that your
  software trusts because it is signed by a CA you trust, and intercept
  all your traffic that you think goes to www.mybank.com. This works
  because your software sees that the certificate is correctly signed (for
  www.attacker.com) and you think you are talking to your bank.
  
  To thwart this attack vector, peername verification should be used, which
  basically checks that the certificate (for www.attacker.com) really
  belongs to the host you are trying to talk to (www.mybank.com), which in
  this example is not the case, as www.attacker.com (from the certificate)
  doesn't match www.mybank.com (the hostname used to create the connection).
  
  So peername verification is almost as important as checking the CA
  signing. Unfortunately, every protocol implements this differently, if at
  all...
  
  =item * Switching off verification is sometimes reasonable.
  
  You can switch off verification. You still get an encrypted connection
  that is protected against eavesdropping and injection - you just lose
  protection against man in the middle attacks, i.e. somebody else with
  enough abilities to intercept all traffic can masquerade herself as the
  other side.
  
  For many applications, switching off verification is entirely
  reasonable. Downloading random stuff from websites using HTTPS for no
  reason is such an application. Talking to your bank and entering TANs is
  not such an application.
  
  =item * A SSL/TLS server always needs a certificate/key pair to operate,
  for clients this is optional.
  
  Apart from (usually disabled) anonymous cipher suites, a server always
  needs a certificate/key pair to operate.
  
  Clients almost never use certificates, but if they do, they can be used
  to authenticate the client, just as server certificates can be used to
  authenticate the server.
  
  =item * SSL version 2 is very insecure.
  
  SSL version 2 is old and not only has it some security issues, SSLv2-only
  implementations are usually buggy, too, due to their age.
  
  =item * Sometimes, even losing your "private" key might not expose all your
  data.
  
  With Diffie-Hellman ephemeral key exchange, you can lose the DH parameters
  (the "keys"), but all your connections are still protected. Diffie-Hellman
  needs special set-up (done by default by AnyEvent::TLS).
  
  =back
  
  =head1 SECURITY CONSIDERATIONS
  
  When you use any of the options that pass in keys or certificates
  as strings (e.g. C<ca_cert>), then, due to serious shortcomings in
  L<Net::SSLeay>, this module creates a temporary file to store the string -
  see L<File::Temp> and possibly its C<safe_level> setting for more details
  on what to watch out for.
  
  =head1 BUGS
  
  Due to the abysmal code quality of Net::SSLeay, this module will leak small
  amounts of memory per TLS connection (currently at least one perl scalar).
  
  =head1 AUTHORS
  
  Marc Lehmann <schmorp@schmorp.de>.
  
  Some of the API, documentation and implementation (verify_hostname),
  and a lot of ideas/workarounds/knowledge have been taken from the
  L<IO::Socket::SSL> module. Care has been taken to keep the API similar to
  that and other modules, to the extent possible while providing a sensible
  API for AnyEvent.
  
  =cut
  
  1
  
ANYEVENT_TLS

$fatpacked{"AnyEvent/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL';
  =encoding utf-8
  
  =head1 NAME
  
  AnyEvent::Util - various utility functions.
  
  =head1 SYNOPSIS
  
     use AnyEvent::Util;
  
  =head1 DESCRIPTION
  
  This module implements various utility functions, mostly replacing
  well-known functions by event-ised counterparts.
  
  All functions documented without C<AnyEvent::Util::> prefix are exported
  by default.
  
  =over 4
  
  =cut
  
  package AnyEvent::Util;
  
  use Carp ();
  use Errno ();
  use Socket ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use base 'Exporter';
  
  our @EXPORT = qw(fh_nonblocking guard fork_call portable_pipe portable_socketpair run_cmd);
  our @EXPORT_OK = qw(
     AF_INET6 WSAEWOULDBLOCK WSAEINPROGRESS WSAEINVAL
     close_all_fds_except
     punycode_encode punycode_decode idn_nameprep idn_to_ascii idn_to_unicode
  );
  
  our $VERSION = $AnyEvent::VERSION;
  
  BEGIN {
     # provide us with AF_INET6, but only if allowed
     if (
        $AnyEvent::PROTOCOL{ipv6}
        && _AF_INET6
        && socket my $ipv6_socket, _AF_INET6, Socket::SOCK_DGRAM(), 0 # check if they can be created
     ) {
        *AF_INET6 = \&_AF_INET6;
     } else {
        # disable ipv6
        *AF_INET6 = sub () { 0 };
        delete $AnyEvent::PROTOCOL{ipv6};
     }
  
     # fix buggy Errno on some non-POSIX platforms
     # such as openbsd and windows.
     my %ERR = (
        EBADMSG => Errno::EDOM   (),
        EPROTO  => Errno::ESPIPE (),
     );
  
     while (my ($k, $v) = each %ERR) {
        next if eval "Errno::$k ()";
        AE::log 8 => "Broken Errno module, adding Errno::$k.";
  
        eval "sub Errno::$k () { $v }";
        push @Errno::EXPORT_OK, $k;
        push @{ $Errno::EXPORT_TAGS{POSIX} }, $k;
     }
  }
  
  =item ($r, $w) = portable_pipe
  
  Calling C<pipe> in Perl is portable - except it doesn't really work on
  sucky windows platforms (at least not with most perls - cygwin's perl
  notably works fine): On windows, you actually get two file handles you
  cannot use select on.
  
  This function gives you a pipe that actually works even on the broken
  windows platform (by creating a pair of TCP sockets on windows, so do not
  expect any speed from that) and using C<pipe> everywhere else.
  
  See C<portable_socketpair>, below, for a bidirectional "pipe".
  
  Returns the empty list on any errors.
  
  =item ($fh1, $fh2) = portable_socketpair
  
  Just like C<portable_pipe>, above, but returns a bidirectional pipe
  (usually by calling C<socketpair> to create a local loopback socket pair,
  except on windows, where it again returns two interconnected TCP sockets).
  
  Returns the empty list on any errors.
  
  =cut
  
  BEGIN {
     if (AnyEvent::WIN32) {
        *_win32_socketpair = sub () {
           # perl's socketpair emulation fails on many vista machines, because
           # vista returns fantasy port numbers.
  
           for (1..10) {
              socket my $l, Socket::AF_INET(), Socket::SOCK_STREAM(), 0
                 or next;
  
              bind $l, Socket::pack_sockaddr_in 0, "\x7f\x00\x00\x01"
                 or next;
  
              my $sa = getsockname $l
                 or next;
  
              listen $l, 1
                 or next;
  
              socket my $r, Socket::AF_INET(), Socket::SOCK_STREAM(), 0
                 or next;
  
              bind $r, Socket::pack_sockaddr_in 0, "\x7f\x00\x00\x01"
                 or next;
  
              connect $r, $sa
                 or next;
  
              accept my $w, $l
                 or next;
  
              # vista has completely broken peername/sockname that return
              # fantasy ports. this combo seems to work, though.
              (Socket::unpack_sockaddr_in getpeername $r)[0]
              == (Socket::unpack_sockaddr_in getsockname $w)[0]
                 or (($! = WSAEINVAL), next);
  
              # vista example (you can't make this shit up...):
              #(Socket::unpack_sockaddr_in getsockname $r)[0] == 53364
              #(Socket::unpack_sockaddr_in getpeername $r)[0] == 53363
              #(Socket::unpack_sockaddr_in getsockname $w)[0] == 53363
              #(Socket::unpack_sockaddr_in getpeername $w)[0] == 53365
  
              return ($r, $w);
           }
  
           ()
        };
  
        *portable_socketpair = \&_win32_socketpair;
        *portable_pipe       = \&_win32_socketpair;
     } else {
        *portable_pipe = sub () {
           my ($r, $w);
  
           pipe $r, $w
              or return;
  
           ($r, $w);
        };
  
        *portable_socketpair = sub () {
           socketpair my $fh1, my $fh2, Socket::AF_UNIX(), Socket::SOCK_STREAM(), 0
              or return;
  
           ($fh1, $fh2)
        };
     }
  }
  
  =item fork_call { CODE } @args, $cb->(@res)
  
  Executes the given code block asynchronously, by forking. Everything the
  block returns will be transferred to the calling process (by serialising and
  deserialising via L<Storable>).
  
  If there are any errors, then the C<$cb> will be called without any
  arguments. In that case, either C<$@> contains the exception (and C<$!> is
  irrelevant), or C<$!> contains an error number. In all other cases, C<$@>
  will be C<undef>ined.
  
  The code block must not ever call an event-polling function or use
  event-based programming that might cause any callbacks registered in the
  parent to run.
  
  Win32 spoilers: Due to the endlessly sucky and broken native windows
  perls (there is no way to cleanly exit a child process on that platform
  that doesn't also kill the parent), you have to make sure that your main
  program doesn't exit as long as any C<fork_calls> are still in progress,
  otherwise the program won't exit. Also, on most windows platforms some
  memory will leak for every invocation. We are open for improvements that
  don't require XS hackery.
  
  Note that forking can be expensive in large programs (RSS 200MB+). On
  windows, it is abysmally slow, do not expect more than 5..20 forks/s on
  that sucky platform (note this uses perl's pseudo-threads, so avoid those
  like the plague).
  
  Example: poor man's async disk I/O (better use L<AnyEvent::IO> together
  with L<IO::AIO>).
  
     fork_call {
        open my $fh, "</etc/passwd"
           or die "passwd: $!";
        local $/;
        <$fh>
     } sub {
        my ($passwd) = @_;
        ...
     };
  
  =item $AnyEvent::Util::MAX_FORKS [default: 10]
  
  The maximum number of child processes that C<fork_call> will fork in
  parallel. Any additional requests will be queued until a slot becomes free
  again.
  
  The environment variable C<PERL_ANYEVENT_MAX_FORKS> is used to initialise
  this value.
  
  =cut
  
  our $MAX_FORKS = int 1 * $ENV{PERL_ANYEVENT_MAX_FORKS};
  $MAX_FORKS = 10 if $MAX_FORKS <= 0;
  
  my $forks;
  my @fork_queue;
  
  sub _fork_schedule;
  sub _fork_schedule {
     require Storable unless $Storable::VERSION;
     require POSIX    unless $POSIX::VERSION;
  
     while ($forks < $MAX_FORKS) {
        my $job = shift @fork_queue
           or last;
  
        ++$forks;
  
        my $coderef = shift @$job;
        my $cb = pop @$job;
        
        # gimme a break...
        my ($r, $w) = portable_pipe
           or ($forks and last) # allow failures when we have at least one job
           or die "fork_call: $!";
  
        my $pid = fork;
  
        if ($pid != 0) {
           # parent
           close $w;
  
           my $buf;
  
           my $ww; $ww = AE::io $r, 0, sub {
              my $len = sysread $r, $buf, 65536, length $buf;
  
              return unless defined $len or $! != Errno::EINTR;
  
              if (!$len) {
                 undef $ww;
                 close $r;
                 --$forks;
                 _fork_schedule;
                 
                 my $result = eval { Storable::thaw ($buf) };
                 $result = [$@] unless $result;
                 $@ = shift @$result;
  
                 $cb->(@$result);
  
                 # work around the endlessly broken windows perls
                 kill 9, $pid if AnyEvent::WIN32;
  
                 # clean up the pid
                 waitpid $pid, 0;
              }
           };
  
        } elsif (defined $pid) {
           # child
           close $r;
  
           my $result = eval {
              local $SIG{__DIE__};
  
              Storable::freeze ([undef, $coderef->(@$job)])
           };
  
           $result = Storable::freeze (["$@"])
              if $@;
  
           # windows forces us to these contortions
           my $ofs;
  
           while () {
              my $len = (length $result) - $ofs
                 or last;
  
              $len = syswrite $w, $result, $len < 65536 ? $len : 65536, $ofs;
  
              last unless $len || (!defined $len && $! == Errno::EINTR);
  
              $ofs += $len;
           }
  
           # on native windows, _exit KILLS YOUR FORKED CHILDREN!
           if (AnyEvent::WIN32) {
              shutdown $w, 1; # signal parent to please kill us
              sleep 10; # give parent a chance to clean up
              sysread $w, (my $buf), 1; # this *might* detect the parent exiting in some cases.
           }
           POSIX::_exit (0);
           exit 1;
           
        } elsif (($! != &Errno::EAGAIN && $! != &Errno::EWOULDBLOCK && $! != &Errno::ENOMEM) || !$forks) {
           # we ignore some errors as long as we can run at least one job
           # maybe we should wait a few seconds and retry instead
           die "fork_call: $!";
        }
     }
  }
  
  sub fork_call(&@) {
     push @fork_queue, [@_];
     _fork_schedule;
  }
  
  END {
     if (AnyEvent::WIN32) {
        while ($forks) {
           @fork_queue = ();
           AnyEvent->one_event;
        }
     }
  }
  
  # to be removed
  sub dotted_quad($) {
     $_[0] =~ /^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)$/x
  }
  
  # just a forwarder
  sub inet_aton {
     require AnyEvent::Socket;
     *inet_aton = \&AnyEvent::Socket::inet_aton;
     goto &inet_aton
  }
  
  =item fh_nonblocking $fh, $nonblocking
  
  Sets the blocking state of the given filehandle (true == nonblocking,
  false == blocking). Uses fcntl on anything sensible and ioctl FIONBIO on
  broken (i.e. windows) platforms.
  
  Instead of using this function, you could use C<AnyEvent::fh_block> or
  C<AnyEvent::fh_unblock>.
  
  =cut
  
  BEGIN {
     *fh_nonblocking = \&AnyEvent::_fh_nonblocking;
  }
  
  =item $guard = guard { CODE }
  
  This function creates a special object that, when destroyed, will execute
  the code block.
  
  This is often handy in continuation-passing style code to clean up some
  resource regardless of where you break out of a process.
  
  The L<Guard> module will be used to implement this function, if it is
  available. Otherwise a pure-perl implementation is used.
  
  While the code is allowed to throw exceptions in unusual conditions, it is
  not defined whether this exception will be reported (at the moment, the
  Guard module and AnyEvent's pure-perl implementation both try to report
  the error and continue).
  
  You can call one method on the returned object:
  
  =item $guard->cancel
  
  This simply causes the code block not to be invoked: it "cancels" the
  guard.
  
  =cut
  
  BEGIN {
     if (!$ENV{PERL_ANYEVENT_AVOID_GUARD} && eval { require Guard; $Guard::VERSION >= 0.5 }) {
        *guard = \&Guard::guard;
        AE::log 8 => "Using Guard module to implement guards.";
     } else {
        *AnyEvent::Util::guard::DESTROY = sub {
           local $@;
  
           eval {
              local $SIG{__DIE__};
              ${$_[0]}->();
           };
  
           AE::log 4 => "Runtime error in AnyEvent::guard callback: $@" if $@;
        };
  
        *AnyEvent::Util::guard::cancel = sub ($) {
           ${$_[0]} = sub { };
        };
  
        *guard = sub (&) {
           bless \(my $cb = shift), "AnyEvent::Util::guard"
        };
  
        AE::log 8 => "Using pure-perl guard implementation.";
     }
  }
  
  =item AnyEvent::Util::close_all_fds_except @fds
  
  This rarely-used function simply closes all file descriptors (or tries to)
  of the current process except the ones given as arguments.
  
  When you want to start a long-running background server, then it is often
  beneficial to do this, as too many C-libraries are too stupid to mark
  their internal fd's as close-on-exec.
  
  The function expects to be called shortly before an C<exec> call.
  
  Example: close all fds except 0, 1, 2.
  
     close_all_fds_except 0, 2, 1;
  
  =cut
  
  sub close_all_fds_except {
     my %except; @except{@_} = ();
  
     require POSIX unless $POSIX::VERSION;
  
     # some OSes have a usable /dev/fd, sadly, very few
     if ($^O =~ /(freebsd|cygwin|linux)/) {
        # netbsd, openbsd, solaris have a broken /dev/fd
        my $dir;
        if (opendir $dir, "/dev/fd" or opendir $dir, "/proc/self/fd") {
           my @fds = sort { $a <=> $b } grep /^\d+$/, readdir $dir;
           # broken OS's have device nodes for 0..63 usually, solaris 0..255
           if (@fds < 20 or "@fds" ne join " ", 0..$#fds) {
              # assume the fds array is valid now
              exists $except{$_} or POSIX::close ($_)
                 for @fds;
              return;
           }
        }
     }
  
     my $fd_max = eval { POSIX::sysconf (POSIX::_SC_OPEN_MAX ()) - 1 } || 1023;
  
     exists $except{$_} or POSIX::close ($_)
        for 0..$fd_max;
  }
  
  =item $cv = run_cmd $cmd, key => value...
  
  Run a given external command, potentially redirecting file descriptors and
  return a condition variable that gets sent the exit status (like C<$?>)
  when the program exits I<and> all redirected file descriptors have been
  exhausted.
  
  The C<$cmd> is either a single string, which is then passed to a shell, or
  an arrayref, which is passed to the C<execvp> function (the first array
  element is used both for the executable name and argv[0]).
  
  The key-value pairs can be:
  
  =over 4
  
  =item ">" => $filename
  
  Redirects program standard output into the specified filename, similar to C<<
  >filename >> in the shell.
  
  =item ">" => \$data
  
  Appends program standard output to the referenced scalar. The condvar will
  not be signalled before EOF or an error is signalled.
  
  Specifying the same scalar in multiple ">" pairs is allowed, e.g. to
  redirect both stdout and stderr into the same scalar:
  
      ">"  => \$output,
      "2>" => \$output,
  
  =item ">" => $filehandle
  
  Redirects program standard output to the given filehandle (or actually its
  underlying file descriptor).
  
  =item ">" => $callback->($data)
  
  Calls the given callback each time standard output receives some data,
  passing it the data received. On EOF or error, the callback will be
  invoked once without any arguments.
  
  The condvar will not be signalled before EOF or an error is signalled.
  
  =item "fd>" => $see_above
  
  Like ">", but redirects the specified fd number instead.
  
  =item "<" => $see_above
  
  The same, but redirects the program's standard input instead. The same
  forms as for ">" are allowed.
  
  In the callback form, the callback is supposed to return data to be
  written, or the empty list or C<undef> or a zero-length scalar to signal
  EOF.
  
  Similarly, either the write data must be exhausted or an error is to be
  signalled before the condvar is signalled, for both string-reference and
  callback forms.
  
  =item "fd<" => $see_above
  
  Like "<", but redirects the specified file descriptor instead.
  
  =item on_prepare => $cb
  
  Specify a callback that is executed just before the command is C<exec>'ed,
  in the child process. Be careful not to use any event handling or other
  services not available in the child.
  
  This can be useful to set up the environment in special ways, such as
  changing the priority of the command or manipulating signal handlers (e.g.
  setting C<SIGINT> to C<IGNORE>).
  
  =item close_all => $boolean
  
  When C<close_all> is enabled (default is disabled), then all extra file
  descriptors will be closed, except the ones that were redirected and C<0>,
  C<1> and C<2>.
  
  See C<close_all_fds_except> for more details.
  
  =item '$$' => \$pid
  
  A reference to a scalar which will receive the PID of the newly-created
  subprocess after C<run_cmd> returns.
  
  Note the the PID might already have been recycled and used by an unrelated
  process at the time C<run_cmd> returns, so it's not useful to send
  signals, use as a unique key in data structures and so on.
  
  =back
  
  Example: run C<rm -rf />, redirecting standard input, output and error to
  F</dev/null>.
  
     my $cv = run_cmd [qw(rm -rf /)],
        "<", "/dev/null",
        ">", "/dev/null",
        "2>", "/dev/null";
     $cv->recv and die "d'oh! something survived!"
  
  Example: run F<openssl> and create a self-signed certificate and key,
  storing them in C<$cert> and C<$key>. When finished, check the exit status
  in the callback and print key and certificate.
  
     my $cv = run_cmd [qw(openssl req
                       -new -nodes -x509 -days 3650
                       -newkey rsa:2048 -keyout /dev/fd/3
                       -batch -subj /CN=AnyEvent
                      )],
        "<", "/dev/null",
        ">" , \my $cert,
        "3>", \my $key,
        "2>", "/dev/null";
  
     $cv->cb (sub {
        shift->recv and die "openssl failed";
  
        print "$key\n$cert\n";
     });
  
  =cut
  
  sub run_cmd {
     my $cmd = shift;
  
     require POSIX unless $POSIX::VERSION;
  
     my $cv = AE::cv;
  
     my %arg;
     my %redir;
     my @exe;
  
     while (@_) {
        my ($type, $ob) = splice @_, 0, 2;
  
        my $fd = $type =~ s/^(\d+)// ? $1 : undef;
  
        if ($type eq ">") {
           $fd = 1 unless defined $fd;
  
           if (defined eval { fileno $ob }) {
              $redir{$fd} = $ob;
           } elsif (ref $ob) {
              my ($pr, $pw) = AnyEvent::Util::portable_pipe;
              $cv->begin;
  
              fcntl $pr, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fh_nonblocking $pr, 1;
              my $w; $w = AE::io $pr, 0,
                 "SCALAR" eq ref $ob
                    ? sub {
                         defined (sysread $pr, $$ob, 16384, length $$ob
                                  and return)
                            or ($! == Errno::EINTR and return);
                         undef $w; $cv->end;
                      }
                    : sub {
                         my $buf;
                         defined (sysread $pr, $buf, 16384
                                  and return $ob->($buf))
                            or ($! == Errno::EINTR and return);
                         undef $w; $cv->end;
                         $ob->();
                      }
              ;
              $redir{$fd} = $pw;
           } else {
              push @exe, sub {
                 open my $fh, ">", $ob
                    or POSIX::_exit (125);
                 $redir{$fd} = $fh;
              };
           }
  
        } elsif ($type eq "<") {
           $fd = 0 unless defined $fd;
  
           if (defined eval { fileno $ob }) {
              $redir{$fd} = $ob;
           } elsif (ref $ob) {
              my ($pr, $pw) = AnyEvent::Util::portable_pipe;
              $cv->begin;
  
              my $data;
              if ("SCALAR" eq ref $ob) {
                 $data = $$ob;
                 $ob = sub { };
              } else {
                 $data = $ob->();
              }
  
              fcntl $pw, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fh_nonblocking $pw, 1;
              my $w; $w = AE::io $pw, 1, sub {
                 my $len = syswrite $pw, $data;
  
                 return unless defined $len or $! != Errno::EINTR;
  
                 if (!$len) {
                    undef $w; $cv->end;
                 } else {
                    substr $data, 0, $len, "";
                    unless (length $data) {
                       $data = $ob->();
                       unless (length $data) {
                          undef $w; $cv->end
                       }
                    }
                 }
              };
  
              $redir{$fd} = $pr;
           } else {
              push @exe, sub {
                 open my $fh, "<", $ob
                    or POSIX::_exit (125);
                 $redir{$fd} = $fh;
              };
           }
  
        } else {
           $arg{$type} = $ob;
        }
     }
  
     my $pid = fork;
  
     defined $pid
        or Carp::croak "fork: $!";
  
     unless ($pid) {
        # step 1, execute
        $_->() for @exe;
  
        # step 2, move any existing fd's out of the way
        # this also ensures that dup2 is never called with fd1==fd2
        # so the cloexec flag is always cleared
        my (@oldfh, @close);
        for my $fh (values %redir) {
           push @oldfh, $fh; # make sure we keep it open
           $fh = fileno $fh; # we only want the fd
  
           # dup if we are in the way
           # if we "leak" fds here, they will be dup2'ed over later
           defined ($fh = POSIX::dup ($fh)) or POSIX::_exit (124)
              while exists $redir{$fh};
        }
  
        # step 3, execute redirects
        while (my ($k, $v) = each %redir) {
           defined POSIX::dup2 ($v, $k)
              or POSIX::_exit (123);
        }
  
        # step 4, close everything else, except 0, 1, 2
        if ($arg{close_all}) {
           close_all_fds_except 0, 1, 2, keys %redir
        } else {
           POSIX::close ($_)
              for values %redir;
        }
  
        eval { $arg{on_prepare}(); 1 } or POSIX::_exit (123)
           if exists $arg{on_prepare};
  
        ref $cmd
           ? exec {$cmd->[0]} @$cmd
           : exec $cmd;
  
        POSIX::_exit (126);
     }
  
     ${$arg{'$$'}} = $pid
        if $arg{'$$'};
  
     %redir = (); # close child side of the fds
  
     my $status;
     $cv->begin (sub { shift->send ($status) });
     my $cw; $cw = AE::child $pid, sub {
        $status = $_[1];
        undef $cw; $cv->end;
     };
  
     $cv
  }
  
  =item AnyEvent::Util::punycode_encode $string
  
  Punycode-encodes the given C<$string> and returns its punycode form. Note
  that uppercase letters are I<not> casefolded - you have to do that
  yourself.
  
  Croaks when it cannot encode the string.
  
  =item AnyEvent::Util::punycode_decode $string
  
  Tries to punycode-decode the given C<$string> and return its unicode
  form. Again, uppercase letters are not casefoled, you have to do that
  yourself.
  
  Croaks when it cannot decode the string.
  
  =cut
  
  sub punycode_encode($) {
     require "AnyEvent/Util/idna.pl";
     goto &punycode_encode;
  }
  
  sub punycode_decode($) {
     require "AnyEvent/Util/idna.pl";
     goto &punycode_decode;
  }
  
  =item AnyEvent::Util::idn_nameprep $idn[, $display]
  
  Implements the IDNA nameprep normalisation algorithm. Or actually the
  UTS#46 algorithm. Or maybe something similar - reality is complicated
  between IDNA2003, UTS#46 and IDNA2008. If C<$display> is true then the name
  is prepared for display, otherwise it is prepared for lookup (default).
  
  If you have no clue what this means, look at C<idn_to_ascii> instead.
  
  This function is designed to avoid using a lot of resources - it uses
  about 1MB of RAM (most of this due to Unicode::Normalize). Also, names
  that are already "simple" will only be checked for basic validity, without
  the overhead of full nameprep processing.
  
  =cut
  
  our ($uts46_valid, $uts46_imap);
  
  sub idn_nameprep($;$) {
     local $_ = $_[0];
  
     # lowercasing these should always be valid, and is required for xn-- detection
     y/A-Z/a-z/;
  
     if (/[^0-9a-z\-.]/) {
        # load the mapping data
        unless (defined $uts46_imap) {
           require Unicode::Normalize;
           require "AnyEvent/Util/uts46data.pl";
        }
  
        # uts46 nameprep
  
        # I naively tried to use a regex/transliterate approach first,
        # with one regex and one y///, but the compiled code was 4.5MB.
        # this version has a bit-table for the valid class, and
        # a char-replacement search string
  
        # for speed (cough) reasons, we skip-case 0-9a-z, -, ., which
        # really ought to be trivially valid. A-Z is valid, but already lowercased.
        s{
           ([^0-9a-z\-.])
        }{
           my $chr = $1;
           unless (vec $uts46_valid, ord $chr, 1) {
              # not in valid class, search for mapping
              utf8::encode $chr; # the imap table is in utf-8
              (my $rep = index $uts46_imap, "\x00$chr") >= 0
                 or Carp::croak "$_[0]: disallowed characters (U+" . (unpack "H*", $chr) . ") during idn_nameprep";
  
              (substr $uts46_imap, $rep, 128) =~ /\x00 .[\x80-\xbf]* ([^\x00]*) \x00/x
                 or die "FATAL: idn_nameprep imap table has unexpected contents";
  
              $rep = $1;
              $chr = $rep unless $rep =~ s/^\x01// && $_[1]; # replace unless deviation and display
              utf8::decode $chr;
           }
           $chr
        }gex;
  
        # KC
        $_ = Unicode::Normalize::NFKC ($_);
     }
  
     # decode punycode components, check for invalid xx-- prefixes
     s{
        (^|\.)(..)--([^\.]*)
     }{
        my ($pfx, $ace, $pc) = ($1, $2, $3);
  
        if ($ace eq "xn") {
           $pc = punycode_decode $pc; # will croak on error (we hope :)
  
           require Unicode::Normalize;
           $pc eq Unicode::Normalize::NFC ($pc)
              or Carp::croak "$_[0]: punycode label not in NFC detected during idn_nameprep";
  
           "$pfx$pc"
        } elsif ($ace !~ /^[a-z0-9]{2}$/) {
           "$pfx$ace--$pc"
        } else {
           Carp::croak "$_[0]: hyphens in 3rd/4th position of a label are not allowed";
        }
     }gex;
  
     # uts46 verification
     /\.-|-\./
        and Carp::croak "$_[0]: invalid hyphens detected during idn_nameprep";
  
     # missing: label begin with combining mark, idna2008 bidi
  
     # now check validity of each codepoint
     if (/[^0-9a-z\-.]/) {
        # load the mapping data
        unless (defined $uts46_imap) {
           require "AnyEvent/Util/uts46data.pl";
        }
  
        vec $uts46_valid, ord, 1
           or $_[1] && 0 <= index $uts46_imap, pack "C0U*", 0, ord, 1 # deviation == \x00$chr\x01
           or Carp::croak "$_[0]: disallowed characters during idn_nameprep"
           for split //;
     }
  
     $_
  }
  
  =item $domainname = AnyEvent::Util::idn_to_ascii $idn
  
  Converts the given unicode string (C<$idn>, international domain name,
  e.g. ) to a pure-ASCII domain name (this is usually
  called the "IDN ToAscii" transform). This transformation is idempotent,
  which means you can call it just in case and it will do the right thing.
  
  Unlike some other "ToAscii" implementations, this one works on full domain
  names and should never fail - if it cannot convert the name, then it will
  return it unchanged.
  
  This function is an amalgam of IDNA2003, UTS#46 and IDNA2008 - it tries to
  be reasonably compatible to other implementations, reasonably secure, as
  much as IDNs can be secure, and reasonably efficient when confronted with
  IDNs that are already valid DNS names.
  
  =cut
  
  sub idn_to_ascii($) {
     return $_[0]
        unless $_[0] =~ /[^\x00-\x7f]/;
  
     my @output;
  
     eval {
        # punycode by label
        for (split /\./, (idn_nameprep $_[0]), -1) {
           if (/[^\x00-\x7f]/) {
              eval {
                 push @output, "xn--" . punycode_encode $_;
                 1;
              } or do {
                 push @output, $_;
              };
           } else {
              push @output, $_;
           }
        }
  
        1
     } or return $_[0];
  
     shift @output
        while !length $output[0] && @output > 1;
  
     join ".", @output
  }
  
  =item $idn = AnyEvent::Util::idn_to_unicode $idn
  
  Converts the given unicode string (C<$idn>, international domain name,
  e.g. , www.deliantra.net, www.xn--l-0ga.de) to
  unicode form (this is usually called the "IDN ToUnicode" transform). This
  transformation is idempotent, which means you can call it just in case and
  it will do the right thing.
  
  Unlike some other "ToUnicode" implementations, this one works on full
  domain names and should never fail - if it cannot convert the name, then
  it will return it unchanged.
  
  This function is an amalgam of IDNA2003, UTS#46 and IDNA2008 - it tries to
  be reasonably compatible to other implementations, reasonably secure, as
  much as IDNs can be secure, and reasonably efficient when confronted with
  IDNs that are already valid DNS names.
  
  At the moment, this function simply calls C<idn_nameprep $idn, 1>,
  returning its argument when that function fails.
  
  =cut
  
  sub idn_to_unicode($) {
     my $res = eval { idn_nameprep $_[0], 1 };
     defined $res ? $res : $_[0]
  }
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_UTIL

$fatpacked{"AnyEvent/Util/idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL_IDNA';
  # based on RFC 3492
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Carp ();
  use List::Util ();
  use integer;
  
  sub pyc_base         () {  36 }
  sub pyc_tmin         () {   1 }
  sub pyc_tmax         () {  26 }
  sub pyc_initial_bias () {  72 }
  sub pyc_initial_n    () { 128 }
  
  sub pyc_digits       () { "abcdefghijklmnopqrstuvwxyz0123456789" }
  
  sub pyc_adapt($$$) {
     my ($delta, $numpoints, $firsttime) = @_;
  
     $delta = $firsttime ? $delta / 700 : $delta >> 1;
     $delta += $delta / $numpoints;
  
     my $k;
  
     while ($delta > (pyc_base - pyc_tmin) * pyc_tmax / 2) {
        $delta /= pyc_base - pyc_tmin;
        $k += pyc_base;
     }
  
     $k + $delta * (pyc_base - pyc_tmin + 1) / ($delta + 38)
  }
  
  sub punycode_encode($) {
     my ($input) = @_;
  
     my ($n, $bias, $delta) = (pyc_initial_n, pyc_initial_bias);
  
     (my $output = $input) =~ y/\x00-\x7f//cd;
     my $h = my $b = length $output;
  
     my @input = split '', $input;
  
     $output .= "-" if $b && $h < @input;
  
     while ($h < @input) {
        my $m = List::Util::min grep { $_ >= $n } map ord, @input;
  
        $m - $n <= (0x7fffffff - $delta) / ($h + 1)
           or Carp::croak "punycode_encode: overflow in punycode delta encoding";
        $delta += ($m - $n) * ($h + 1);
        $n = $m;
  
        for my $i (@input) {
           my $c = ord $i;
           ++$delta < 0x7fffffff
              or Carp::croak "punycode_encode: overflow in punycode delta encoding"
              if $c < $n;
  
           if ($c == $n) {
              my ($q, $k) = ($delta, pyc_base);
  
              while () {
                  my $t = List::Util::min pyc_tmax, List::Util::max pyc_tmin, $k - $bias;
  
                  last if $q < $t;
  
                  $output .= substr pyc_digits, $t + (($q - $t) % (pyc_base - $t)), 1;
  
                  $q = ($q - $t) / (pyc_base - $t);
                  $k += pyc_base;
              }
  
              $output .= substr pyc_digits, $q, 1;
  
              $bias = pyc_adapt $delta, $h + 1, $h == $b;
  
              $delta = 0;
              ++$h;
           }
        }
  
        ++$delta;
        ++$n;
     }
  
     $output
  }
  
  sub punycode_decode($) {
     my ($input) = @_;
  
     my ($n, $bias, $i) = (pyc_initial_n, pyc_initial_bias);
     my $output;
  
     if ($input =~ /^(.*?)-([^-]*)$/x) {
        $output = $1;
        $input = $2;
  
        $output =~ /[^\x00-\x7f]/
           and Carp::croak "punycode_decode: malformed punycode";
     }
  
     while (length $input) {
        my $oldi = $i;
        my $w    = 1;
  
        for (my $k = pyc_base; ; $k += pyc_base) {
           (my $digit = index pyc_digits, substr $input, 0, 1, "")
              >= 0
              or Carp::croak "punycode_decode: malformed punycode";
        
           $i += $digit * $w;
           
           my $t = List::Util::max pyc_tmin, List::Util::min pyc_tmax, $k - $bias;
           last if $digit < $t;
  
           $w *= pyc_base - $t;
        }
  
        my $outlen = 1 + length $output;
        $bias = pyc_adapt $i - $oldi, $outlen, $oldi == 0;
  
        $n += $i / $outlen;
        $i %=      $outlen;
  
        substr $output, $i, 0, chr $n;
        ++$i;
     }
  
     $output
  }
  
  1
ANYEVENT_UTIL_IDNA

$fatpacked{"AnyEvent/Util/uts46data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL_UTS46DATA';
  # autogenerated by util/gen_uts46data
  $uts46_imap = q Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz a  2 3  1 o 14 12 34                                                       i ij ij      l l     n                            s                                     d d d lj lj lj nj nj nj                  dz dz dz                                               h  j r    w y  l s x                                                                                                                                                                                                                                                                                                                                            a  b d e  g h i j k l m n o  p r t u w a    b d e    g k m  o    p t u   v       i r u v        c    f                           z                                                                                a  ss                                                                                                                                                                                                        0 i 4 5 6 7 8 9  n 0 1 2 3 4 5 6 7 8 9  a e o x  h k l m n p s t rs c c  f g h h h h  i i l l n no p q r r r sm tel tm z  z k  b c e e f m o     i fax      d d e i j 17 19 110 13 23 15 25 35 45 16 56 18 38 58 78 1 i ii iii iv v vi vii viii ix x xi xii l c d m i ii iii iv v vi vii viii ix x xi xii l c d m 03       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z 0                                                               j v                                                                                                                                                                                                                                                                                 .                                                                                                                      pte 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35                                                                                 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 1 2 3 4 5 6 7 8 9 10 11 12 hg erg ev ltd                                                                                                                                        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 hpa da au bar ov pc dm dm2 dm3 iu      pa na a ma ka kb mb gb cal kcal pf nf f g mg kg hz khz mhz ghz thz l ml dl kl fm nm m mm cm km mm2 cm2 m2 km2 mm3 cm3 m3 km3 ms ms2 pa kpa mpa gpa rad rads rads2 ps ns s ms pv nv v mv kv mv pw nw w mw kw mw k m bq cc cd ckg db gy ha hp in kk km kt lm ln log lx mb mil mol ph ppm pr sr sv wb vm am 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 gal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ff fi fl ffi ffl st st                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -                                                                                                                                     - . 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z   .                                                                                                                                                                                                                                                                                                               a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a c d g j k n o p q s t u v w x y z a b c d f h i j k l m n p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b d e f g j k l m n o p q s t u v w x y a b c d e f g h i j k l m n o p q r s t u v w x y z a b d e f g i j k l m o s t u v w x y a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z                                                                                                                                                                                                                                                                                                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9                                                                                                                                                                                s c r cd wz a b c d e f g h i j k l m n o p q r s t u v w x y z hv mv sd ss ppv wc mc md dj                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;
  $uts46_valid = q     `        Z  UTT)1$N*-Q@U! 8    H      T       ? ?O        ?   y %9? ; 9 == =` =`@ /_     %;_?    {{          ======?     ? ? ? ?                   @       ? ?   ?   U      C @   @  0} '           B       O?                      ?          b          {                                 f?                                                                            ? ?                 ?? ?   ~~~ ?           ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               @                                                                                              `                                                      ??         ?                  ?          ?                         ?                    ?      7        o      ??                                                                                                                     ?    ?         9                 +                         ??                                                                                                                                                      ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ?? ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ? ?  ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ?                                                          ?                                                                                                                                                                                                                                   ?;
  1;
ANYEVENT_UTIL_UTS46DATA

$fatpacked{"AnyEvent/constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_CONSTANTS';
  package AnyEvent;
  sub common_sense{}
  sub CYGWIN      (){ 0 }
  sub WIN32       (){ 0 }
  sub F_SETFD     (){ eval { Fcntl::F_SETFD() } || 2 }
  sub F_SETFL     (){ eval { Fcntl::F_SETFL() } || 4 }
  sub O_NONBLOCK  (){ eval { Fcntl::O_NONBLOCK() } || 04000 }
  sub FD_CLOEXEC  (){ eval { Fcntl::FD_CLOEXEC() } || 1 }
  package AnyEvent::Base;
  sub WNOHANG     (){ eval { POSIX::WNOHANG() } || 1 }
  package AnyEvent::IO;
  sub O_RDONLY    (){ eval { Fcntl::O_RDONLY() } || 0 }
  sub O_WRONLY    (){ eval { Fcntl::O_WRONLY() } || 1 }
  sub O_RDWR      (){ eval { Fcntl::O_RDWR  () } || 2 }
  sub O_CREAT     (){ eval { Fcntl::O_CREAT () } || 64 }
  sub O_EXCL      (){ eval { Fcntl::O_EXCL  () } || 128 }
  sub O_TRUNC     (){ eval { Fcntl::O_TRUNC () } || 512 }
  sub O_APPEND    (){ eval { Fcntl::O_APPEND() } || 1024 }
  package AnyEvent::Util;
  sub WSAEINVAL   (){ -1e99 }
  sub WSAEWOULDBLOCK(){ -1e99 }
  sub WSAEINPROGRESS(){ -1e99 }
  sub _AF_INET6   (){ 30 }
  1;
  
  =pod
  
                      GNU GENERAL PUBLIC LICENSE
                         Version 3, 29 June 2007
  
   Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
   Everyone is permitted to copy and distribute verbatim copies
   of this license document, but changing it is not allowed.
  
                              Preamble
  
    The GNU General Public License is a free, copyleft license for
  software and other kinds of works.
  
    The licenses for most software and other practical works are designed
  to take away your freedom to share and change the works.  By contrast,
  the GNU General Public License is intended to guarantee your freedom to
  share and change all versions of a program--to make sure it remains free
  software for all its users.  We, the Free Software Foundation, use the
  GNU General Public License for most of our software; it applies also to
  any other work released this way by its authors.  You can apply it to
  your programs, too.
  
    When we speak of free software, we are referring to freedom, not
  price.  Our General Public Licenses are designed to make sure that you
  have the freedom to distribute copies of free software (and charge for
  them if you wish), that you receive source code or can get it if you
  want it, that you can change the software or use pieces of it in new
  free programs, and that you know you can do these things.
  
    To protect your rights, we need to prevent others from denying you
  these rights or asking you to surrender the rights.  Therefore, you have
  certain responsibilities if you distribute copies of the software, or if
  you modify it: responsibilities to respect the freedom of others.
  
    For example, if you distribute copies of such a program, whether
  gratis or for a fee, you must pass on to the recipients the same
  freedoms that you received.  You must make sure that they, too, receive
  or can get the source code.  And you must show them these terms so they
  know their rights.
  
    Developers that use the GNU GPL protect your rights with two steps:
  (1) assert copyright on the software, and (2) offer you this License
  giving you legal permission to copy, distribute and/or modify it.
  
    For the developers' and authors' protection, the GPL clearly explains
  that there is no warranty for this free software.  For both users' and
  authors' sake, the GPL requires that modified versions be marked as
  changed, so that their problems will not be attributed erroneously to
  authors of previous versions.
  
    Some devices are designed to deny users access to install or run
  modified versions of the software inside them, although the manufacturer
  can do so.  This is fundamentally incompatible with the aim of
  protecting users' freedom to change the software.  The systematic
  pattern of such abuse occurs in the area of products for individuals to
  use, which is precisely where it is most unacceptable.  Therefore, we
  have designed this version of the GPL to prohibit the practice for those
  products.  If such problems arise substantially in other domains, we
  stand ready to extend this provision to those domains in future versions
  of the GPL, as needed to protect the freedom of users.
  
    Finally, every program is threatened constantly by software patents.
  States should not allow patents to restrict development and use of
  software on general-purpose computers, but in those that do, we wish to
  avoid the special danger that patents applied to a free program could
  make it effectively proprietary.  To prevent this, the GPL assures that
  patents cannot be used to render the program non-free.
  
    The precise terms and conditions for copying, distribution and
  modification follow.
  
                         TERMS AND CONDITIONS
  
    0. Definitions.
  
    "This License" refers to version 3 of the GNU General Public License.
  
    "Copyright" also means copyright-like laws that apply to other kinds of
  works, such as semiconductor masks.
  
    "The Program" refers to any copyrightable work licensed under this
  License.  Each licensee is addressed as "you".  "Licensees" and
  "recipients" may be individuals or organizations.
  
    To "modify" a work means to copy from or adapt all or part of the work
  in a fashion requiring copyright permission, other than the making of an
  exact copy.  The resulting work is called a "modified version" of the
  earlier work or a work "based on" the earlier work.
  
    A "covered work" means either the unmodified Program or a work based
  on the Program.
  
    To "propagate" a work means to do anything with it that, without
  permission, would make you directly or secondarily liable for
  infringement under applicable copyright law, except executing it on a
  computer or modifying a private copy.  Propagation includes copying,
  distribution (with or without modification), making available to the
  public, and in some countries other activities as well.
  
    To "convey" a work means any kind of propagation that enables other
  parties to make or receive copies.  Mere interaction with a user through
  a computer network, with no transfer of a copy, is not conveying.
  
    An interactive user interface displays "Appropriate Legal Notices"
  to the extent that it includes a convenient and prominently visible
  feature that (1) displays an appropriate copyright notice, and (2)
  tells the user that there is no warranty for the work (except to the
  extent that warranties are provided), that licensees may convey the
  work under this License, and how to view a copy of this License.  If
  the interface presents a list of user commands or options, such as a
  menu, a prominent item in the list meets this criterion.
  
    1. Source Code.
  
    The "source code" for a work means the preferred form of the work
  for making modifications to it.  "Object code" means any non-source
  form of a work.
  
    A "Standard Interface" means an interface that either is an official
  standard defined by a recognized standards body, or, in the case of
  interfaces specified for a particular programming language, one that
  is widely used among developers working in that language.
  
    The "System Libraries" of an executable work include anything, other
  than the work as a whole, that (a) is included in the normal form of
  packaging a Major Component, but which is not part of that Major
  Component, and (b) serves only to enable use of the work with that
  Major Component, or to implement a Standard Interface for which an
  implementation is available to the public in source code form.  A
  "Major Component", in this context, means a major essential component
  (kernel, window system, and so on) of the specific operating system
  (if any) on which the executable work runs, or a compiler used to
  produce the work, or an object code interpreter used to run it.
  
    The "Corresponding Source" for a work in object code form means all
  the source code needed to generate, install, and (for an executable
  work) run the object code and to modify the work, including scripts to
  control those activities.  However, it does not include the work's
  System Libraries, or general-purpose tools or generally available free
  programs which are used unmodified in performing those activities but
  which are not part of the work.  For example, Corresponding Source
  includes interface definition files associated with source files for
  the work, and the source code for shared libraries and dynamically
  linked subprograms that the work is specifically designed to require,
  such as by intimate data communication or control flow between those
  subprograms and other parts of the work.
  
    The Corresponding Source need not include anything that users
  can regenerate automatically from other parts of the Corresponding
  Source.
  
    The Corresponding Source for a work in source code form is that
  same work.
  
    2. Basic Permissions.
  
    All rights granted under this License are granted for the term of
  copyright on the Program, and are irrevocable provided the stated
  conditions are met.  This License explicitly affirms your unlimited
  permission to run the unmodified Program.  The output from running a
  covered work is covered by this License only if the output, given its
  content, constitutes a covered work.  This License acknowledges your
  rights of fair use or other equivalent, as provided by copyright law.
  
    You may make, run and propagate covered works that you do not
  convey, without conditions so long as your license otherwise remains
  in force.  You may convey covered works to others for the sole purpose
  of having them make modifications exclusively for you, or provide you
  with facilities for running those works, provided that you comply with
  the terms of this License in conveying all material for which you do
  not control copyright.  Those thus making or running the covered works
  for you must do so exclusively on your behalf, under your direction
  and control, on terms that prohibit them from making any copies of
  your copyrighted material outside their relationship with you.
  
    Conveying under any other circumstances is permitted solely under
  the conditions stated below.  Sublicensing is not allowed; section 10
  makes it unnecessary.
  
    3. Protecting Users' Legal Rights From Anti-Circumvention Law.
  
    No covered work shall be deemed part of an effective technological
  measure under any applicable law fulfilling obligations under article
  11 of the WIPO copyright treaty adopted on 20 December 1996, or
  similar laws prohibiting or restricting circumvention of such
  measures.
  
    When you convey a covered work, you waive any legal power to forbid
  circumvention of technological measures to the extent such circumvention
  is effected by exercising rights under this License with respect to
  the covered work, and you disclaim any intention to limit operation or
  modification of the work as a means of enforcing, against the work's
  users, your or third parties' legal rights to forbid circumvention of
  technological measures.
  
    4. Conveying Verbatim Copies.
  
    You may convey verbatim copies of the Program's source code as you
  receive it, in any medium, provided that you conspicuously and
  appropriately publish on each copy an appropriate copyright notice;
  keep intact all notices stating that this License and any
  non-permissive terms added in accord with section 7 apply to the code;
  keep intact all notices of the absence of any warranty; and give all
  recipients a copy of this License along with the Program.
  
    You may charge any price or no price for each copy that you convey,
  and you may offer support or warranty protection for a fee.
  
    5. Conveying Modified Source Versions.
  
    You may convey a work based on the Program, or the modifications to
  produce it from the Program, in the form of source code under the
  terms of section 4, provided that you also meet all of these conditions:
  
      a) The work must carry prominent notices stating that you modified
      it, and giving a relevant date.
  
      b) The work must carry prominent notices stating that it is
      released under this License and any conditions added under section
      7.  This requirement modifies the requirement in section 4 to
      "keep intact all notices".
  
      c) You must license the entire work, as a whole, under this
      License to anyone who comes into possession of a copy.  This
      License will therefore apply, along with any applicable section 7
      additional terms, to the whole of the work, and all its parts,
      regardless of how they are packaged.  This License gives no
      permission to license the work in any other way, but it does not
      invalidate such permission if you have separately received it.
  
      d) If the work has interactive user interfaces, each must display
      Appropriate Legal Notices; however, if the Program has interactive
      interfaces that do not display Appropriate Legal Notices, your
      work need not make them do so.
  
    A compilation of a covered work with other separate and independent
  works, which are not by their nature extensions of the covered work,
  and which are not combined with it such as to form a larger program,
  in or on a volume of a storage or distribution medium, is called an
  "aggregate" if the compilation and its resulting copyright are not
  used to limit the access or legal rights of the compilation's users
  beyond what the individual works permit.  Inclusion of a covered work
  in an aggregate does not cause this License to apply to the other
  parts of the aggregate.
  
    6. Conveying Non-Source Forms.
  
    You may convey a covered work in object code form under the terms
  of sections 4 and 5, provided that you also convey the
  machine-readable Corresponding Source under the terms of this License,
  in one of these ways:
  
      a) Convey the object code in, or embodied in, a physical product
      (including a physical distribution medium), accompanied by the
      Corresponding Source fixed on a durable physical medium
      customarily used for software interchange.
  
      b) Convey the object code in, or embodied in, a physical product
      (including a physical distribution medium), accompanied by a
      written offer, valid for at least three years and valid for as
      long as you offer spare parts or customer support for that product
      model, to give anyone who possesses the object code either (1) a
      copy of the Corresponding Source for all the software in the
      product that is covered by this License, on a durable physical
      medium customarily used for software interchange, for a price no
      more than your reasonable cost of physically performing this
      conveying of source, or (2) access to copy the
      Corresponding Source from a network server at no charge.
  
      c) Convey individual copies of the object code with a copy of the
      written offer to provide the Corresponding Source.  This
      alternative is allowed only occasionally and noncommercially, and
      only if you received the object code with such an offer, in accord
      with subsection 6b.
  
      d) Convey the object code by offering access from a designated
      place (gratis or for a charge), and offer equivalent access to the
      Corresponding Source in the same way through the same place at no
      further charge.  You need not require recipients to copy the
      Corresponding Source along with the object code.  If the place to
      copy the object code is a network server, the Corresponding Source
      may be on a different server (operated by you or a third party)
      that supports equivalent copying facilities, provided you maintain
      clear directions next to the object code saying where to find the
      Corresponding Source.  Regardless of what server hosts the
      Corresponding Source, you remain obligated to ensure that it is
      available for as long as needed to satisfy these requirements.
  
      e) Convey the object code using peer-to-peer transmission, provided
      you inform other peers where the object code and Corresponding
      Source of the work are being offered to the general public at no
      charge under subsection 6d.
  
    A separable portion of the object code, whose source code is excluded
  from the Corresponding Source as a System Library, need not be
  included in conveying the object code work.
  
    A "User Product" is either (1) a "consumer product", which means any
  tangible personal property which is normally used for personal, family,
  or household purposes, or (2) anything designed or sold for incorporation
  into a dwelling.  In determining whether a product is a consumer product,
  doubtful cases shall be resolved in favor of coverage.  For a particular
  product received by a particular user, "normally used" refers to a
  typical or common use of that class of product, regardless of the status
  of the particular user or of the way in which the particular user
  actually uses, or expects or is expected to use, the product.  A product
  is a consumer product regardless of whether the product has substantial
  commercial, industrial or non-consumer uses, unless such uses represent
  the only significant mode of use of the product.
  
    "Installation Information" for a User Product means any methods,
  procedures, authorization keys, or other information required to install
  and execute modified versions of a covered work in that User Product from
  a modified version of its Corresponding Source.  The information must
  suffice to ensure that the continued functioning of the modified object
  code is in no case prevented or interfered with solely because
  modification has been made.
  
    If you convey an object code work under this section in, or with, or
  specifically for use in, a User Product, and the conveying occurs as
  part of a transaction in which the right of possession and use of the
  User Product is transferred to the recipient in perpetuity or for a
  fixed term (regardless of how the transaction is characterized), the
  Corresponding Source conveyed under this section must be accompanied
  by the Installation Information.  But this requirement does not apply
  if neither you nor any third party retains the ability to install
  modified object code on the User Product (for example, the work has
  been installed in ROM).
  
    The requirement to provide Installation Information does not include a
  requirement to continue to provide support service, warranty, or updates
  for a work that has been modified or installed by the recipient, or for
  the User Product in which it has been modified or installed.  Access to a
  network may be denied when the modification itself materially and
  adversely affects the operation of the network or violates the rules and
  protocols for communication across the network.
  
    Corresponding Source conveyed, and Installation Information provided,
  in accord with this section must be in a format that is publicly
  documented (and with an implementation available to the public in
  source code form), and must require no special password or key for
  unpacking, reading or copying.
  
    7. Additional Terms.
  
    "Additional permissions" are terms that supplement the terms of this
  License by making exceptions from one or more of its conditions.
  Additional permissions that are applicable to the entire Program shall
  be treated as though they were included in this License, to the extent
  that they are valid under applicable law.  If additional permissions
  apply only to part of the Program, that part may be used separately
  under those permissions, but the entire Program remains governed by
  this License without regard to the additional permissions.
  
    When you convey a copy of a covered work, you may at your option
  remove any additional permissions from that copy, or from any part of
  it.  (Additional permissions may be written to require their own
  removal in certain cases when you modify the work.)  You may place
  additional permissions on material, added by you to a covered work,
  for which you have or can give appropriate copyright permission.
  
    Notwithstanding any other provision of this License, for material you
  add to a covered work, you may (if authorized by the copyright holders of
  that material) supplement the terms of this License with terms:
  
      a) Disclaiming warranty or limiting liability differently from the
      terms of sections 15 and 16 of this License; or
  
      b) Requiring preservation of specified reasonable legal notices or
      author attributions in that material or in the Appropriate Legal
      Notices displayed by works containing it; or
  
      c) Prohibiting misrepresentation of the origin of that material, or
      requiring that modified versions of such material be marked in
      reasonable ways as different from the original version; or
  
      d) Limiting the use for publicity purposes of names of licensors or
      authors of the material; or
  
      e) Declining to grant rights under trademark law for use of some
      trade names, trademarks, or service marks; or
  
      f) Requiring indemnification of licensors and authors of that
      material by anyone who conveys the material (or modified versions of
      it) with contractual assumptions of liability to the recipient, for
      any liability that these contractual assumptions directly impose on
      those licensors and authors.
  
    All other non-permissive additional terms are considered "further
  restrictions" within the meaning of section 10.  If the Program as you
  received it, or any part of it, contains a notice stating that it is
  governed by this License along with a term that is a further
  restriction, you may remove that term.  If a license document contains
  a further restriction but permits relicensing or conveying under this
  License, you may add to a covered work material governed by the terms
  of that license document, provided that the further restriction does
  not survive such relicensing or conveying.
  
    If you add terms to a covered work in accord with this section, you
  must place, in the relevant source files, a statement of the
  additional terms that apply to those files, or a notice indicating
  where to find the applicable terms.
  
    Additional terms, permissive or non-permissive, may be stated in the
  form of a separately written license, or stated as exceptions;
  the above requirements apply either way.
  
    8. Termination.
  
    You may not propagate or modify a covered work except as expressly
  provided under this License.  Any attempt otherwise to propagate or
  modify it is void, and will automatically terminate your rights under
  this License (including any patent licenses granted under the third
  paragraph of section 11).
  
    However, if you cease all violation of this License, then your
  license from a particular copyright holder is reinstated (a)
  provisionally, unless and until the copyright holder explicitly and
  finally terminates your license, and (b) permanently, if the copyright
  holder fails to notify you of the violation by some reasonable means
  prior to 60 days after the cessation.
  
    Moreover, your license from a particular copyright holder is
  reinstated permanently if the copyright holder notifies you of the
  violation by some reasonable means, this is the first time you have
  received notice of violation of this License (for any work) from that
  copyright holder, and you cure the violation prior to 30 days after
  your receipt of the notice.
  
    Termination of your rights under this section does not terminate the
  licenses of parties who have received copies or rights from you under
  this License.  If your rights have been terminated and not permanently
  reinstated, you do not qualify to receive new licenses for the same
  material under section 10.
  
    9. Acceptance Not Required for Having Copies.
  
    You are not required to accept this License in order to receive or
  run a copy of the Program.  Ancillary propagation of a covered work
  occurring solely as a consequence of using peer-to-peer transmission
  to receive a copy likewise does not require acceptance.  However,
  nothing other than this License grants you permission to propagate or
  modify any covered work.  These actions infringe copyright if you do
  not accept this License.  Therefore, by modifying or propagating a
  covered work, you indicate your acceptance of this License to do so.
  
    10. Automatic Licensing of Downstream Recipients.
  
    Each time you convey a covered work, the recipient automatically
  receives a license from the original licensors, to run, modify and
  propagate that work, subject to this License.  You are not responsible
  for enforcing compliance by third parties with this License.
  
    An "entity transaction" is a transaction transferring control of an
  organization, or substantially all assets of one, or subdividing an
  organization, or merging organizations.  If propagation of a covered
  work results from an entity transaction, each party to that
  transaction who receives a copy of the work also receives whatever
  licenses to the work the party's predecessor in interest had or could
  give under the previous paragraph, plus a right to possession of the
  Corresponding Source of the work from the predecessor in interest, if
  the predecessor has it or can get it with reasonable efforts.
  
    You may not impose any further restrictions on the exercise of the
  rights granted or affirmed under this License.  For example, you may
  not impose a license fee, royalty, or other charge for exercise of
  rights granted under this License, and you may not initiate litigation
  (including a cross-claim or counterclaim in a lawsuit) alleging that
  any patent claim is infringed by making, using, selling, offering for
  sale, or importing the Program or any portion of it.
  
    11. Patents.
  
    A "contributor" is a copyright holder who authorizes use under this
  License of the Program or a work on which the Program is based.  The
  work thus licensed is called the contributor's "contributor version".
  
    A contributor's "essential patent claims" are all patent claims
  owned or controlled by the contributor, whether already acquired or
  hereafter acquired, that would be infringed by some manner, permitted
  by this License, of making, using, or selling its contributor version,
  but do not include claims that would be infringed only as a
  consequence of further modification of the contributor version.  For
  purposes of this definition, "control" includes the right to grant
  patent sublicenses in a manner consistent with the requirements of
  this License.
  
    Each contributor grants you a non-exclusive, worldwide, royalty-free
  patent license under the contributor's essential patent claims, to
  make, use, sell, offer for sale, import and otherwise run, modify and
  propagate the contents of its contributor version.
  
    In the following three paragraphs, a "patent license" is any express
  agreement or commitment, however denominated, not to enforce a patent
  (such as an express permission to practice a patent or covenant not to
  sue for patent infringement).  To "grant" such a patent license to a
  party means to make such an agreement or commitment not to enforce a
  patent against the party.
  
    If you convey a covered work, knowingly relying on a patent license,
  and the Corresponding Source of the work is not available for anyone
  to copy, free of charge and under the terms of this License, through a
  publicly available network server or other readily accessible means,
  then you must either (1) cause the Corresponding Source to be so
  available, or (2) arrange to deprive yourself of the benefit of the
  patent license for this particular work, or (3) arrange, in a manner
  consistent with the requirements of this License, to extend the patent
  license to downstream recipients.  "Knowingly relying" means you have
  actual knowledge that, but for the patent license, your conveying the
  covered work in a country, or your recipient's use of the covered work
  in a country, would infringe one or more identifiable patents in that
  country that you have reason to believe are valid.
  
    If, pursuant to or in connection with a single transaction or
  arrangement, you convey, or propagate by procuring conveyance of, a
  covered work, and grant a patent license to some of the parties
  receiving the covered work authorizing them to use, propagate, modify
  or convey a specific copy of the covered work, then the patent license
  you grant is automatically extended to all recipients of the covered
  work and works based on it.
  
    A patent license is "discriminatory" if it does not include within
  the scope of its coverage, prohibits the exercise of, or is
  conditioned on the non-exercise of one or more of the rights that are
  specifically granted under this License.  You may not convey a covered
  work if you are a party to an arrangement with a third party that is
  in the business of distributing software, under which you make payment
  to the third party based on the extent of your activity of conveying
  the work, and under which the third party grants, to any of the
  parties who would receive the covered work from you, a discriminatory
  patent license (a) in connection with copies of the covered work
  conveyed by you (or copies made from those copies), or (b) primarily
  for and in connection with specific products or compilations that
  contain the covered work, unless you entered into that arrangement,
  or that patent license was granted, prior to 28 March 2007.
  
    Nothing in this License shall be construed as excluding or limiting
  any implied license or other defenses to infringement that may
  otherwise be available to you under applicable patent law.
  
    12. No Surrender of Others' Freedom.
  
    If conditions are imposed on you (whether by court order, agreement or
  otherwise) that contradict the conditions of this License, they do not
  excuse you from the conditions of this License.  If you cannot convey a
  covered work so as to satisfy simultaneously your obligations under this
  License and any other pertinent obligations, then as a consequence you may
  not convey it at all.  For example, if you agree to terms that obligate you
  to collect a royalty for further conveying from those to whom you convey
  the Program, the only way you could satisfy both those terms and this
  License would be to refrain entirely from conveying the Program.
  
    13. Use with the GNU Affero General Public License.
  
    Notwithstanding any other provision of this License, you have
  permission to link or combine any covered work with a work licensed
  under version 3 of the GNU Affero General Public License into a single
  combined work, and to convey the resulting work.  The terms of this
  License will continue to apply to the part which is the covered work,
  but the special requirements of the GNU Affero General Public License,
  section 13, concerning interaction through a network will apply to the
  combination as such.
  
    14. Revised Versions of this License.
  
    The Free Software Foundation may publish revised and/or new versions of
  the GNU General Public License from time to time.  Such new versions will
  be similar in spirit to the present version, but may differ in detail to
  address new problems or concerns.
  
    Each version is given a distinguishing version number.  If the
  Program specifies that a certain numbered version of the GNU General
  Public License "or any later version" applies to it, you have the
  option of following the terms and conditions either of that numbered
  version or of any later version published by the Free Software
  Foundation.  If the Program does not specify a version number of the
  GNU General Public License, you may choose any version ever published
  by the Free Software Foundation.
  
    If the Program specifies that a proxy can decide which future
  versions of the GNU General Public License can be used, that proxy's
  public statement of acceptance of a version permanently authorizes you
  to choose that version for the Program.
  
    Later license versions may give you additional or different
  permissions.  However, no additional obligations are imposed on any
  author or copyright holder as a result of your choosing to follow a
  later version.
  
    15. Disclaimer of Warranty.
  
    THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
  APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
  HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
  OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
  IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
  ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
  
    16. Limitation of Liability.
  
    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
  THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
  GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
  USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
  DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
  PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
  EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
    17. Interpretation of Sections 15 and 16.
  
    If the disclaimer of warranty and limitation of liability provided
  above cannot be given local legal effect according to their terms,
  reviewing courts shall apply local law that most closely approximates
  an absolute waiver of all civil liability in connection with the
  Program, unless a warranty or assumption of liability accompanies a
  copy of the Program in return for a fee.
  
                       END OF TERMS AND CONDITIONS
  
              How to Apply These Terms to Your New Programs
  
    If you develop a new program, and you want it to be of the greatest
  possible use to the public, the best way to achieve this is to make it
  free software which everyone can redistribute and change under these terms.
  
    To do so, attach the following notices to the program.  It is safest
  to attach them to the start of each source file to most effectively
  state the exclusion of warranty; and each file should have at least
  the "copyright" line and a pointer to where the full notice is found.
  
      <one line to give the program's name and a brief idea of what it does.>
      Copyright (C) <year>  <name of author>
  
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with this program.  If not, see <https://www.gnu.org/licenses/>.
  
  Also add information on how to contact you by electronic and paper mail.
  
    If the program does terminal interaction, make it output a short
  notice like this when it starts in an interactive mode:
  
      <program>  Copyright (C) <year>  <name of author>
      This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
      This is free software, and you are welcome to redistribute it
      under certain conditions; type `show c' for details.
  
  The hypothetical commands `show w' and `show c' should show the appropriate
  parts of the General Public License.  Of course, your program's commands
  might be different; for a GUI interface, you would use an "about box".
  
    You should also get your employer (if you work as a programmer) or school,
  if any, to sign a "copyright disclaimer" for the program, if necessary.
  For more information on this, and how to apply and follow the GNU GPL, see
  <https://www.gnu.org/licenses/>.
  
    The GNU General Public License does not permit incorporating your program
  into proprietary programs.  If your program is a subroutine library, you
  may consider it more useful to permit linking proprietary applications with
  the library.  If this is what you want to do, use the GNU Lesser General
  Public License instead of this License.  But first, please read
  <https://www.gnu.org/licenses/why-not-lgpl.html>.
  =cut
ANYEVENT_CONSTANTS

$fatpacked{"ArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAYBUFFER';
  package ArrayBuffer;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Streams::_Common;
  use Streams::IOError;
  
  ## {array_buffer_data}'s value is a Data Block.  In Perl, it is
  ## represented as a reference to a byte string.
  
  ## Private
  our $CallerLevel = 0;
  
  ## ArrayBuffer constructor
  sub new ($$) {
    my $self = bless {caller => [caller $CallerLevel]}, $_[0];
    my $length = _to_index $_[1], 'Byte length';
  
    ## AllocateArrayBuffer
    {
      $self->{array_buffer_byte_length} = $length;
  
      #$self->{array_buffer_data} = \("\x00" x $length); # CreateByteDataBlock (can throw RangeError)
      ## Not in JS:
      $self->{array_buffer_data} = '';
      $self->{allocation_delayed} = 1;
    }
  
    return $self;
  } # new
  
  ## Not in JS
  sub new_from_scalarref ($$) {
    die _type_error "The argument is not a SCALAR"
        unless defined $_[1] and (ref $_[1] eq 'SCALAR' or ref $_[1] eq 'LVALUE');
    die _type_error "The argument is a utf8-flaged string" if utf8::is_utf8 ${$_[1]};
    my $self = bless {caller => [caller $CallerLevel]}, $_[0];
    my $length = _to_index length (${$_[1]}), 'Byte length';
  
    $self->{array_buffer_data} = $_[1];
    $self->{array_buffer_byte_length} = $length;
  
    return $self;
  } # new_from_scalarref
  
  ## TransferArrayBuffer, invoked by Streams Standard operations.  $self
  ## must be an ArrayBuffer that is not detached.
  sub _transfer ($) {
    my $transferred = bless {
      array_buffer_byte_length => $_[0]->{array_buffer_byte_length},
      array_buffer_data => $_[0]->{array_buffer_data},
      caller => [caller ($CallerLevel + 1)],
      label => 'transferred from ' . $_[0]->debug_info,
    }, (ref $_[0]);
    $transferred->{allocation_delayed} = 1
        if delete $_[0]->{allocation_delayed}; # Not in JS
  
    ## DetachArrayBuffer
    {
      $_[0]->{array_buffer_data} = undef;
      $_[0]->{array_buffer_byte_length} = 0;
    }
  
    return $transferred
  } # _transfer
  
  ## Not in JS
  sub manakai_transfer_to_scalarref ($) {
    die _type_error ('ArrayBuffer is detached')
        if not defined $_[0]->{array_buffer_data}; ## IsDetachedBuffer
  
    if ($_[0]->{allocation_delayed}) {
      $_[0]->{array_buffer_data} = \("\x00" x $_[0]->{array_buffer_byte_length});
    }
    my $ref = $_[0]->{array_buffer_data};
  
    ## DetachArrayBuffer
    {
      $_[0]->{array_buffer_data} = undef;
      $_[0]->{array_buffer_byte_length} = 0;
    }
  
    return $ref;
  } # manakai_transfer_to_scalarref
  
  ## Not in JS
  sub manakai_label ($;$) {
    if (@_ > 1) {
      $_[0]->{label} = $_[1];
    }
    return $_[0]->{label}; # or undef
  } # manakai_label
  
  ## CloneArrayBuffer (where cloneConstructor is $class), invoked by
  ## Typed Array and Streams Standard operations.  SharedArrayBuffer
  ## $src_buffer is not supported by this implementation.
  sub _clone ($$$$) {
    my ($class, $src_buffer, $src_byte_offset, $src_length) = @_;
  
    ## Assert: $src_byte_offset < $src_buffer->byte_length,
    ## $src_byte_offset + $src_length <= $src_buffer->byte_length (As
    ## this is a private method, these are not checked here.)
  
    ## Can throw RangeError (in AllocateArrayBuffer) here in theory, if
    ## $src_length is too large.
  
    die _type_error ('ArrayBuffer is detached')
        if not defined $src_buffer->{array_buffer_data}; ## IsDetachedBuffer
  
    _note_buffer_copy $src_length, $src_buffer->debug_info, 'new clone';
  
    ## AllocateArrayBuffer, CopyDataBlockBytes
    local $CallerLevel = $CallerLevel + 1;
    my $ab;
    if ($src_buffer->{allocation_delayed}) { # Not in JS
      my $target_block_value = "\x00" x $src_length;
      $ab = ArrayBuffer->new_from_scalarref (\$target_block_value);
    } else {
      my $target_block_value = substr (${$src_buffer->{array_buffer_data}}, $src_byte_offset, $src_length);
      $ab = ArrayBuffer->new_from_scalarref (\$target_block_value);
    }
  
    $ab->{label} = 'clone of ' . $src_buffer->debug_info;
    return $ab;
  } # _clone
  
  ## CopyDataBlockBytes, invoked by Streams Standard operations, without
  ## SharedArrayBuffer support.
  sub _copy_data_block_bytes ($$$$$) {
    my ($dest_buffer, $dest_offset, $src_buffer, $src_offset, $byte_count) = @_;
  
    _note_buffer_copy
        $byte_count, $src_buffer->debug_info, $dest_buffer->debug_info;
  
    if ($dest_buffer->{allocation_delayed}) {
      my $new_buffer = ("\x00" x $dest_offset) . (
       $src_buffer->{allocation_delayed}
           ? "\x00" x $byte_count
           : substr ${$src_buffer->{array_buffer_data}}, $src_offset, $byte_count
      ) . ("\x00" x ($dest_buffer->{array_buffer_byte_length} - $byte_count - $dest_offset));
      delete $dest_buffer->{allocation_delayed};
      $dest_buffer->{array_buffer_data} = \$new_buffer;
    } else { # $dest allocated
      if ($src_buffer->{allocation_delayed}) {
        substr (${$dest_buffer->{array_buffer_data}}, $dest_offset, $byte_count)
            = "\x00" x $byte_count;
      } else {
        substr (${$dest_buffer->{array_buffer_data}}, $dest_offset, $byte_count)
            = substr ${$src_buffer->{array_buffer_data}}, $src_offset, $byte_count;
      }
    }
  } # _copy_data_block_bytes
  
  sub byte_length ($) {
    my $self = $_[0];
    die _type_error ('ArrayBuffer is detached')
        if not defined $self->{array_buffer_data}; ## IsDetachedBuffer
    return $self->{array_buffer_byte_length};
  } # byte_length
  
  ## Not in JS
  sub manakai_syswrite ($$;$$) {
    my $self = $_[0];
    die _type_error ('ArrayBuffer is detached')
        if not defined $self->{array_buffer_data}; ## IsDetachedBuffer
    my $length = defined $_[2] ? (_to_index $_[2], 'Byte length') : $self->{array_buffer_byte_length};
    my $offset = _to_index $_[3] || 0, 'Byte offset';
    my $l = syswrite $_[1], (
      $self->{allocation_delayed}
        ? "\x00" x $length
        : ${$self->{array_buffer_data}}
    ), $length, $offset;
    die Streams::IOError->new ($!) unless defined $l;
    _note_buffer_copy $l, $self->debug_info, 'syswrite' if $l > 0;
    return $l;
  } # manakai_syswrite
  
  ## Not in JS
  sub debug_info ($) {
    return '{' . (
      join ' ', grep { defined }
          'ArrayBuffer',
          $_[0]->{label},
          (defined $_[0]->{array_buffer_data}
               ? 'l=' . $_[0]->{array_buffer_byte_length} : 'detached'),
          "file $_[0]->{caller}->[1]",
          "line $_[0]->{caller}->[2]",
    ) . '}';
  } # debug_info
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/) {
      warn "$$: Reference to ".$_[0]->debug_info." is not discarded before global destruction\n";
    }
  } # DESTROY
  
  1;
  
  ## XXX Not implemented (yet):
  ## $class->is_view
  ## $self->slice
  
  =head1 LICENSE
  
  Copyright 2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
ARRAYBUFFER

$fatpacked{"DataView.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATAVIEW';
  package DataView;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Streams::_Common;
  push our @ISA, qw(ArrayBufferView);
  
  sub new ($$;$$) {
    my $self = bless {}, $_[0];
  
    my $buffer = $_[1];
    die _type_error "The argument is not an ArrayBuffer"
        unless defined $buffer and UNIVERSAL::isa ($buffer, 'ArrayBuffer'); ## has [[ArrayBufferData]]
    my $offset = _to_index $_[2] || 0, 'Offset';
    die _type_error "ArrayBuffer is detached"
        if not defined $buffer->{array_buffer_data}; ## IsDetachedBuffer
    my $buffer_byte_length = $buffer->{array_buffer_byte_length};
    die _range_error "Offset $offset > buffer length $buffer_byte_length"
        if $offset > $buffer_byte_length;
    my $view_byte_length;
    if (defined $_[3]) {
      $view_byte_length = _to_index $_[3], 'Byte length';
      die _range_error
          "Offset $offset + length $view_byte_length > buffer length $buffer_byte_length"
              if $offset + $view_byte_length > $buffer_byte_length;
    } else {
      $view_byte_length = $buffer_byte_length - $offset;
    }
    #$self->{data_view} = undef;
    $self->{viewed_array_buffer} = $buffer;
    $self->{byte_length} = $view_byte_length;
    $self->{byte_offset} = $offset;
    return $self;
  } # new
  
  sub buffer ($) {
    return $_[0]->{viewed_array_buffer};
  } # buffer
  
  sub byte_length ($) {
    my $self = $_[0];
    die _type_error "ArrayBuffer is detached"
        if not defined $self->{viewed_array_buffer}
            ->{array_buffer_data}; ## IsDetachedBuffer
    return $self->{byte_length};
  } # byte_length
  
  sub byte_offset ($) {
    my $self = $_[0];
    die _type_error "ArrayBuffer is detached"
        if not defined $self->{viewed_array_buffer}
            ->{array_buffer_data}; ## IsDetachedBuffer
    return $self->{byte_offset};
  } # byte_offset
  
  sub manakai_to_string ($) {
    my $self = $_[0];
    die _type_error "ArrayBuffer is detached"
        if not defined $self->{viewed_array_buffer}
            ->{array_buffer_data}; ## IsDetachedBuffer
  
    my $buffer = $self->{viewed_array_buffer};
    _note_buffer_copy $self->{byte_length}, $buffer->debug_info, "string";
    if ($buffer->{allocation_delayed}) {
      return "\x00" x $self->{byte_length};
    } else {
      return substr ${$buffer->{array_buffer_data}},
          $self->{byte_offset}, $self->{byte_length};
    }
  } # manakai_to_string
  
  ## Not implemented yet:
  ##   $object->get_* set_*
  
  1;
  
  =head1 LICENSE
  
  Copyright 2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DATAVIEW

$fatpacked{"JSON/PS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PS';
  package JSON::PS;
  use strict;
  use warnings;
  no warnings 'utf8';
  use warnings FATAL => 'recursion';
  our $VERSION = '4.0';
  use B;
  use Carp;
  
  BEGIN {
    if (eval q{ use Web::Encoding (); 1 }) {
      *_du = \&Web::Encoding::decode_web_utf8;
      *_eu = \&Web::Encoding::encode_web_utf8;
    } else {
      require Encode;
      *_du = sub { return scalar Encode::decode ('utf-8', $_[0]) };
      *_eu = sub { return scalar Encode::encode ('utf-8', $_[0]) };
    }
  }
  
  our @EXPORT;
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
  } # import
  
  our $OnError ||= sub {
    warn sprintf "%s at index %d\n", $_[0]->{type}, $_[0]->{index} || 0;
  }; # $OnError
  
  my $_OnError = sub {
    if (ref $_[0] eq 'HASH') {
      $OnError->($_[0]);
    } else {
      $OnError->({type => $_[0]});
    }
  }; # $_OnError
  
  my $EscapeToChar = {
    '"' => q<">,
    '\\' => q<\\>,
    '/' => q</>,
    'b' => "\x08",
    'f' => "\x0C",
    'n' => "\x0A",
    'r' => "\x0D",
    't' => "\x09",
  };
  
  sub _decode_value ($);
  sub _decode_value ($) {
    if ($_[0] =~ /\G"([\x20\x21\x23-\x5B\x5D-\x7E]*)"/gc) {
      return $1;
    } elsif ($_[0] =~ /\G(-?(?>[1-9][0-9]*|0)(?>\.[0-9]+)?(?>[eE][+-]?[0-9]+)?)/gc) {
      return 1*(0+$1);
    } elsif ($_[0] =~ /\G"/gc) {
      my @s;
      while (1) {
        if ($_[0] =~ /\G([^\x22\x5C\x00-\x1F]+)/gc) {
          push @s, $1;
        } elsif ($_[0] =~ m{\G\\(["\\/bfnrt])}gc) {
          push @s, $EscapeToChar->{$1};
        } elsif ($_[0] =~ /\G\\u([Dd][89ABab][0-9A-Fa-f]{2})\\u([Dd][C-Fc-f][0-9A-Fa-f]{2})/gc) {
          push @s, chr (0x10000 + ((hex ($1) - 0xD800) << 10) + (hex ($2) - 0xDC00));
        } elsif ($_[0] =~ /\G\\u([0-9A-Fa-f]{4})/gc) {
          push @s, chr hex $1;
        } elsif ($_[0] =~ /\G"/gc) {
          last;
        } else {
          die {index => pos $_[0], type => 'json:bad string'};
        }
      }
      return join '', @s;
    } elsif ($_[0] =~ m{\G\{}gc) {
      my $obj = {};
      $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
      if ($_[0] =~ /\G\}/gc) {
        #
      } else {
        OBJECT: {
          my $name;
          if ($_[0] =~ /\G"([\x20\x21\x23-\x5B\x5D-\x7E]*)"/gc) {
            $name = $1;
          } elsif ($_[0] =~ /\G(?=\")/gc) {
            $name = _decode_value $_[0];
          }
          if (defined $name) {
            $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
            if ($_[0] =~ /\G:/gc) {
              $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
              # XXX duplicate $name warning
              $obj->{$name} = _decode_value $_[0];
              $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
              if ($_[0] =~ /\G,/gc) {
                $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
                redo OBJECT;
              } elsif ($_[0] =~ /\G\}/gc) {
                last OBJECT;
              } else {
                die {index => pos $_[0], type => 'json:bad object sep'};
              }
            } else {
              die {index => pos $_[0], type => 'json:bad object nv sep'};
            }
          } else {
            die {index => pos $_[0], type => 'json:bad object name'};
          }
        } # OBJECT
      }
      return $obj;
    } elsif ($_[0] =~ m{\G\[}gc) {
      my @item;
      $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
      if ($_[0] =~ /\G\]/gc) {
        #
      } else {
        ARRAY: {
          push @item, _decode_value $_[0];
          $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
          if ($_[0] =~ /\G,/gc) {
            $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
            redo ARRAY;
          } elsif ($_[0] =~ /\G\]/gc) {
            last ARRAY;
          } else {
            die {index => pos $_[0], type => 'json:bad array sep'};
          }
        } # ARRAY
      }
      return \@item;
    } elsif ($_[0] =~ /\Gtrue/gc) {
      return 1;
    } elsif ($_[0] =~ /\Gfalse/gc) {
      return 0;
    } elsif ($_[0] =~ /\Gnull/gc) {
      return undef;
    } else {
      die {index => pos $_[0], type => 'json:bad value'};
    }
  } # _decode_value
  
  sub _decode ($) {
    return undef unless defined $_[0];
    pos ($_[0]) = 0;
    $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
    my $result = _decode_value $_[0];
    $_[0] =~ /\G[\x09\x0A\x0D\x20]+/gc;
    die {index => pos $_[0], type => 'json:eof expected'} if $_[0] =~ /\G./gcs;
    return $result;
  } # _decode
  
  push @EXPORT, qw(json_bytes2perl);
  sub json_bytes2perl ($) {
    local $@;
    if (utf8::is_utf8 ($_[0])) { # backcompat
      my $value = scalar eval { _decode $_[0] };
      $_OnError->($@) if $@;
      return $value;
    } else {
      my $value = scalar eval { _decode _du $_[0] };
      $_OnError->($@) if $@;
      return $value;
    }
  } # json_bytes2perl
  
  push @EXPORT, qw(json_chars2perl);
  sub json_chars2perl ($) {
    local $@;
    my $value = scalar eval { _decode $_[0] };
    $_OnError->($@) if $@;
    return $value;
  } # json_chars2perl
  
  my $StringNonSafe = qr/[\x00-\x1F\x22\x5C\x2B\x3C\x7F-\x9F\x{2028}\x{2029}\x{D800}-\x{DFFF}\x{FDD0}-\x{FDEF}\x{FFFE}-\x{FFFF}\x{1FFFE}-\x{1FFFF}\x{2FFFE}-\x{2FFFF}\x{3FFFE}-\x{3FFFF}\x{4FFFE}-\x{4FFFF}\x{5FFFE}-\x{5FFFF}\x{6FFFE}-\x{6FFFF}\x{7FFFE}-\x{7FFFF}\x{8FFFE}-\x{8FFFF}\x{9FFFE}-\x{9FFFF}\x{AFFFE}-\x{AFFFF}\x{BFFFE}-\x{BFFFF}\x{CFFFE}-\x{CFFFF}\x{DFFFE}-\x{DFFFF}\x{EFFFE}-\x{EFFFF}\x{FFFFE}-\x{FFFFF}\x{10FFFE}-\x{10FFFF}]/;
  
  our $Symbols = {
    LBRACE => '{',
    RBRACE => '}',
    LBRACKET => '[',
    RBRACKET => ']',
    COLON => ':',
    COMMA => ',',
    indent => '',
    last => '',
    sort => 0,
  };
  my $PrettySymbols = {
    LBRACE => "{\x0A",
    RBRACE => '}',
    LBRACKET => "[\x0A",
    RBRACKET => ']',
    COLON => ' : ',
    COMMA => ",\x0A",
    indent => '   ',
    last => "\x0A",
    sort => 1,
  };
  
  sub _encode_value ($$);
  sub _encode_value ($$) {
    if (defined $_[0]) {
      if (my $ref = ref $_[0]) {
        if (UNIVERSAL::can ($_[0], 'TO_JSON')) {
          return _encode_value $_[0]->TO_JSON, $_[1];
        }
  
        if ($ref eq 'ARRAY') {
          my $indent = $_[1].$Symbols->{indent};
          my @v = map { $indent, (_encode_value $_, $indent), $Symbols->{COMMA} } @{$_[0]};
          $v[-1] = $Symbols->{last} if @v;
          return $Symbols->{LBRACKET}, @v, $_[1], $Symbols->{RBRACKET};
        }
  
        if ($ref eq 'HASH') {
          my $indent = $_[1].$Symbols->{indent};
          my @key = keys %{$_[0]};
          @key = sort { $a cmp $b } @key if $Symbols->{sort};
          my @v = map {
            if ($_ =~ /$StringNonSafe/o) {
              my $v = $_;
              $v =~ s{($StringNonSafe)}{
                my $c = ord $1;
                if ($c >= 0x10000) {
                  sprintf '\\u%04X\\u%04X',
                      (($c - 0x10000) >> 10) + 0xD800,
                      (($c - 0x10000) & 0x3FF) + 0xDC00;
                } else {
                  sprintf '\\u%04X', $c;
                }
              }geo;
              $indent, '"', $v, '"', $Symbols->{COLON}, _encode_value ($_[0]->{$_}, $indent), $Symbols->{COMMA};
            } else {
              $indent, '"', $_, '"', $Symbols->{COLON}, _encode_value ($_[0]->{$_}, $indent), $Symbols->{COMMA};
            }
          } @key;
          $v[-1] = $Symbols->{last} if @v;
          return $Symbols->{LBRACE}, @v, $_[1], $Symbols->{RBRACE};
        }
  
        if ($ref eq 'SCALAR') {
          if (defined ${$_[0]} and not ref ${$_[0]}) {
            if (${$_[0]} eq '1') {
              return 'true';
            } elsif (${$_[0]} eq '0') {
              return 'false';
            }
          }
        } else {
          if (Types::Serialiser->can ('is_bool')) {
            if (Types::Serialiser::is_true ($_[0])) {
              return 'true';
            } elsif (Types::Serialiser::is_false ($_[0])) {
              return 'false';
            }
          }
        }
      } # $ref
  
      my $f = B::svref_2object (\($_[0]))->FLAGS;
      if ($f & (B::SVp_IOK | B::SVp_NOK) && $_[0] * 0 == 0) {
        my $n = 0 + $_[0];
        if ($n =~ /\A(-?(?>[1-9][0-9]*|0)(?>\.[0-9]+)?(?>[eE][+-]?[0-9]+)?)\z/) {
          return $n;
        }
      }
  
      if ($_[0] =~ /$StringNonSafe/o) {
        my $v = $_[0];
        $v =~ s{($StringNonSafe)}{
          my $c = ord $1;
          if ($c >= 0x10000) {
            sprintf '\\u%04X\\u%04X',
                (($c - 0x10000) >> 10) + 0xD800,
                (($c - 0x10000) & 0x3FF) + 0xDC00;
          } else {
            sprintf '\\u%04X', $c;
          }
        }geo;
        return '"', $v, '"';
      } else {
        return '"', $_[0], '"';
      }
    } else {
      return 'null';
    }
  } # _encode_value
  
  push @EXPORT, qw(perl2json_bytes);
  sub perl2json_bytes ($) {
    return _eu join '', _encode_value $_[0], '';
  } # perl2json_bytes
  
  push @EXPORT, qw(perl2json_chars);
  sub perl2json_chars ($) {
    return scalar join '', _encode_value $_[0], '';
  } # perl2json_chars
  
  push @EXPORT, qw(perl2json_bytes_for_record);
  sub perl2json_bytes_for_record ($) {
    local $Symbols = $PrettySymbols;
    return _eu join '', _encode_value ($_[0], ''), "\x0A";
  } # perl2json_bytes_for_record
  
  push @EXPORT, qw(perl2json_chars_for_record);
  sub perl2json_chars_for_record ($) {
    local $Symbols = $PrettySymbols;
    return scalar join '', _encode_value ($_[0], ''), "\x0A";
  } # perl2json_chars_for_record
  
  ## Deprecated
  #push @EXPORT_OK, qw(file2perl);
  sub file2perl ($) {
    return json_chars2perl _du scalar $_[0]->slurp;
  } # file2perl
  
  1;
  
  =head1 LICENSE
  
  Copyright 2014-2019 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
JSON_PS

$fatpacked{"Main.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAIN';
  package Main;
  use strict;
  use warnings;
  use Path::Tiny;
  use Time::HiRes qw(time);
  use ArrayBuffer;
  use DataView;
  use Promise;
  use Promised::Flow;
  use Promised::File;
  use Promised::Command;
  use JSON::PS;
  
  my $Executors = {
    perl => {
      exts => [qw(t)],
    },
  }; # $Executors
  my $Ext2Executors = {};
  for my $xtype (sort { $a cmp $b } keys %$Executors) {
    for (@{$Executors->{$xtype}->{exts} or []}) {
      $Ext2Executors->{$_} = $xtype;
    }
  }
  
  sub _files ($$$$);
  sub _files ($$$$) {
    my ($base, $names, $files, $is_sub) = @_;
    my $in_names = {};
    if (not $is_sub) {
      $in_names->{$_} = 1 for @$names;
    }
    my $files2 = [];
    return ((promised_for {
      my $name = $_[0];
      my $path = path ($name)->absolute ($base);
      my $file = Promised::File->new_from_path ($path);
      return $file->is_file->then (sub {
        if ($_[0]) {
          push @$files, {path => $path, file_name => $name,
                         specified => $in_names->{$name}};
        } else {
          return $file->is_directory->then (sub {
            if ($_[0]) {
              return $file->get_child_names->then (sub {
                return _files $path, [sort { $a cmp $b } @{$_[0]}], $files2, 1;
              }, sub {
                my $e = shift;
                my $msg;
                if (UNIVERSAL::can ($e, 'message')) {
                  if (UNIVERSAL::can ($e, 'name')) {
                    $msg = $e->name . ': ' . $e->message;
                  } else {
                    $msg = '' . $e->message;
                  }
                } else {
                  $msg = '' . $e;
                }
                push @$files, {path => $path,
                               file_name => $name,
                               specified => $in_names->{$name},
                               time => time,
                               error => {
                                 message => $msg,
                               }};
              });
            } else {
              push @$files, {path => $path,
                             file_name => $name,
                             specified => $in_names->{$name},
                             time => time,
                             error => {
                               message => "Failed to read a file or directory",
                             }};
            }
          });
        }
      });
    } $names)->then (sub {
      push @$files, @$files2;
    }));
  } # _files
  
  sub expand_files ($$) {
    my ($rule, $args) = @_;
  
    if (@$args) {
      $rule->{files} = $args;
    }
  
    unless (defined $rule->{files} and
            ref $rule->{files} eq 'ARRAY') {
      ## Default for Perl
      $rule->{files} = ['t'];
    }
  
    my $files = [];
    return _files ($rule->{base_dir}, $rule->{files}, $files, 0)->then (sub {
      return $files;
    });
  } # expand_files
  
  sub filter_files ($) {
    my $in_files = shift;
    my $out_files = [];
    my $found = {};
    for my $file (@$in_files) {
      next if $found->{$file->{path}}++;
      if ($file->{error}) {
        push @$out_files, $file;
      } else {
        my $ext = undef;
        $ext = $1 if $file->{file_name} =~ /\.([^\.]+)\z/;
        my $xtype = $Ext2Executors->{$ext};
        if (defined $xtype) {
          $file->{executor} = {type => $xtype};
          push @$out_files, $file;
        } else {
          if ($file->{specified}) {
            $file->{error} = {message => "No test executor found"};
            push @$out_files, $file;
          }
        }
      }
    }
    $out_files = [sort { $a->{path} cmp $b->{path} } @$out_files];
    return $out_files;
  } # filter_files
  
  sub load_executors ($$) {
    my ($env, $result) = @_;
    return promised_for {
      my $xtype = shift;
      my $xenv = $env->{executors}->{$xtype};
      if ($xtype eq 'perl') {
        my $perl_path = $env->{base_dir_path}->child ('perl');
        my $perl_file = Promised::File->new_from_path ($perl_path);
        return $perl_file->is_executable->then (sub {
          if ($_[0]) {
            $xenv->{perl_command} = [$perl_path->absolute];
          } else {
            $xenv->{perl_command} = ['perl'];
          }
          $result->{executors}->{$xtype}->{perl_command} = [map { '' . $_ } @{$xenv->{perl_command}}];
        });
      } # $xtype
    } [keys %{$env->{executors}}];
  } # load_executors
  
  sub process_files ($$$) {
    my ($env, $file_paths, $result) = @_;
  
    my $count = 0+@$file_paths;
    my $n = 1;
    return promised_for {
      my $file = shift;
      my $file_name = $file->{path}->relative ($env->{base_dir_path});
      my $fr = $result->{file_results}->{$file_name} = {
        result => {ok => 0},
        times => {start => time},
      };
  
      if ($file->{error}) {
        $fr->{times}->{end} = $fr->{times}->{start} = $file->{time};
        $fr->{error} = $file->{error};
        $result->{result}->{fail}++;
        return;
      }
  
      $fr->{executor} = $file->{executor};
  
      print STDERR "$n/$count [$fr->{executor}->{type}] $file_name...";
      $n++;
  
      #$fr->{executor}->{type} eq 'perl'
      my $xenv = $env->{executors}->{$fr->{executor}->{type}};
  
      my $cmd = Promised::Command->new ([
        @{$xenv->{perl_command}},
        $file->{path},
      ]);
  
      my $escaped_name = $file_name;
      $escaped_name =~ s{([^A-Za-z0-9])}{sprintf '_%02X', ord $1}ge;
      my $output_path = $env->{result_dir_path}->child ('files')
          ->child ($escaped_name . '.txt');
      $fr->{output_file} = '' . $output_path->relative ($env->{result_dir_path});
      my $output_ws = Promised::File->new_from_path ($output_path)->write_bytes;
      my $output_w = $output_ws->get_writer;
      my $output_chunk = sub {
        my ($h, $chunk) = @_;
        print STDERR ".";
        my $v = sprintf "\x0A&%d %d %.9f\x0A",
            $h,
            $chunk->byte_length,
            time;
        $output_w->write (DataView->new (ArrayBuffer->new_from_scalarref (\$v)));
        return $output_w->write ($chunk);
      };
      my $closed = sub {
        my ($h) = @_;
        my $v = sprintf "\x0A&%d -1 %.9f\x0A",
            $h,
            time;
        return $output_w->write (DataView->new (ArrayBuffer->new_from_scalarref (\$v)));
      };
      my @wait;
      my $so_rs = $cmd->get_stdout_stream;
      my $so_r = $so_rs->get_reader ('byob');
      push @wait, promised_until {
        return $so_r->read (DataView->new (ArrayBuffer->new (1024)))->then (sub {
          if ($_[0]->{done}) {
            push @wait, $closed->(1);
            return 'done';
          }
          return $output_chunk->(1, $_[0]->{value})->then (sub {
            return not 'done';
          });
        });
      };
      my $se_rs = $cmd->get_stderr_stream;
      my $se_r = $se_rs->get_reader ('byob');
      push @wait, promised_until {
        return $se_r->read (DataView->new (ArrayBuffer->new (1024)))->then (sub {
          if ($_[0]->{done}) {
            push @wait, $closed->(2);
            return 'done';
          }
          return $output_chunk->(2, $_[0]->{value})->then (sub {
            return not 'done';
          });
        });
      };
      return $cmd->run->then (sub {
        return $cmd->wait;
      })->then (sub {
        my $cr = $_[0];
        $fr->{times}->{end} = time;
        $fr->{result}->{exit_code} = $cr->exit_code;
        die $cr unless $cr->exit_code == 0;
        $fr->{result}->{ok} = 1;
        $result->{result}->{pass}++;
        warn " PASS\n";
      })->catch (sub {
        my $e = $_[0];
        $fr->{times}->{end} //= time;
        $fr->{error}->{message} = ''.$e;
        warn " FAIL\n";
        $result->{result}->{fail}++;
      })->finally (sub {
        return $output_w->close;
      })->finally (sub {
        return Promise->all (\@wait);
      });
    } $file_paths;
  } # process_files
  
  sub main ($@) {
    my ($class, @args) = @_;
    
    my $rule = {};
    my $result = {result => {exit_code => 1, pass => 0, fail => 0},
                  times => {start => time},
                  file_results => {}, executors => {}};
    my $env = {executors => {}};
    return Promise->resolve->then (sub {
      $rule->{base_dir} = '.' unless defined $rule->{base_dir};
      $env->{base_dir_path} = path ($rule->{base_dir})->absolute;
      $result->{rule}->{base_dir} = '' . $env->{base_dir_path};
  
      my $ca = $ENV{CIRCLE_ARTIFACTS} // '';
      if (length $ca) {
        $env->{result_dir_path} = path ($ca)->absolute;
      } else {
        $env->{result_dir_path} = $env->{base_dir_path}->child ('local/test');
      }
      $result->{rule}->{result_dir} = '' . $env->{result_dir_path};
  
      $env->{result_json_path} = $env->{result_dir_path}->child ('result.json');
      $result->{result}->{json_file} = '' . $env->{result_json_path}->relative ($env->{result_dir_path});
  
      return expand_files $rule, \@args;
    })->then (sub {
      my $files = $_[0];
      return filter_files $files;
    })->then (sub {
      my $files = $_[0];
      $result->{files} = [map {
        $env->{executors}->{$_->{executor}->{type}} = {} if defined $_->{executor};
        {file_name_path => '' . $_->{path}->relative ($env->{base_dir_path})};
      } @$files];
      return load_executors ($env, $result)->then (sub {
        return process_files $env, $files => $result;
      });
    })->then (sub {
      if ($result->{result}->{fail}) {
        #$result->{result}->{exit_code} = 1;
      } else {
        $result->{result}->{exit_code} = 0;
        $result->{result}->{ok} = 1;
      }
    })->catch (sub {
      my $error = $_[0];
      $result->{result}->{error} = '' . $error;
      $result->{result}->{exit_code} = 1;
      warn "ERROR: $error\n";
    })->then (sub {
      $result->{times}->{end} = time;
      my $result_json_file = Promised::File->new_from_path
          ($env->{result_json_path});
      return $result_json_file->write_byte_string (perl2json_bytes $result);
    })->then (sub {
      warn sprintf "Result: |%s|\n",
          $env->{result_json_path};
      warn sprintf "Pass: %d, Fail: %d\n",
          $result->{result}->{pass}, $result->{result}->{fail};
      if ($result->{result}->{exit_code} == 0) {
        warn "Test passed\n";
      } else {
        warn "Test failed\n";
      }
      return $result;
    });
  } # main
  
  1;
  
  =head1 LICENSE
  
  Copyright 2018-2022 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
MAIN

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  
  our $VERSION = '0.104';
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 0.86 ();          # shipped with 5.8.1
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_BSD   => ( scalar $^O =~ /bsd$/ ),
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  # FREEZE/THAW per Sereal/CBOR/Types::Serialiser protocol
  sub FREEZE { return $_[0]->[PATH] }
  sub THAW   { return path( $_[2] ) }
  { no warnings 'once'; *TO_JSON = *FREEZE };
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      !!eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  my $HAS_PU; # has PerlIO::utf8_strict; lazily populated
  
  sub _check_PU {
      !!eval { require PerlIO::utf8_strict; PerlIO::utf8_strict->VERSION(0.003); 1 };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?$}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT$/ ) : ( $_[0] eq '/' );
  }
  
  BEGIN {
      *_same = IS_WIN32() ? sub { lc( $_[0] ) eq lc( $_[1] ) } : sub { $_[0] eq $_[1] };
  }
  
  # mode bits encoded for chmod in symbolic mode
  my %MODEBITS = ( om => 0007, gm => 0070, um => 0700 ); ## no critic
  { my $m = 0; $MODEBITS{$_} = ( 1 << $m++ ) for qw/ox ow or gx gw gr ux uw ur/ };
  
  sub _symbolic_chmod {
      my ( $mode, $symbolic ) = @_;
      for my $clause ( split /,\s*/, $symbolic ) {
          if ( $clause =~ m{\A([augo]+)([=+-])([rwx]+)\z} ) {
              my ( $who, $action, $perms ) = ( $1, $2, $3 );
              $who =~ s/a/ugo/g;
              for my $w ( split //, $who ) {
                  my $p = 0;
                  $p |= $MODEBITS{"$w$_"} for split //, $perms;
                  if ( $action eq '=' ) {
                      $mode = ( $mode & ~$MODEBITS{"${w}m"} ) | $p;
                  }
                  else {
                      $mode = $action eq "+" ? ( $mode | $p ) : ( $mode & ~$p );
                  }
              }
          }
          else {
              Carp::croak("Invalid mode clause '$clause' for chmod()");
          }
      }
      return $mode;
  }
  
  # flock doesn't work on NFS on BSD.  Since program authors often can't control
  # or detect that, we warn once instead of being fatal if we can detect it and
  # people who need it strict can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use if Path::Tiny::IS_BSD(), 'warnings::register' }
  #>>>
  
  my $WARNED_BSD_NFS = 0;
  
  sub _throw {
      my ( $self, $function, $file, $msg ) = @_;
      if (   IS_BSD()
          && $function =~ /^flock/
          && $! =~ /operation not supported/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_BSD_NFS ) {
              warnings::warn( flock => "No flock for NFS on BSD: continuing in unsafe mode" );
              $WARNED_BSD_NFS++;
          }
      }
      else {
          $msg = $! unless defined $msg;
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ),
              $msg );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  #pod =construct path
  #pod
  #pod     $path = path("foo/bar");
  #pod     $path = path("/tmp", "file.txt"); # list
  #pod     $path = path(".");                # cwd
  #pod     $path = path("~user/file.txt");   # tilde processing
  #pod
  #pod Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  #pod directory path.  It's still up to you to call directory-like methods only on
  #pod directories and file-like methods only on files.  This function is exported
  #pod automatically by default.
  #pod
  #pod The first argument must be defined and have non-zero length or an exception
  #pod will be thrown.  This prevents subtle, dangerous errors with code like
  #pod C<< path( maybe_undef() )->remove_tree >>.
  #pod
  #pod If the first component of the path is a tilde ('~') then the component will be
  #pod replaced with the output of C<glob('~')>.  If the first component of the path
  #pod is a tilde followed by a user name then the component will be replaced with
  #pod output of C<glob('~username')>.  Behaviour for non-existent users depends on
  #pod the output of C<glob> on the system.
  #pod
  #pod On Windows, if the path consists of a drive identifier without a path component
  #pod (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  #pod directory on that volume using C<Cwd::getdcwd()>.
  #pod
  #pod If called with a single C<Path::Tiny> argument, the original is returned unless
  #pod the original is holding a temporary file or directory reference in which case a
  #pod stringified copy is made.
  #pod
  #pod     $path = path("foo/bar");
  #pod     $temp = Path::Tiny->tempfile;
  #pod
  #pod     $p2 = path($path); # like $p2 = $path
  #pod     $t2 = path($temp); # like $t2 = path( "$temp" )
  #pod
  #pod This optimizes copies without proliferating references unexpectedly if a copy is
  #pod made by code outside your control.
  #pod
  #pod Current API available since 0.017.
  #pod
  #pod =cut
  
  sub path {
      my $path = shift;
      Carp::croak("Path::Tiny paths require defined, positive-length parts")
        unless 1 + @_ == grep { defined && length } $path, @_;
  
      # non-temp Path::Tiny objects are effectively immutable and can be reused
      if ( !@_ && ref($path) eq __PACKAGE__ && !$path->[TEMP] ) {
          return $path;
      }
  
      # stringify objects
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};
          $path .= "/" if $path =~ m{^$UNC_VOL$};
      }
  
      # concatenations stringifies objects, too
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize, but with unix slashes and put back trailing volume slash
      my $cpath = $path = File::Spec->canonpath($path);
      $path =~ tr[\\][/] if IS_WIN32();
      $path = "/" if $path eq '/..'; # for old File::Spec
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL$};
  
      # root paths must always have a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?$}{/};
      }
      else {
          $path =~ s{/$}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          require File::Glob;
          my ($homedir) = File::Glob::bsd_glob($1);
          $homedir =~ tr[\\][/] if IS_WIN32();
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  #pod =construct new
  #pod
  #pod     $path = Path::Tiny->new("foo/bar");
  #pod
  #pod This is just like C<path>, but with method call overhead.  (Why would you
  #pod do that?)
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub new { shift; path(@_) }
  
  #pod =construct cwd
  #pod
  #pod     $path = Path::Tiny->cwd; # path( Cwd::getcwd )
  #pod     $path = cwd; # optional export
  #pod
  #pod Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  #pod This is slightly faster than C<< path(".")->absolute >>.
  #pod
  #pod C<cwd> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  #pod =construct rootdir
  #pod
  #pod     $path = Path::Tiny->rootdir; # /
  #pod     $path = rootdir;             # optional export 
  #pod
  #pod Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  #pod picky for C<path("/")>.
  #pod
  #pod C<rootdir> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  #pod =construct tempfile, tempdir
  #pod
  #pod     $temp = Path::Tiny->tempfile( @options );
  #pod     $temp = Path::Tiny->tempdir( @options );
  #pod     $temp = tempfile( @options ); # optional export
  #pod     $temp = tempdir( @options );  # optional export
  #pod
  #pod C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  #pod object with the file name.  The C<TMPDIR> option is enabled by default.
  #pod
  #pod The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  #pod destroyed, the C<File::Temp> object will be as well.
  #pod
  #pod C<File::Temp> annoyingly requires you to specify a custom template in slightly
  #pod different ways depending on which function or method you call, but
  #pod C<Path::Tiny> lets you ignore that and can take either a leading template or a
  #pod C<TEMPLATE> option and does the right thing.
  #pod
  #pod     $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
  #pod     $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  #pod
  #pod The tempfile path object will be normalized to have an absolute path, even if
  #pod created in a relative directory using C<DIR>.  If you want it to have
  #pod the C<realpath> instead, pass a leading options hash like this:
  #pod
  #pod     $real_temp = tempfile({realpath => 1}, @options);
  #pod
  #pod C<tempdir> is just like C<tempfile>, except it calls
  #pod C<< File::Temp->newdir >> instead.
  #pod
  #pod Both C<tempfile> and C<tempdir> may be exported on request and used as
  #pod functions instead of as methods.
  #pod
  #pod B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  #pod reused.  This is not as secure as using File::Temp handles directly, but is
  #pod less prone to deadlocks or access problems on some platforms.  Think of what
  #pod C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  #pod up.
  #pod
  #pod B<Note 2>: if you don't want these cleaned up automatically when the object
  #pod is destroyed, File::Temp requires different options for directories and
  #pod files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  #pod files.
  #pod
  #pod B<Note 3>: Don't lose the temporary object by chaining a method call instead
  #pod of storing it:
  #pod
  #pod     my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  #pod
  #pod B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  #pod Keeping a reference to, or modifying the cached object may break the
  #pod behavior documented above and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.097.
  #pod
  #pod =cut
  
  sub tempfile {
      shift if @_ && $_[0] eq 'Path::Tiny'; # called as method
      my $opts = ( @_ && ref $_[0] eq 'HASH' ) ? shift @_ : {};
      $opts = _get_args( $opts, qw/realpath/ );
  
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = $opts->{realpath} ? path($temp)->realpath : path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if @_ && $_[0] eq 'Path::Tiny'; # called as method
      my $opts = ( @_ && ref $_[0] eq 'HASH' ) ? shift @_ : {};
      $opts = _get_args( $opts, qw/realpath/ );
  
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = $opts->{realpath} ? path($temp)->realpath : path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      # Some ActiveState Perls for Windows break Cwd in ways that lead
      # File::Temp to get confused about what path to remove; this
      # monkey-patches the object with our own view of the absolute path
      $temp->{REALNAME} = $self->[CANON] if IS_WIN32;
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  sub _resolve_symlinks {
      my ($self) = @_;
      my $new = $self;
      my ( $count, %seen ) = 0;
      while ( -l $new->[PATH] ) {
          if ( $seen{ $new->[PATH] }++ ) {
              $self->_throw( 'readlink', $self->[PATH], "symlink loop detected" );
          }
          if ( ++$count > 100 ) {
              $self->_throw( 'readlink', $self->[PATH], "maximum symlink depth exceeded" );
          }
          my $resolved = readlink $new->[PATH] or $new->_throw( 'readlink', $new->[PATH] );
          $resolved = path($resolved);
          $new = $resolved->is_absolute ? $resolved : $new->sibling($resolved);
      }
      return $new;
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  #pod =method absolute
  #pod
  #pod     $abs = path("foo/bar")->absolute;
  #pod     $abs = path("foo/bar")->absolute("/tmp");
  #pod
  #pod Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  #pod absolute).  If no argument is given, the current directory is used as the
  #pod absolute base path.  If an argument is given, it will be converted to an
  #pod absolute path (if it is not already) and used as the absolute base path.
  #pod
  #pod This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  #pod in L<File::Spec> would normally do so on your platform.  If you need them
  #pod resolved, you must call the more expensive C<realpath> method instead.
  #pod
  #pod On Windows, an absolute path without a volume component will have it added
  #pod based on the current drive.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # no base means use current directory as base
      require Cwd;
      return path( Cwd::getcwd(), $_[0]->[PATH] ) unless defined $base;
  
      # relative base should be made absolute; we check is_absolute rather
      # than unconditionally make base absolute so that "/foo" doesn't become
      # "C:/foo" on Windows.
      $base = path($base);
      return path( ( $base->is_absolute ? $base : $base->absolute ), $_[0]->[PATH] );
  }
  
  #pod =method append, append_raw, append_utf8
  #pod
  #pod     path("foo.txt")->append(@data);
  #pod     path("foo.txt")->append(\@data);
  #pod     path("foo.txt")->append({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->append_raw(@data);
  #pod     path("foo.txt")->append_utf8(@data);
  #pod
  #pod Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  #pod optional hash reference may be used to pass options.  Valid options are:
  #pod
  #pod =for :list
  #pod * C<binmode>: passed to C<binmode()> on the handle used for writing.
  #pod * C<truncate>: truncates the file after locking and before appending
  #pod
  #pod The C<truncate> option is a way to replace the contents of a file
  #pod B<in place>, unlike L</spew> which writes to a temporary file and then
  #pod replaces the original (if it exists).
  #pod
  #pod C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<append_utf8> is like C<append> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw append will be done instead on the data encoded
  #pod with C<Unicode::UTF8>.
  #pod
  #pod Current API available since 0.060.
  #pod
  #pod =cut
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $mode = $args->{truncate} ? ">" : ">>";
      my $fh = $self->filehandle( { locked => 1 }, $mode, $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      $args->{binmode} = ':unix';
      append( $self, $args, @data );
  }
  
  sub append_utf8 {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          $args->{binmode} = ":unix";
          append( $self, $args, map { Unicode::UTF8::encode_utf8($_) } @data );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          append( $self, $args, @data );
      }
      else {
          $args->{binmode} = ":unix:encoding(UTF-8)";
          append( $self, $args, @data );
      }
  }
  
  #pod =method assert
  #pod
  #pod     $path = path("foo.txt")->assert( sub { $_->exists } );
  #pod
  #pod Returns the invocant after asserting that a code reference argument returns
  #pod true.  When the assertion code reference runs, it will have the invocant
  #pod object in the C<$_> variable.  If it returns false, an exception will be
  #pod thrown.  The assertion code reference may also throw its own exception.
  #pod
  #pod If no assertion is provided, the invocant is returned without error.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut
  
  sub assert {
      my ( $self, $assertion ) = @_;
      return $self unless $assertion;
      if ( ref $assertion eq 'CODE' ) {
          local $_ = $self;
          $assertion->()
            or Path::Tiny::Error->throw( "assert", $self->[PATH], "failed assertion" );
      }
      else {
          Carp::croak("argument to assert must be a code reference argument");
      }
      return $self;
  }
  
  #pod =method basename
  #pod
  #pod     $name = path("foo/bar.txt")->basename;        # bar.txt
  #pod     $name = path("foo.txt")->basename('.txt');    # foo
  #pod     $name = path("foo.txt")->basename(qr/.txt/);  # foo
  #pod     $name = path("foo.txt")->basename(@suffixes);
  #pod
  #pod Returns the file portion or last directory portion of a path.
  #pod
  #pod Given a list of suffixes as strings or regular expressions, any that match at
  #pod the end of the file portion or last directory portion will be removed before
  #pod the result is returned.
  #pod
  #pod Current API available since 0.054.
  #pod
  #pod =cut
  
  sub basename {
      my ( $self, @suffixes ) = @_;
      $self->_splitpath unless defined $self->[FILE];
      my $file = $self->[FILE];
      for my $s (@suffixes) {
          my $re = ref($s) eq 'Regexp' ? qr/$s$/ : qr/\Q$s\E$/;
          last if $file =~ s/$re//;
      }
      return $file;
  }
  
  #pod =method canonpath
  #pod
  #pod     $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  #pod
  #pod Returns a string with the canonical format of the path name for
  #pod the platform.  In particular, this means directory separators
  #pod will be C<\> on Windows.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub canonpath { $_[0]->[CANON] }
  
  #pod =method cached_temp
  #pod
  #pod Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  #pod C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  #pod If there is no such object, this method throws.
  #pod
  #pod B<WARNING>: Keeping a reference to, or modifying the cached object may
  #pod break the behavior documented for temporary files and directories created
  #pod with C<Path::Tiny> and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut
  
  sub cached_temp {
      my $self = shift;
      $self->_throw( "cached_temp", $self, "has no cached File::Temp object" )
        unless defined $self->[TEMP];
      return $self->[TEMP];
  }
  
  #pod =method child
  #pod
  #pod     $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
  #pod     $file = path("/tmp")->child(@parts);
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the original.  Works
  #pod like C<catfile> or C<catdir> from File::Spec, but without caring about
  #pod file or directories.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  #pod =method children
  #pod
  #pod     @paths = path("/tmp")->children;
  #pod     @paths = path("/tmp")->children( qr/\.txt$/ );
  #pod
  #pod Returns a list of C<Path::Tiny> objects for all files and directories
  #pod within a directory.  Excludes "." and ".." automatically.
  #pod
  #pod If an optional C<qr//> argument is provided, it only returns objects for child
  #pod names that match the given regular expression.  Only the base name is used
  #pod for matching:
  #pod
  #pod     @paths = path("/tmp")->children( qr/^foo/ );
  #pod     # matches children like the glob foo*
  #pod
  #pod Current API available since 0.028.
  #pod
  #pod =cut
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  #pod =method chmod
  #pod
  #pod     path("foo.txt")->chmod(0777);
  #pod     path("foo.txt")->chmod("0755");
  #pod     path("foo.txt")->chmod("go-w");
  #pod     path("foo.txt")->chmod("a=r,u+wx");
  #pod
  #pod Sets file or directory permissions.  The argument can be a numeric mode, a
  #pod octal string beginning with a "0" or a limited subset of the symbolic mode use
  #pod by F</bin/chmod>.
  #pod
  #pod The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  #pod match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  #pod "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  #pod are required for each clause, multiple ops are not allowed and permissions
  #pod C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut
  
  sub chmod {
      my ( $self, $new_mode ) = @_;
  
      my $mode;
      if ( $new_mode =~ /\d/ ) {
          $mode = ( $new_mode =~ /^0/ ? oct($new_mode) : $new_mode );
      }
      elsif ( $new_mode =~ /[=+-]/ ) {
          $mode = _symbolic_chmod( $self->stat->mode & 07777, $new_mode ); ## no critic
      }
      else {
          Carp::croak("Invalid mode argument '$new_mode' for chmod()");
      }
  
      CORE::chmod( $mode, $self->[PATH] ) or $self->_throw("chmod");
  
      return 1;
  }
  
  #pod =method copy
  #pod
  #pod     path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  #pod
  #pod Copies the current path to the given destination using L<File::Copy>'s
  #pod C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  #pod newly copied file.
  #pod
  #pod Current API available since 0.070.
  #pod
  #pod =cut
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  
      return -d $dest ? path( $dest, $self->basename ) : path($dest);
  }
  
  #pod =method digest
  #pod
  #pod     $obj = path("/tmp/foo.txt")->digest;        # SHA-256
  #pod     $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  #pod     $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  #pod
  #pod Returns a hexadecimal digest for a file.  An optional hash reference of options may
  #pod be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  #pod bytes will be read at a time.  If not provided, the entire file will be slurped
  #pod into memory to compute the digest.
  #pod
  #pod Any subsequent arguments are passed to the constructor for L<Digest> to select
  #pod an algorithm.  If no arguments are given, the default is SHA-256.
  #pod
  #pod Current API available since 0.056.
  #pod
  #pod =cut
  
  sub digest {
      my ( $self, @opts ) = @_;
      my $args = ( @opts && ref $opts[0] eq 'HASH' ) ? shift @opts : {};
      $args = _get_args( $args, qw/chunk_size/ );
      unshift @opts, 'SHA-256' unless @opts;
      require Digest;
      my $digest = Digest->new(@opts);
      if ( $args->{chunk_size} ) {
          my $fh = $self->filehandle( { locked => 1 }, "<", ":unix" );
          my $buf;
          $digest->add($buf) while read $fh, $buf, $args->{chunk_size};
      }
      else {
          $digest->add( $self->slurp_raw );
      }
      return $digest->hexdigest;
  }
  
  #pod =method dirname (deprecated)
  #pod
  #pod     $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  #pod
  #pod Returns the directory portion you would get from calling
  #pod C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  #pod parent directory portion.  Because L<File::Spec> is inconsistent, the result
  #pod might or might not have a trailing slash.  Because of this, this method is
  #pod B<deprecated>.
  #pod
  #pod A better, more consistently approach is likely C<< $path->parent->stringify >>,
  #pod which will not have a trailing slash except for a root directory.
  #pod
  #pod Deprecated in 0.056.
  #pod
  #pod =cut
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  #pod =method edit, edit_raw, edit_utf8
  #pod
  #pod     path("foo.txt")->edit( \&callback, $options );
  #pod     path("foo.txt")->edit_utf8( \&callback );
  #pod     path("foo.txt")->edit_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file using a single
  #pod callback argument. They slurp the file using C<slurp>, place the contents
  #pod inside a localized C<$_> variable, call the callback function (without
  #pod arguments), and then write C<$_> (presumably mutated) back to the
  #pod file with C<spew>.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to C<slurp> and C<spew>.
  #pod
  #pod C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  #pod C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut
  
  sub edit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      local $_ =
        $self->slurp( exists( $args->{binmode} ) ? { binmode => $args->{binmode} } : () );
      $cb->();
      $self->spew( $args, $_ );
  
      return;
  }
  
  # this is done long-hand to benefit from slurp_utf8 optimizations
  sub edit_utf8 {
      my ( $self, $cb ) = @_;
      Carp::croak("Callback for edit_utf8() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      local $_ = $self->slurp_utf8;
      $cb->();
      $self->spew_utf8($_);
  
      return;
  }
  
  sub edit_raw { $_[2] = { binmode => ":unix" }; goto &edit }
  
  #pod =method edit_lines, edit_lines_utf8, edit_lines_raw
  #pod
  #pod     path("foo.txt")->edit_lines( \&callback, $options );
  #pod     path("foo.txt")->edit_lines_utf8( \&callback );
  #pod     path("foo.txt")->edit_lines_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file's lines using a
  #pod single callback argument.  They iterate over the file: for each line, the
  #pod line is put into a localized C<$_> variable, the callback function is
  #pod executed (without arguments) and then C<$_> is written to a temporary file.
  #pod When iteration is finished, the temporary file is atomically renamed over
  #pod the original.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to the method that open handles for reading and
  #pod writing.
  #pod
  #pod C<edit_lines_utf8> and C<edit_lines_raw> act like their respective
  #pod C<slurp_*> and C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut
  
  sub edit_lines {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit_lines() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
  
      # writing need to follow the link and create the tempfile in the same
      # dir for later atomic rename
      my $resolved_path = $self->_resolve_symlinks;
      my $temp          = path( $resolved_path . $$ . int( rand( 2**31 ) ) );
  
      my $temp_fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      my $in_fh = $self->filehandle( { locked => 1 }, '<', $binmode );
  
      local $_;
      while (<$in_fh>) {
          $cb->();
          $temp_fh->print($_);
      }
  
      close $temp_fh or $self->_throw( 'close', $temp );
      close $in_fh or $self->_throw('close');
  
      return $temp->move($resolved_path);
  }
  
  sub edit_lines_raw { $_[2] = { binmode => ":unix" }; goto &edit_lines }
  
  sub edit_lines_utf8 {
      $_[2] = { binmode => ":raw:encoding(UTF-8)" };
      goto &edit_lines;
  }
  
  #pod =method exists, is_file, is_dir
  #pod
  #pod     if ( path("/tmp")->exists ) { ... }     # -e
  #pod     if ( path("/tmp")->is_dir ) { ... }     # -d
  #pod     if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  #pod
  #pod Implements file test operations, this means the file or directory actually has
  #pod to exist on the filesystem.  Until then, it's just a path.
  #pod
  #pod B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  #pod C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  #pod read just like files.
  #pod
  #pod Use C<-f> instead if you really mean to check for a plain file.
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -e $_[0]->[PATH] && !-d _ }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  #pod =method filehandle
  #pod
  #pod     $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  #pod
  #pod Returns an open file handle.  The C<$mode> argument must be a Perl-style
  #pod read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  #pod is given, it is set during the C<open> call.
  #pod
  #pod An optional hash reference may be used to pass options.
  #pod
  #pod The C<locked> option governs file locking; if true, handles opened for writing,
  #pod appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  #pod locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  #pod truncation until after the lock is acquired.
  #pod
  #pod The C<exclusive> option causes the open() call to fail if the file already
  #pod exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  #pod C<exclusive> implies C<locked> and will set it for you if you forget it.
  #pod
  #pod See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  #pod
  #pod Current API available since 0.066.
  #pod
  #pod =cut
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked exclusive/ );
      $args->{locked} = 1 if $args->{exclusive};
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              $flags |= Fcntl::O_EXCL() if $args->{exclusive};
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX if
              # the file is writable; otherwise give up on locking.  N.B.
              # checking -w before open to determine the open mode is an
              # unavoidable race condition
              if ( -w $self->[PATH] ) {
                  $opentype = "+<";
                  $lock     = Fcntl::LOCK_EX();
              }
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  #pod =method is_absolute, is_relative
  #pod
  #pod     if ( path("/tmp")->is_absolute ) { ... }
  #pod     if ( path("/tmp")->is_relative ) { ... }
  #pod
  #pod Booleans for whether the path appears absolute or relative.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  #pod =method is_rootdir
  #pod
  #pod     while ( ! $path->is_rootdir ) {
  #pod         $path = $path->parent;
  #pod         ...
  #pod     }
  #pod
  #pod Boolean for whether the path is the root directory of the volume.  I.e. the
  #pod C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  #pod
  #pod This works even on C<MSWin32> with drives and UNC volumes:
  #pod
  #pod     path("C:/")->is_rootdir;             # true
  #pod     path("//server/share/")->is_rootdir; #true
  #pod
  #pod Current API available since 0.038.
  #pod
  #pod =cut
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  #pod =method iterator
  #pod
  #pod     $iter = path("/tmp")->iterator( \%options );
  #pod
  #pod Returns a code reference that walks a directory lazily.  Each invocation
  #pod returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  #pod
  #pod     $iter = path("/tmp")->iterator;
  #pod     while ( $path = $iter->() ) {
  #pod         ...
  #pod     }
  #pod
  #pod The current and parent directory entries ("." and "..") will not
  #pod be included.
  #pod
  #pod If the C<recurse> option is true, the iterator will walk the directory
  #pod recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  #pod directory links will be followed recursively.  There is no protection against
  #pod loops when following links. If a directory is not readable, it will not be
  #pod followed.
  #pod
  #pod The default is the same as:
  #pod
  #pod     $iter = path("/tmp")->iterator( {
  #pod         recurse         => 0,
  #pod         follow_symlinks => 0,
  #pod     } );
  #pod
  #pod For a more powerful, recursive iterator with built-in loop avoidance, see
  #pod L<Path::Iterator::Rule>.
  #pod
  #pod See also L</visit>.
  #pod
  #pod Current API available since 0.016.
  #pod
  #pod =cut
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  #pod =method lines, lines_raw, lines_utf8
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines;
  #pod     @contents = path("/tmp/foo.txt")->lines(\%options);
  #pod     @contents = path("/tmp/foo.txt")->lines_raw;
  #pod     @contents = path("/tmp/foo.txt")->lines_utf8;
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  #pod
  #pod Returns a list of lines from a file.  Optionally takes a hash-reference of
  #pod options.  Valid options are C<binmode>, C<count> and C<chomp>.
  #pod
  #pod If C<binmode> is provided, it will be set on the handle prior to reading.
  #pod
  #pod If a positive C<count> is provided, that many lines will be returned from the
  #pod start of the file.  If a negative C<count> is provided, the entire file will be
  #pod read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  #pod exceeds the number of lines in the file, all lines will be returned.
  #pod
  #pod If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  #pod C<LF>) will be removed from the lines returned.
  #pod
  #pod Because the return is a list, C<lines> in scalar context will return the number
  #pod of lines (and throw away the data).
  #pod
  #pod     $number_of_lines = path("/tmp/foo.txt")->lines;
  #pod
  #pod C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  #pod instead of C<:unix> so PerlIO buffering can manage reading by line.
  #pod
  #pod C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  #pod (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  #pod UTF-8 slurp will be done and then the lines will be split.  This is
  #pod actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  #pod intensive.  If memory use is a concern, consider C<openr_utf8> and
  #pod iterating directly on the handle.
  #pod
  #pod Current API available since 0.065.
  #pod
  #pod =cut
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( $counter, $mod, @result ) = ( 0, abs( $args->{count} ) );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if $chomp;
              $result[ $counter++ ] = $line;
              # for positive count, terminate after right number of lines
              last if $counter == $args->{count};
              # for negative count, eventually wrap around in the result array
              $counter %= $mod;
          }
          # reorder results if full and wrapped somewhere in the middle
          splice( @result, 0, 0, splice( @result, $counter ) )
            if @result == $mod && $counter % $mod;
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})$//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  my $CRLF = qr/(?:\x{0d}?\x{0a}|\x{0d})/;
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) )
          && $args->{chomp}
          && !$args->{count} )
      {
          my $slurp = slurp_utf8($self);
          $slurp =~ s/$CRLF$//; # like chomp, but full CR?LF|CR
          return split $CRLF, $slurp, -1; ## no critic
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          return lines( $self, $args );
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  #pod =method mkpath
  #pod
  #pod     path("foo/bar/baz")->mkpath;
  #pod     path("foo/bar/baz")->mkpath( \%options );
  #pod
  #pod Like calling C<make_path> from L<File::Path>.  An optional hash reference
  #pod is passed through to C<make_path>.  Errors will be trapped and an exception
  #pod thrown.  Returns the list of directories created or an empty list if
  #pod the directories already exist, just like C<make_path>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  #pod =method move
  #pod
  #pod     path("foo.txt")->move("bar.txt");
  #pod
  #pod Move the current path to the given destination path using Perl's
  #pod built-in L<rename|perlfunc/rename> function. Returns the result
  #pod of the C<rename> function.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst" );
  }
  
  #pod =method openr, openw, openrw, opena
  #pod
  #pod     $fh = path("foo.txt")->openr($binmode);  # read
  #pod     $fh = path("foo.txt")->openr_raw;
  #pod     $fh = path("foo.txt")->openr_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openw($binmode);  # write
  #pod     $fh = path("foo.txt")->openw_raw;
  #pod     $fh = path("foo.txt")->openw_utf8;
  #pod
  #pod     $fh = path("foo.txt")->opena($binmode);  # append
  #pod     $fh = path("foo.txt")->opena_raw;
  #pod     $fh = path("foo.txt")->opena_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openrw($binmode); # read/write
  #pod     $fh = path("foo.txt")->openrw_raw;
  #pod     $fh = path("foo.txt")->openrw_utf8;
  #pod
  #pod Returns a file handle opened in the specified mode.  The C<openr> style methods
  #pod take a single C<binmode> argument.  All of the C<open*> methods have
  #pod C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  #pod C<:raw:encoding(UTF-8)>, respectively.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<locked>.  If true, handles opened for writing, appending or read-write are
  #pod locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  #pod
  #pod     $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  #pod
  #pod See L</filehandle> for more on locking.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  #pod =method parent
  #pod
  #pod     $parent = path("foo/bar/baz")->parent; # foo/bar
  #pod     $parent = path("foo/wibble.txt")->parent; # foo
  #pod
  #pod     $parent = path("foo/bar/baz")->parent(2); # foo
  #pod
  #pod Returns a C<Path::Tiny> object corresponding to the parent directory of the
  #pod original directory or file. An optional positive integer argument is the number
  #pod of parent directories upwards to return.  C<parent> by itself is equivalent to
  #pod C<parent(1)>.
  #pod
  #pod Current API available since 0.014.
  #pod
  #pod =cut
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.$)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  #pod =method realpath
  #pod
  #pod     $real = path("/baz/foo/../bar")->realpath;
  #pod     $real = path("foo/../bar")->realpath;
  #pod
  #pod Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  #pod parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  #pod more expensive as it must actually consult the filesystem.
  #pod
  #pod If the parent path can't be resolved (e.g. if it includes directories that
  #pod don't exist), an exception will be thrown:
  #pod
  #pod     $real = path("doesnt_exist/foo")->realpath; # dies
  #pod
  #pod However, if the parent path exists and only the last component (e.g. filename)
  #pod doesn't exist, the realpath will be the realpath of the parent plus the
  #pod non-existent last component:
  #pod
  #pod     $real = path("./aasdlfasdlf")->realpath; # works
  #pod
  #pod The underlying L<Cwd> module usually worked this way on Unix, but died on
  #pod Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  #pod it's safe to use anywhere.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  # Win32 and some Unixes need parent path resolved separately so realpath
  # doesn't throw an error resolving non-existent basename
  sub realpath {
      my $self = shift;
      $self = $self->_resolve_symlinks;
      require Cwd;
      $self->_splitpath if !defined $self->[FILE];
      my $check_parent =
        length $self->[FILE] && $self->[FILE] ne '.' && $self->[FILE] ne '..';
      my $realpath = eval {
          # pure-perl Cwd can carp
          local $SIG{__WARN__} = sub { };
          Cwd::realpath( $check_parent ? $self->parent->[PATH] : $self->[PATH] );
      };
      # parent realpath must exist; not all Cwd::realpath will error if it doesn't
      $self->_throw("resolving realpath")
        unless defined $realpath && length $realpath && -e $realpath;
      return ( $check_parent ? path( $realpath, $self->[FILE] ) : path($realpath) );
  }
  
  #pod =method relative
  #pod
  #pod     $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  #pod
  #pod Returns a C<Path::Tiny> object with a path relative to a new base path
  #pod given as an argument.  If no argument is given, the current directory will
  #pod be used as the new base path.
  #pod
  #pod If either path is already relative, it will be made absolute based on the
  #pod current directly before determining the new relative path.
  #pod
  #pod The algorithm is roughly as follows:
  #pod
  #pod =for :list
  #pod * If the original and new base path are on different volumes, an exception
  #pod   will be thrown.
  #pod * If the original and new base are identical, the relative path is C<".">.
  #pod * If the new base subsumes the original, the relative path is the original
  #pod   path with the new base chopped off the front
  #pod * If the new base does not subsume the original, a common prefix path is
  #pod   determined (possibly the root directory) and the relative path will
  #pod   consist of updirs (C<"..">) to reach the common prefix, followed by the
  #pod   original path less the common prefix.
  #pod
  #pod Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  #pod on a common prefix takes into account symlinks that could affect the updir
  #pod process.  Given an original path "/A/B" and a new base "/A/C",
  #pod (where "A", "B" and "C" could each have multiple path components):
  #pod
  #pod =for :list
  #pod * Symlinks in "A" don't change the result unless the last component of A is
  #pod   a symlink and the first component of "C" is an updir.
  #pod * Symlinks in "B" don't change the result and will exist in the result as
  #pod   given.
  #pod * Symlinks and updirs in "C" must be resolved to actual paths, taking into
  #pod   account the possibility that not all path components might exist on the
  #pod   filesystem.
  #pod
  #pod Current API available since 0.001.  New algorithm (that accounts for
  #pod symlinks) available since 0.079.
  #pod
  #pod =cut
  
  sub relative {
      my ( $self, $base ) = @_;
      $base = path( defined $base && length $base ? $base : '.' );
  
      # relative paths must be converted to absolute first
      $self = $self->absolute if $self->is_relative;
      $base = $base->absolute if $base->is_relative;
  
      # normalize volumes if they exist
      $self = $self->absolute if !length $self->volume && length $base->volume;
      $base = $base->absolute if length $self->volume  && !length $base->volume;
  
      # can't make paths relative across volumes
      if ( !_same( $self->volume, $base->volume ) ) {
          Carp::croak("relative() can't cross volumes: '$self' vs '$base'");
      }
  
      # if same absolute path, relative is current directory
      return path(".") if _same( $self->[PATH], $base->[PATH] );
  
      # if base is a prefix of self, chop prefix off self
      if ( $base->subsumes($self) ) {
          $base = "" if $base->is_rootdir;
          my $relative = "$self";
          $relative =~ s{\A\Q$base/}{};
          return path($relative);
      }
  
      # base is not a prefix, so must find a common prefix (even if root)
      my ( @common, @self_parts, @base_parts );
      @base_parts = split /\//, $base->_just_filepath;
  
      # if self is rootdir, then common directory is root (shown as empty
      # string for later joins); otherwise, must be computed from path parts.
      if ( $self->is_rootdir ) {
          @common = ("");
          shift @base_parts;
      }
      else {
          @self_parts = split /\//, $self->_just_filepath;
  
          while ( @self_parts && @base_parts && _same( $self_parts[0], $base_parts[0] ) ) {
              push @common, shift @base_parts;
              shift @self_parts;
          }
      }
  
      # if there are any symlinks from common to base, we have a problem, as
      # you can't guarantee that updir from base reaches the common prefix;
      # we must resolve symlinks and try again; likewise, any updirs are
      # a problem as it throws off calculation of updirs needed to get from
      # self's path to the common prefix.
      if ( my $new_base = $self->_resolve_between( \@common, \@base_parts ) ) {
          return $self->relative($new_base);
      }
  
      # otherwise, symlinks in common or from common to A don't matter as
      # those don't involve updirs
      my @new_path = ( ("..") x ( 0+ @base_parts ), @self_parts );
      return path(@new_path);
  }
  
  sub _just_filepath {
      my $self     = shift;
      my $self_vol = $self->volume;
      return "$self" if !length $self_vol;
  
      ( my $self_path = "$self" ) =~ s{\A\Q$self_vol}{};
  
      return $self_path;
  }
  
  sub _resolve_between {
      my ( $self, $common, $base ) = @_;
      my $path = $self->volume . join( "/", @$common );
      my $changed = 0;
      for my $p (@$base) {
          $path .= "/$p";
          if ( $p eq '..' ) {
              $changed = 1;
              if ( -e $path ) {
                  $path = path($path)->realpath->[PATH];
              }
              else {
                  $path =~ s{/[^/]+/..$}{/};
              }
          }
          if ( -l $path ) {
              $changed = 1;
              $path    = path($path)->realpath->[PATH];
          }
      }
      return $changed ? path($path) : undef;
  }
  
  #pod =method remove
  #pod
  #pod     path("foo.txt")->remove;
  #pod
  #pod This is just like C<unlink>, except for its error handling: if the path does
  #pod not exist, it returns false; if deleting the file fails, it throws an
  #pod exception.
  #pod
  #pod Current API available since 0.012.
  #pod
  #pod =cut
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink( $self->[PATH] ) || $self->_throw('unlink');
  }
  
  #pod =method remove_tree
  #pod
  #pod     # directory
  #pod     path("foo/bar/baz")->remove_tree;
  #pod     path("foo/bar/baz")->remove_tree( \%options );
  #pod     path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  #pod
  #pod Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  #pod An optional hash reference is passed through to C<remove_tree>.  Errors will be
  #pod trapped and an exception thrown.  Returns the number of directories deleted,
  #pod just like C<remove_tree>.
  #pod
  #pod If you want to remove a directory only if it is empty, use the built-in
  #pod C<rmdir> function instead.
  #pod
  #pod     rmdir path("foo/bar/baz/");
  #pod
  #pod Current API available since 0.013.
  #pod
  #pod =cut
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      $args->{safe}  = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  #pod =method sibling
  #pod
  #pod     $foo = path("/tmp/foo.txt");
  #pod     $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
  #pod     $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the parent of the original.
  #pod This is slightly more efficient than C<< $path->parent->child(...) >>.
  #pod
  #pod Current API available since 0.058.
  #pod
  #pod =cut
  
  sub sibling {
      my $self = shift;
      return path( $self->parent->[PATH], @_ );
  }
  
  #pod =method slurp, slurp_raw, slurp_utf8
  #pod
  #pod     $data = path("foo.txt")->slurp;
  #pod     $data = path("foo.txt")->slurp( {binmode => ":raw"} );
  #pod     $data = path("foo.txt")->slurp_raw;
  #pod     $data = path("foo.txt")->slurp_utf8;
  #pod
  #pod Reads file contents into a scalar.  Takes an optional hash reference which may
  #pod be used to pass options.  The only available option is C<binmode>, which is
  #pod passed to C<binmode()> on the handle used for reading.
  #pod
  #pod C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  #pod a fast, unbuffered, raw read.
  #pod
  #pod C<slurp_utf8> is like C<slurp> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw slurp will be done instead and the result decoded
  #pod with C<Unicode::UTF8>.  This is just as strict and is roughly an order of
  #pod magnitude faster than using C<:encoding(UTF-8)>.
  #pod
  #pod B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  #pod you plan to slurp from a file created with L<File::Temp>, be sure to
  #pod close other handles or open without locking to avoid a deadlock:
  #pod
  #pod     my $tempfile = File::Temp->new(EXLOCK => 0);
  #pod     my $guts = path($tempfile)->slurp;
  #pod
  #pod Current API available since 0.004.
  #pod
  #pod =cut
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $_[1] = { binmode => ":unix:utf8_strict" };
          goto &slurp;
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  #pod =method spew, spew_raw, spew_utf8
  #pod
  #pod     path("foo.txt")->spew(@data);
  #pod     path("foo.txt")->spew(\@data);
  #pod     path("foo.txt")->spew({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->spew_raw(@data);
  #pod     path("foo.txt")->spew_utf8(@data);
  #pod
  #pod Writes data to a file atomically.  The file is written to a temporary file in
  #pod the same directory, then renamed over the original.  An optional hash reference
  #pod may be used to pass options.  The only option is C<binmode>, which is passed to
  #pod C<binmode()> on the handle used for writing.
  #pod
  #pod C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  #pod (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  #pod spew will be done instead on the data encoded with C<Unicode::UTF8>.
  #pod
  #pod B<NOTE>: because the file is written to a temporary file and then renamed, the
  #pod new file will wind up with permissions based on your current umask.  This is a
  #pod feature to protect you from a race condition that would otherwise give
  #pod different permissions than you might expect.  If you really want to keep the
  #pod original mode flags, use L</append> with the C<truncate> option.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
  
      # spewing need to follow the link
      # and create the tempfile in the same dir
      my $resolved_path = $self->_resolve_symlinks;
  
      my $temp = path( $resolved_path . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          my $self = shift;
          spew(
              $self,
              { binmode => ":unix" },
              map { Unicode::UTF8::encode_utf8($_) } map { ref eq 'ARRAY' ? @$_ : $_ } @_
          );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          splice @_, 1, 0, { binmode => ":unix:utf8_strict" };
          goto &spew;
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  #pod =method stat, lstat
  #pod
  #pod     $stat = path("foo.txt")->stat;
  #pod     $stat = path("/some/symlink")->lstat;
  #pod
  #pod Like calling C<stat> or C<lstat> from L<File::stat>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  #pod =method stringify
  #pod
  #pod     $path = path("foo.txt");
  #pod     say $path->stringify; # same as "$path"
  #pod
  #pod Returns a string representation of the path.  Unlike C<canonpath>, this method
  #pod returns the path standardized with Unix-style C</> directory separators.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub stringify { $_[0]->[PATH] }
  
  #pod =method subsumes
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/baz"); # true
  #pod     path("/foo/bar")->subsumes("/foo/baz");   # false
  #pod
  #pod Returns true if the first path is a prefix of the second path at a directory
  #pod boundary.
  #pod
  #pod This B<does not> resolve parent directory entries (C<..>) or symlinks:
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/../baz"); # true
  #pod
  #pod If such things are important to you, ensure that both paths are resolved to
  #pod the filesystem with C<realpath>:
  #pod
  #pod     my $p1 = path("foo/bar")->realpath;
  #pod     my $p2 = path("foo/bar/../baz")->realpath;
  #pod     if ( $p1->subsumes($p2) ) { ... }
  #pod
  #pod Current API available since 0.048.
  #pod
  #pod =cut
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|$)};
      }
  }
  
  #pod =method touch
  #pod
  #pod     path("foo.txt")->touch;
  #pod     path("foo.txt")->touch($epoch_secs);
  #pod
  #pod Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  #pod changes the modification and access times to the current time.  If the first
  #pod argument is the epoch seconds then it will be used.
  #pod
  #pod Returns the path object so it can be easily chained with other methods:
  #pod
  #pod     # won't die if foo.txt doesn't exist
  #pod     $content = path("foo.txt")->touch->slurp;
  #pod
  #pod Current API available since 0.015.
  #pod
  #pod =cut
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      if ( defined $epoch ) {
          utime $epoch, $epoch, $self->[PATH]
            or $self->_throw("utime ($epoch)");
      }
      else {
          # literal undef prevents warnings :-(
          utime undef, undef, $self->[PATH]
            or $self->_throw("utime ()");
      }
      return $self;
  }
  
  #pod =method touchpath
  #pod
  #pod     path("bar/baz/foo.txt")->touchpath;
  #pod
  #pod Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  #pod before touching the file.  Returns the path object like C<touch> does.
  #pod
  #pod Current API available since 0.022.
  #pod
  #pod =cut
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  #pod =method visit
  #pod
  #pod     path("/tmp")->visit( \&callback, \%options );
  #pod
  #pod Executes a callback for each child of a directory.  It returns a hash
  #pod reference with any state accumulated during iteration.
  #pod
  #pod The options are the same as for L</iterator> (which it uses internally):
  #pod C<recurse> and C<follow_symlinks>.  Both default to false.
  #pod
  #pod The callback function will receive a C<Path::Tiny> object as the first argument
  #pod and a hash reference to accumulate state as the second argument.  For example:
  #pod
  #pod     # collect files sizes
  #pod     my $sizes = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             return if $path->is_dir;
  #pod             $state->{$path} = -s $path;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod For convenience, the C<Path::Tiny> object will also be locally aliased as the
  #pod C<$_> global variable:
  #pod
  #pod     # print paths matching /foo/
  #pod     path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  #pod
  #pod If the callback returns a B<reference> to a false scalar value, iteration will
  #pod terminate.  This is not the same as "pruning" a directory search; this just
  #pod stops all iteration and returns the state hash reference.
  #pod
  #pod     # find up to 10 files larger than 100K
  #pod     my $files = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             $state->{$path}++ if -s $path > 102400
  #pod             return \0 if keys %$state == 10;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut
  
  sub visit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      Carp::croak("Callback for visit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
      my $next  = $self->iterator($args);
      my $state = {};
      while ( my $file = $next->() ) {
          local $_ = $file;
          my $r = $cb->( $file, $state );
          last if ref($r) eq 'SCALAR' && !$$r;
      }
      return $state;
  }
  
  #pod =method volume
  #pod
  #pod     $vol = path("/tmp/foo.txt")->volume;   # ""
  #pod     $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  #pod
  #pod Returns the volume portion of the path.  This is equivalent
  #pod to what L<File::Spec> would give from C<splitpath> and thus
  #pod usually is the empty string on Unix-like operating systems or the
  #pod drive letter for an absolute path on C<MSWin32>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.104
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    ($head) = $file->lines( {count => 1} );
    ($tail) = $file->lines( {count => -1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module provides a small, fast utility for working with file paths.  It is
  friendlier to use than L<File::Spec> and provides easy access to functions from
  several other core file handling modules.  It aims to be smaller and faster
  than many alternatives on CPAN, while helping people do many common things in
  consistent and less error-prone ways.
  
  Path::Tiny does not try to work for anything except Unix-like and Win32
  platforms.  Even then, it might break if you try something particularly obscure
  or tortuous.  (Quick!  What does this mean:
  C<< ///../../..//./././a//b/.././c/././ >>?  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode.  On Windows, that means they will not have CRLF translation from the
  C<:crlf> IO layer.  Installing L<Unicode::UTF8> 0.58 or later will speed up
  C<*_utf8> situations in many cases and is highly recommended.
  Alternatively, installing L<PerlIO::utf8_strict> 0.003 or later will be
  used in place of the default C<:encoding(UTF-8)>.
  
  This module depends heavily on PerlIO layers for correct operation and thus
  requires Perl 5.008001 or later.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  If called with a single C<Path::Tiny> argument, the original is returned unless
  the original is holding a temporary file or directory reference in which case a
  stringified copy is made.
  
      $path = path("foo/bar");
      $temp = Path::Tiny->tempfile;
  
      $p2 = path($path); # like $p2 = $path
      $t2 = path($temp); # like $t2 = path( "$temp" )
  
  This optimizes copies without proliferating references unexpectedly if a copy is
  made by code outside your control.
  
  Current API available since 0.017.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  Current API available since 0.001.
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  Current API available since 0.018.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  Current API available since 0.018.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will be normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.  If you want it to have
  the C<realpath> instead, pass a leading options hash like this:
  
      $real_temp = tempfile({realpath => 1}, @options);
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  reused.  This is not as secure as using File::Temp handles directly, but is
  less prone to deadlocks or access problems on some platforms.  Think of what
  C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  up.
  
  B<Note 2>: if you don't want these cleaned up automatically when the object
  is destroyed, File::Temp requires different options for directories and
  files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  files.
  
  B<Note 3>: Don't lose the temporary object by chaining a method call instead
  of storing it:
  
      my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  
  B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  Keeping a reference to, or modifying the cached object may break the
  behavior documented above and is not supported.  Use at your own risk.
  
  Current API available since 0.097.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  If no argument is given, the current directory is used as the
  absolute base path.  If an argument is given, it will be converted to an
  absolute path (if it is not already) and used as the absolute base path.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  Current API available since 0.101.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  Valid options are:
  
  =over 4
  
  =item *
  
  C<binmode>: passed to C<binmode()> on the handle used for writing.
  
  =item *
  
  C<truncate>: truncates the file after locking and before appending
  
  =back
  
  The C<truncate> option is a way to replace the contents of a file
  B<in place>, unlike L</spew> which writes to a temporary file and then
  replaces the original (if it exists).
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw append will be done instead on the data encoded
  with C<Unicode::UTF8>.
  
  Current API available since 0.060.
  
  =head2 assert
  
      $path = path("foo.txt")->assert( sub { $_->exists } );
  
  Returns the invocant after asserting that a code reference argument returns
  true.  When the assertion code reference runs, it will have the invocant
  object in the C<$_> variable.  If it returns false, an exception will be
  thrown.  The assertion code reference may also throw its own exception.
  
  If no assertion is provided, the invocant is returned without error.
  
  Current API available since 0.062.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename;        # bar.txt
      $name = path("foo.txt")->basename('.txt');    # foo
      $name = path("foo.txt")->basename(qr/.txt/);  # foo
      $name = path("foo.txt")->basename(@suffixes);
  
  Returns the file portion or last directory portion of a path.
  
  Given a list of suffixes as strings or regular expressions, any that match at
  the end of the file portion or last directory portion will be removed before
  the result is returned.
  
  Current API available since 0.054.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  Current API available since 0.001.
  
  =head2 cached_temp
  
  Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  If there is no such object, this method throws.
  
  B<WARNING>: Keeping a reference to, or modifying the cached object may
  break the behavior documented for temporary files and directories created
  with C<Path::Tiny> and is not supported.  Use at your own risk.
  
  Current API available since 0.101.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  Current API available since 0.001.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt$/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  Current API available since 0.028.
  
  =head2 chmod
  
      path("foo.txt")->chmod(0777);
      path("foo.txt")->chmod("0755");
      path("foo.txt")->chmod("go-w");
      path("foo.txt")->chmod("a=r,u+wx");
  
  Sets file or directory permissions.  The argument can be a numeric mode, a
  octal string beginning with a "0" or a limited subset of the symbolic mode use
  by F</bin/chmod>.
  
  The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  are required for each clause, multiple ops are not allowed and permissions
  C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  
  Current API available since 0.053.
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies the current path to the given destination using L<File::Copy>'s
  C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  newly copied file.
  
  Current API available since 0.070.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
      $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  
  Returns a hexadecimal digest for a file.  An optional hash reference of options may
  be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  bytes will be read at a time.  If not provided, the entire file will be slurped
  into memory to compute the digest.
  
  Any subsequent arguments are passed to the constructor for L<Digest> to select
  an algorithm.  If no arguments are given, the default is SHA-256.
  
  Current API available since 0.056.
  
  =head2 dirname (deprecated)
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory portion you would get from calling
  C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  parent directory portion.  Because L<File::Spec> is inconsistent, the result
  might or might not have a trailing slash.  Because of this, this method is
  B<deprecated>.
  
  A better, more consistently approach is likely C<< $path->parent->stringify >>,
  which will not have a trailing slash except for a root directory.
  
  Deprecated in 0.056.
  
  =head2 edit, edit_raw, edit_utf8
  
      path("foo.txt")->edit( \&callback, $options );
      path("foo.txt")->edit_utf8( \&callback );
      path("foo.txt")->edit_raw( \&callback );
  
  These are convenience methods that allow "editing" a file using a single
  callback argument. They slurp the file using C<slurp>, place the contents
  inside a localized C<$_> variable, call the callback function (without
  arguments), and then write C<$_> (presumably mutated) back to the
  file with C<spew>.
  
  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<slurp> and C<spew>.
  
  C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  C<spew_*> methods.
  
  Current API available since 0.077.
  
  =head2 edit_lines, edit_lines_utf8, edit_lines_raw
  
      path("foo.txt")->edit_lines( \&callback, $options );
      path("foo.txt")->edit_lines_utf8( \&callback );
      path("foo.txt")->edit_lines_raw( \&callback );
  
  These are convenience methods that allow "editing" a file's lines using a
  single callback argument.  They iterate over the file: for each line, the
  line is put into a localized C<$_> variable, the callback function is
  executed (without arguments) and then C<$_> is written to a temporary file.
  When iteration is finished, the temporary file is atomically renamed over
  the original.
  
  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to the method that open handles for reading and
  writing.
  
  C<edit_lines_utf8> and C<edit_lines_raw> act like their respective
  C<slurp_*> and C<spew_*> methods.
  
  Current API available since 0.077.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }     # -e
      if ( path("/tmp")->is_dir ) { ... }     # -d
      if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  
  Implements file test operations, this means the file or directory actually has
  to exist on the filesystem.  Until then, it's just a path.
  
  B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  read just like files.
  
  Use C<-f> instead if you really mean to check for a plain file.
  
  Current API available since 0.053.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.
  
  The C<locked> option governs file locking; if true, handles opened for writing,
  appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  truncation until after the lock is acquired.
  
  The C<exclusive> option causes the open() call to fail if the file already
  exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  C<exclusive> implies C<locked> and will set it for you if you forget it.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  Current API available since 0.066.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  Current API available since 0.001.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  Current API available since 0.038.
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  See also L</visit>.
  
  Current API available since 0.016.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.
  
  If C<binmode> is provided, it will be set on the handle prior to reading.
  
  If a positive C<count> is provided, that many lines will be returned from the
  start of the file.  If a negative C<count> is provided, the entire file will be
  read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  exceeds the number of lines in the file, all lines will be returned.
  
  If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  C<LF>) will be removed from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  Current API available since 0.065.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  Current API available since 0.001.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Move the current path to the given destination path using Perl's
  built-in L<rename|perlfunc/rename> function. Returns the result
  of the C<rename> function.
  
  Current API available since 0.001.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  Current API available since 0.011.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  Current API available since 0.014.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the parent path can't be resolved (e.g. if it includes directories that
  don't exist), an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  However, if the parent path exists and only the last component (e.g. filename)
  doesn't exist, the realpath will be the realpath of the parent plus the
  non-existent last component:
  
      $real = path("./aasdlfasdlf")->realpath; # works
  
  The underlying L<Cwd> module usually worked this way on Unix, but died on
  Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  it's safe to use anywhere.
  
  Current API available since 0.001.
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a path relative to a new base path
  given as an argument.  If no argument is given, the current directory will
  be used as the new base path.
  
  If either path is already relative, it will be made absolute based on the
  current directly before determining the new relative path.
  
  The algorithm is roughly as follows:
  
  =over 4
  
  =item *
  
  If the original and new base path are on different volumes, an exception will be thrown.
  
  =item *
  
  If the original and new base are identical, the relative path is C<".">.
  
  =item *
  
  If the new base subsumes the original, the relative path is the original path with the new base chopped off the front
  
  =item *
  
  If the new base does not subsume the original, a common prefix path is determined (possibly the root directory) and the relative path will consist of updirs (C<"..">) to reach the common prefix, followed by the original path less the common prefix.
  
  =back
  
  Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  on a common prefix takes into account symlinks that could affect the updir
  process.  Given an original path "/A/B" and a new base "/A/C",
  (where "A", "B" and "C" could each have multiple path components):
  
  =over 4
  
  =item *
  
  Symlinks in "A" don't change the result unless the last component of A is a symlink and the first component of "C" is an updir.
  
  =item *
  
  Symlinks in "B" don't change the result and will exist in the result as given.
  
  =item *
  
  Symlinks and updirs in "C" must be resolved to actual paths, taking into account the possibility that not all path components might exist on the filesystem.
  
  =back
  
  Current API available since 0.001.  New algorithm (that accounts for
  symlinks) available since 0.079.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  This is just like C<unlink>, except for its error handling: if the path does
  not exist, it returns false; if deleting the file fails, it throws an
  exception.
  
  Current API available since 0.012.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  Current API available since 0.013.
  
  =head2 sibling
  
      $foo = path("/tmp/foo.txt");
      $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
      $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  
  Returns a new C<Path::Tiny> object relative to the parent of the original.
  This is slightly more efficient than C<< $path->parent->child(...) >>.
  
  Current API available since 0.058.
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference which may
  be used to pass options.  The only available option is C<binmode>, which is
  passed to C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw slurp will be done instead and the result decoded
  with C<Unicode::UTF8>.  This is just as strict and is roughly an order of
  magnitude faster than using C<:encoding(UTF-8)>.
  
  B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  you plan to slurp from a file created with L<File::Temp>, be sure to
  close other handles or open without locking to avoid a deadlock:
  
      my $tempfile = File::Temp->new(EXLOCK => 0);
      my $guts = path($tempfile)->slurp;
  
  Current API available since 0.004.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  spew will be done instead on the data encoded with C<Unicode::UTF8>.
  
  B<NOTE>: because the file is written to a temporary file and then renamed, the
  new file will wind up with permissions based on your current umask.  This is a
  feature to protect you from a race condition that would otherwise give
  different permissions than you might expect.  If you really want to keep the
  original mode flags, use L</append> with the C<truncate> option.
  
  Current API available since 0.011.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  Current API available since 0.001.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  Current API available since 0.001.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  Current API available since 0.048.
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with other methods:
  
      # won't die if foo.txt doesn't exist
      $content = path("foo.txt")->touch->slurp;
  
  Current API available since 0.015.
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  Current API available since 0.022.
  
  =head2 visit
  
      path("/tmp")->visit( \&callback, \%options );
  
  Executes a callback for each child of a directory.  It returns a hash
  reference with any state accumulated during iteration.
  
  The options are the same as for L</iterator> (which it uses internally):
  C<recurse> and C<follow_symlinks>.  Both default to false.
  
  The callback function will receive a C<Path::Tiny> object as the first argument
  and a hash reference to accumulate state as the second argument.  For example:
  
      # collect files sizes
      my $sizes = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              return if $path->is_dir;
              $state->{$path} = -s $path;
          },
          { recurse => 1 }
      );
  
  For convenience, the C<Path::Tiny> object will also be locally aliased as the
  C<$_> global variable:
  
      # print paths matching /foo/
      path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  
  If the callback returns a B<reference> to a false scalar value, iteration will
  terminate.  This is not the same as "pruning" a directory search; this just
  stops all iteration and returns the state hash reference.
  
      # find up to 10 files larger than 100K
      my $files = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              $state->{$path}++ if -s $path > 102400
              return \0 if keys %$state == 10;
          },
          { recurse => 1 }
      );
  
  If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  
  Current API available since 0.062.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  Current API available since 0.001.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_BSD IS_WIN32 FREEZE THAW TO_JSON abs2rel
  
  =head1 EXCEPTION HANDLING
  
  Simple usage errors will generally croak.  Failures of underlying Perl
  functions will be thrown as exceptions in the class
  C<Path::Tiny::Error>.
  
  A C<Path::Tiny::Error> object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op>  a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file>  the file or directory relating to the error
  
  =item *
  
  C<err>  hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg>  a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 CAVEATS
  
  =head2 Subclassing not supported
  
  For speed, this class is implemented as an array based object and uses many
  direct function calls internally.  You must not subclass it and expect
  things to work properly.
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  Path::Tiny has some heuristics to detect this
  and will warn once and let you continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.  If the user does not have write
  permission, no lock will be used.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods by default use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.  Alternatively, if you install L<PerlIO::utf8_strict>,
  that will be used instead of C<:encoding(UTF-8)> and is also very fast.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::chmod>
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alex Efros Chris Williams Dave Rolsky David Steinbrunner Doug Bell Gabor Szabo Gabriel Andrade George Hartzell Geraud Continsouzas Goro Fuji Graham Knop Ollis James Hunt John Karr Karen Etheridge Mark Ellis Martin Kjeldsen Michael G. Schwern Nigel Gregoire Philippe Bruhat (BooK) Regina Verbae Roy Ivy III Shlomi Fish Smylers Tatsuhiko Miyagawa Toby Inkster Yanick Champoux  - Keedi Kim
  
  =over 4
  
  =item *
  
  Alex Efros <powerman@powerman.name>
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Doug Bell <madcityzen@gmail.com>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  James Hunt <james@niftylogic.com>
  
  =item *
  
  John Karr <brainbuz@brainbuz.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Mark Ellis <mark.ellis@cartridgesave.co.uk>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Nigel Gregoire <nigelgregoire@gmail.com>
  
  =item *
  
  Philippe Bruhat (BooK) <book@cpan.org>
  
  =item *
  
  Regina Verbae <regina-verbae@users.noreply.github.com>
  
  =item *
  
  Roy Ivy III <rivy@cpan.org>
  
  =item *
  
  Shlomi Fish <shlomif@shlomifish.org>
  
  =item *
  
  Smylers <Smylers@stripey.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
  Yanick Champoux <yanick@babyl.dyndns.org>
  
  =item *
  
   - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Promise.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PROMISE';
  package Promise;
  use strict;
  use warnings;
  use warnings FATAL => 'uninitialized';
  our $VERSION = '5.0';
  use Carp;
  push our @CARP_NOT, qw(Promise::TypeError);
  
  ## Not public; using |our| such that |local| can be used.
  our $CallerLevel = 0;
  
  $Promise::CreateTypeError ||= sub ($$) {
    require Promise::TypeError;
    $Promise::CreateTypeError = sub ($$) {
      return Promise::TypeError->new ($_[1]);
    };
    return $Promise::CreateTypeError->(@_);
  };
  sub _type_error ($) { $Promise::CreateTypeError->(undef, $_[0]) }
  
  $Promise::Enqueue = sub ($$) {
    require AnyEvent;
    &AE::postpone ($_[1]);
    $Promise::Enqueue = sub { &AE::postpone ($_[1]) };
  };
  sub _enqueue (&) { $Promise::Enqueue->(undef, $_[0]) }
  
  $Promise::RejectionTrackerReject = sub ($) { };
  $Promise::RejectionTrackerHandle = sub ($) { };
  sub _rejection_tracker_reject ($) { $Promise::RejectionTrackerReject->(@_) }
  sub _rejection_tracker_handle ($) { $Promise::RejectionTrackerHandle->(@_) }
  
  sub _enqueue_promise_reaction_job ($$) {
    my ($reaction, $argument) = @_;
    _enqueue {
      ## PromiseReactionJob
      my $promise_capability = $reaction->{capability};
      if (defined $reaction->{handler}) {
        my $file = $reaction->{caller}->[1];
        $file =~ s/[\x0D\x0A\x22]/_/g;
        my $handler_result;
        my $eval_result = eval sprintf q{
  package Promise::_Dummy;
  #line %d "%s"
  $handler_result = $reaction->{handler}->($argument);
  1;
  }, $reaction->{caller}->[2], $file;
        return $promise_capability->{reject}->($@) unless $eval_result;
        return $promise_capability->{resolve}->($handler_result);
      } else {
        if ($reaction->{type} eq 'fulfill') {
          return $promise_capability->{resolve}->($argument);
        } else { # reject
          return $promise_capability->{reject}->($argument);
        }
      }
    };
  } # _enqueue_promise_reaction_job
  
  sub _create_resolving_functions ($);
  
  sub _enqueue_promise_resolve_thenable_job ($$$) {
    my ($promise_to_resolve, $thenable, $then) = @_;
    _enqueue {
      ## PromiseResolveThenableJob
      my $resolving_functions = _create_resolving_functions $promise_to_resolve;
      my $eval_result = eval {
        # gives scalar context
        my $then_call_result = $then->($thenable, $resolving_functions->{resolve}, $resolving_functions->{reject});
        1;
      };
      return $resolving_functions->{reject}->($@) unless $eval_result;
      #return $then_call_result; # unused
    };
  } # _enqueue_promise_resolve_thenable_job
  
  sub _fulfill_promise ($$) {
    my $promise = $_[0];
    my $reactions = delete $promise->{promise_fulfill_reactions};
    $promise->{promise_result} = $_[1];
    my $x = delete $promise->{promise_reject_reactions};
    $promise->{promise_state} = 'fulfilled';
  
    ## Run GC between promise callbacks
    _enqueue { undef $x };
  
    ## TriggerPromiseReactions
    _enqueue_promise_reaction_job $_, $_[1] for @$reactions;
  
    return undef;
  } # _fulfill_promise
  
  sub _reject_promise ($$) {
    my $promise = $_[0];
    my $reactions = delete $promise->{promise_reject_reactions};
    $promise->{promise_result} = $_[1];
    my $x = delete $promise->{promise_fulfill_reactions};
    $promise->{promise_state} = 'rejected';
    _rejection_tracker_reject $promise unless $promise->{promise_is_handled};
  
    ## Run GC between promise callbacks
    _enqueue { undef $x };
  
    ## TriggerPromiseReactions
    _enqueue_promise_reaction_job $_, $_[1] for @$reactions;
  
    return undef;
  } # _reject_promise
  
  sub _create_resolving_functions ($) {
    my ($promise) = @_;
    my $already_resolved = 0;
    my $resolve = sub ($$) { ## promise resolve function
      return undef if $already_resolved;
      $already_resolved = 1;
      return _reject_promise $promise, _type_error ('SelfResolutionError')
          if defined $_[0] and $_[0] eq $promise; ## SameValue
      return _fulfill_promise $promise, $_[0]
          if not defined $_[0] or not ref $_[0];
      local $@;
      my $then;
      my $eval_result = eval {
        $then = UNIVERSAL::can ($_[0], 'then') && $_[0]->can ('then');
        1;
      };
      return _reject_promise $promise, $@ unless $eval_result;
      return _fulfill_promise $promise, $_[0]
          unless defined $then and ref $then eq 'CODE';
      _enqueue_promise_resolve_thenable_job $promise, $_[0], $then;
      return undef;
    };
    my $reject = sub ($$) { ## promise reject function
      return undef if $already_resolved;
      $already_resolved = 1;
      return _reject_promise $promise, $_[0];
    };
    return {resolve => $resolve, reject => $reject};
  } # _create_resolving_functions
  
  sub _new_promise_capability ($) {
    my $class = $_[0];
    my $promise_capability = {}; # promise, resolve, reject
  
    ## GetCapabilitiesExecutor
    my $executor = sub ($$) {
      die _type_error ('The resolver is already specified')
          if defined $promise_capability->{resolve};
      die _type_error ('The reject handler is already specified')
          if defined $promise_capability->{reject};
      $promise_capability->{resolve} = $_[0];
      $promise_capability->{reject} = $_[1];
      return undef;
    };
  
    local $CallerLevel = $CallerLevel + 2;
    $promise_capability->{promise} = $class->new ($executor); # or throw
    die _type_error
        ('The executor is not invoked or the resolver is not specified')
        unless defined $promise_capability->{resolve} and
               ref $promise_capability->{resolve} eq 'CODE';
    die _type_error
        ('The executor is not invoked or the reject handler is not specified')
        unless defined $promise_capability->{reject} and
               ref $promise_capability->{reject} eq 'CODE';
    return $promise_capability;
  } # _new_promise_capability
  
  sub new ($$) {
    my ($class, $executor) = @_;
    die _type_error ('The executor is not a code reference')
        unless defined $executor and ref $executor eq 'CODE';
    my $promise = bless {caller => [caller $CallerLevel]}, $class;
    $promise->{promise_state} = 'pending';
    $promise->{promise_fulfill_reactions} = [];
    $promise->{promise_reject_reactions} = [];
    #$promise->{promise_is_handled} = 0;
    my $resolving_functions = _create_resolving_functions $promise;
    {
      local $@;
      my $eval_result = eval {
        $executor->($resolving_functions->{resolve}, $resolving_functions->{reject});
        1;
      };
      $resolving_functions->{reject}->($@) unless $eval_result;
    }
    return $promise;
  } # new
  
  sub all ($$) {
    my ($class, $iterable) = @_;
    my $promise_capability = _new_promise_capability $class; # or throw
    local $@;
    my $iterator;
    my $eval_result = eval {
      $iterator = [@$iterable];
      1;
    };
    unless ($eval_result) { ## IfAbruptRejectPromise
      $promise_capability->{reject}->($@);
      return $promise_capability->{promise};
    }
    ## PerformPromiseAll
    my $values = [];
    my $remaining_elements_count = 1;
    my $index = 0;
    {
      unless ($index <= $#$iterator) {
        $remaining_elements_count--;
        if ($remaining_elements_count == 0) {
          $promise_capability->{resolve}->($values); # or throw
        }
        return $promise_capability->{promise};
      }
      my $next_promise;
      my $eval_result = eval {
        $next_promise = $class->resolve ($iterator->[$index]);
        1;
      };
      unless ($eval_result) { ## IfAbruptRejectPromise
        $promise_capability->{reject}->($@);
        return $promise_capability->{promise};
      }
      my $already_called = 0;
      my $resolve_element_index = $index;
      my $resolve_element = sub ($) { ## Promise.all resolve element function
        return undef if $already_called;
        $already_called = 1;
        $values->[$resolve_element_index] = $_[0];
        $remaining_elements_count--;
        if ($remaining_elements_count == 0) {
          return $promise_capability->{resolve}->($values);
        }
        return undef;
      };
      $remaining_elements_count++;
      $eval_result = eval {
        $next_promise->then ($resolve_element, $promise_capability->{reject});
        1;
      };
      unless ($eval_result) { ## IfAbruptRejectPromise
        $promise_capability->{reject}->($@);
        return $promise_capability->{promise};
      }
      $index++;
      redo;
    }
  } # all
  
  sub race ($$) {
    my ($class, $iterable) = @_;
    my $promise_capability = _new_promise_capability $class; # or throw
    local $@;
    my $iterator;
    my $eval_result = eval {
      $iterator = [@$iterable];
      1;
    };
    unless ($eval_result) { ## IfAbruptRejectPromise
      $promise_capability->{reject}->($@);
      return $promise_capability->{promise};
    }
    ## PerformPromiseRace
    for my $value (@$iterator) {
      my $eval_result = eval {
        my $promise = $class->resolve ($value);
        scalar $promise->then ($promise_capability->{resolve}, $promise_capability->{reject});
        1;
      };
      unless ($eval_result) { ## IfAbruptRejectPromise
        $promise_capability->{reject}->($@);
        return $promise_capability->{promise};
      }
    } # $value
    return $promise_capability->{promise};
  } # race
  
  sub reject ($$) {
    my $promise_capability = _new_promise_capability $_[0]; # or throw
    $promise_capability->{reject}->($_[1]);
    return $promise_capability->{promise};
  } # reject
  
  sub resolve ($$) {
    ## PromiseResolve <https://tc39.github.io/ecma262/#sec-promise-resolve>
    return $_[1] if defined $_[1] and ref $_[1] eq $_[0]; ## IsPromise and constructor
    my $promise_capability = _new_promise_capability $_[0]; # or throw
    $promise_capability->{resolve}->($_[1]);
    return $promise_capability->{promise};
  } # resolve
  
  sub catch ($$) {
    local $CallerLevel = 1;
    return $_[0]->then (undef, $_[1]); # or throw
  } # catch
  
  sub then ($$$) {
    my ($promise, $onfulfilled, $onrejected) = @_;
    my $promise_capability = _new_promise_capability ref $promise; # or throw
  
    my $caller = [caller ((sub { Carp::short_error_loc })->() - 1)];
  
    ## PerformPromiseThen
    if (defined $onfulfilled and not ref $onfulfilled eq 'CODE') {
      warn sprintf "Fulfilled callback is not a CODE (%s) at %s line %s\n",
          $onfulfilled,
          $caller->[1],
          $caller->[2];
      $onfulfilled = undef;
    }
    if (defined $onrejected and not ref $onrejected eq 'CODE') {
      warn sprintf "Rejected callback is not a CODE (%s) at %s line %s\n",
          $onrejected,
          $caller->[1],
          $caller->[2];
      $onrejected = undef;
    }
    my $fulfill_reaction = {type => 'fulfill',
                            capability => $promise_capability,
                            handler => $onfulfilled,
                            caller => $caller};
    my $reject_reaction = {type => 'reject',
                           capability => $promise_capability,
                           handler => $onrejected,
                           caller => $caller};
    if ($promise->{promise_state} eq 'pending') {
      push @{$promise->{promise_fulfill_reactions}}, $fulfill_reaction
          if defined $promise->{promise_fulfill_reactions} and
             ref $promise->{promise_fulfill_reactions} eq 'ARRAY';
      push @{$promise->{promise_reject_reactions}}, $reject_reaction
          if defined $promise->{promise_reject_reactions} and
             ref $promise->{promise_reject_reactions} eq 'ARRAY';
    } elsif ($promise->{promise_state} eq 'fulfilled') {
      _enqueue_promise_reaction_job $fulfill_reaction, $promise->{promise_result};
    } elsif ($promise->{promise_state} eq 'rejected') {
      my $result = $promise->{promise_result};
      _rejection_tracker_handle $promise unless $promise->{promise_is_handled};
      _enqueue_promise_reaction_job $reject_reaction, $result;
    }
    $promise->{promise_is_handled} = 1;
    return $promise_capability->{promise};
  } # then
  
  sub manakai_set_handled ($) {
    $_[0]->{promise_is_handled} = 1;
  } # manakai_set_handled
  
  ## <https://tc39.github.io/ecma262/#sec-promise.prototype.finally>
  sub finally ($$) {
    my $promise = $_[0];
    my $onfinally = $_[1];
    my $then_finally;
    my $catch_finally;
    if (ref $onfinally eq 'CODE') {
      my $class = ref $promise;
      $then_finally = sub {
        my $v = $_[0]; # PromiseResolve
        return $class->resolve ($onfinally->()) # or throw
            ->then (sub { return $v });
      };
      $catch_finally = sub {
        my $e = $_[0]; # PromiseResolve
        return $class->resolve ($onfinally->()) # or throw
            ->then (sub { die $e });
      };
    } else {
      $then_finally = $catch_finally = $onfinally;
    }
    return $promise->then ($then_finally, $catch_finally); # or throw
  } # finally
  
  sub from_cv ($$) {
    my ($class, $cv) = @_;
    local $CallerLevel = 1;
    return $class->new (sub {
      my ($resolve, $reject) = @_;
      $cv->cb (sub {
        my $eval_result = eval {
          $resolve->($_[0]->recv);
          1;
        };
        $reject->($@) unless $eval_result;
      });
    });
  } # from_cv
  
  sub to_cv ($) {
    require AnyEvent;
    my $cv = AE::cv ();
    $_[0]->then (sub {
      $cv->send ($_[0]);
    }, sub {
      $cv->croak ($_[0]);
    });
    return $cv;
  } # to_cv
  
  sub debug_info ($) {
    my $self = $_[0];
    no warnings 'uninitialized';
    return sprintf '{%s: %s, created at %s line %s}',
        ref $self,
        $self->{promise_state},
        $self->{caller}->[1],
        $self->{caller}->[2];
  } # debug_info
  
  sub DESTROY ($) {
    if (not $_[0]->{promise_is_handled} and
        defined $_[0]->{promise_state} and
        $_[0]->{promise_state} eq 'rejected') {
      my $msg = "$$: Uncaught rejection: @{[defined $_[0]->{promise_result} ? $_[0]->{promise_result} : '(undef)']}";
      $msg .= " for " . $_[0]->debug_info . "\n" unless $msg =~ /\n$/;
      warn $msg;
    }
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/ and not $_[0]->{is_global_variable}) {
      warn "$$: Reference to " . $_[0]->debug_info . " is not discarded before global destruction\n";
    }
  } # DESTROY
  
  1;
  
  =head1 LICENSE
  
  Copyright 2014-2021 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PROMISE

$fatpacked{"Promise/AbortError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PROMISE_ABORTERROR';
  package Promise::AbortError;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '2.0';
  use Carp;
  
  $Web::DOM::Error::L1ObjectClass->{(__PACKAGE__)} = 1;
  
  use overload
      '""' => 'stringify', bool => sub { 1 },
      cmp => sub {
        carp "Use of uninitialized value in string comparison (cmp)"
            unless defined $_[1];
        overload::StrVal ($_[0]) cmp overload::StrVal ($_[1])
      },
      fallback => 1;
  
  sub new ($$) {
    my $self = bless {name => 'AbortError',
                      message => defined $_[1] ? ''.$_[1] : 'Aborted'}, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new
  
  sub _set_stacktrace ($) {
    my $self = $_[0];
    if (Carp::shortmess =~ /at (.+) line ([0-9]+)\.?$/) {
      $self->{file_name} = $1;
      $self->{line_number} = $2;
    }
  } # _set_stacktrace
  
  sub name ($) { $_[0]->{name} }
  sub file_name ($) { $_[0]->{file_name} }
  sub line_number ($) { $_[0]->{line_number} || 0 }
  sub message ($) { $_[0]->{message} }
  
  sub stringify ($) {
    my $self = $_[0];
    my $name = $self->name;
    my $msg = $self->message;
    if (length $msg) {
      $msg = $name . ': ' . $msg if length $name;
    } else {
      $msg = $name;
    }
    my $fn = $self->file_name;
    return sprintf "%s at %s line %d.\n",
        $msg, defined $fn ? $fn : '(unknown)', $self->line_number || 0;
  } # stringify
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PROMISE_ABORTERROR

$fatpacked{"Promised/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PROMISED_COMMAND';
  package Promised::Command;
  use strict;
  use warnings;
  our $VERSION = '2.0';
  use Promise;
  use AnyEvent;
  use AnyEvent::Util qw(run_cmd);
  
  push our @CARP_NOT, qw(Streams::Filehandle WritableStream);
  
  my $DEBUG = $ENV{PROMISED_COMMAND_DEBUG};
  my $CommandID = int rand 10000;
  
  sub new ($$) {
    my $self = bless {args => []}, $_[0];
    ($self->{command}, @{$self->{args}}) = @{$_[1]};
    return $self;
  } # new
  
  sub wd ($;$) {
    if (@_ > 1) {
      $_[0]->{wd} = $_[1];
    }
    return $_[0]->{wd};
  } # wd
  
  sub envs ($) {
    return $_[0]->{envs} ||= {};
  } # envs
  
  sub create_process_group ($;$) {
    if (@_ > 1) {
      $_[0]->{create_process_group} = $_[1];
    }
    return $_[0]->{create_process_group};
  } # create_process_group
  
  sub stdin ($;$) {
    if (@_ > 1) {
      $_[0]->{stdin} = $_[1];
    }
    die "Not implemented" if defined wantarray;
  } # stdin
  
  sub stdout ($;$) {
    if (@_ > 1) {
      $_[0]->{stdout} = $_[1];
    }
    die "Not implemented" if defined wantarray;
  } # stdout
  
  sub stderr ($;$) {
    if (@_ > 1) {
      $_[0]->{stderr} = $_[1];
    }
    die "Not implemented" if defined wantarray;
  } # stderr
  
  sub get_stdin_stream ($) {
    die "A stdin handler is already set" if defined $_[0]->{stdin};
  
    my ($pr, $fh) = AnyEvent::Util::portable_pipe;
    fcntl $fh, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
    AnyEvent::Util::fh_nonblocking $fh, 1;
  
    require WritableStream;
    require Streams::Filehandle;
    my $canceled = 0;
    my $wcancel = sub { };
    my $wc;
    my $ws = WritableStream->new ({
      start => sub {
        $wc = $_[1];
      }, # start
      write => sub {
        return Streams::Filehandle::write_to_fhref (\$fh, $_[1], cancel_ref => \$wcancel)->catch (sub {
          close $fh;
          undef $fh;
          $wcancel->();
          $canceled = 1;
          $wcancel = sub { };
          die $_[0];
        });
      }, # write
      close => sub {
        close $fh;
        undef $fh;
        $canceled = 1;
        $wcancel = sub { };
      }, # close
      abort => sub {
        close $fh;
        undef $fh;
        $wcancel->();
        $canceled = 1;
        $wcancel = sub { };
      }, # abort
    }); # $ws
  
    $_[0]->{stdin} = $pr;
  
    return $ws;
  } # get_stdin_stream
  
  sub get_stdout_stream ($) {
    die "A stdout handler is already set" if defined $_[0]->{stdout};
    require Streams::_Common;
    require ArrayBuffer;
    require DataView;
    require ReadableStream;
    my $canceled = 0;
    my $rc;
    my $rs = ReadableStream->new ({
      type => 'bytes',
      auto_allocate_chunk_size => $Streams::_Common::DefaultBufferSize,
      start => sub {
        $rc = $_[1];
      }, # start
      #pull
      cancel => sub {
        $canceled = 1;
      }, # cancel
    }); # $rs
    $_[0]->{stdout} = sub {
      return if $canceled;
      if (@_) {
        $rc->enqueue (DataView->new (ArrayBuffer->new_from_scalarref (\($_[0])))); # will string-copy!
      } else { # eof
        my $req = $rc->byob_request;
        $rc->close;
        $req->respond (0) if defined $req;
      }
    };
    return $rs;
  } # get_stdout_stream
  
  sub get_stderr_stream ($) {
    die "A stderr handler is already set" if defined $_[0]->{stderr};
    require Streams::_Common;
    require ArrayBuffer;
    require DataView;
    require ReadableStream;
    my $canceled = 0;
    my $rc;
    my $rs = ReadableStream->new ({
      type => 'bytes',
      auto_allocate_chunk_size => $Streams::_Common::DefaultBufferSize,
      start => sub {
        $rc = $_[1];
      }, # start
      #pull
      cancel => sub {
        $canceled = 1;
      }, # cancel
    }); # $rs
    $_[0]->{stderr} = sub {
      return if $canceled;
      if (@_) {
        $rc->enqueue (DataView->new (ArrayBuffer->new_from_scalarref (\($_[0])))); # will string-copy!
      } else { # eof
        my $req = $rc->byob_request;
        $rc->close;
        $req->respond (0) if defined $req;
      }
    };
    return $rs;
  } # get_stderr_stream
  
  sub propagate_signal ($;$) {
    if (@_ > 1) {
      $_[0]->{propagate_signal} = $_[1];
    }
    return $_[0]->{propagate_signal};
  } # propagate_signal
  
  sub signal_before_destruction ($;$) {
    if (@_ > 1) {
      $_[0]->{signal_before_destruction} = $_[1];
    }
    return $_[0]->{signal_before_destruction};
  } # signal_before_destruction
  
  sub timeout ($;$) {
    if (@_ > 1) {
      $_[0]->{timeout} = $_[1];
    }
    return $_[0]->{timeout};
  } # timeout
  
  sub timeout_signal ($;$) {
    if (@_ > 1) {
      $_[0]->{timeout_signal} = $_[1];
    }
    return $_[0]->{timeout_signal} || 'TERM';
  } # timeout_signal
  
  sub abort_signal ($;$) {
    if (@_ > 1) {
      $_[0]->{abort_signal} = $_[1];
    }
    return $_[0]->{abort_signal};
  } # abort_signal
  
  sub _r (@) {
    return bless {@_}, __PACKAGE__.'::Result';
  } # _r
  
  sub run ($) {
    my $self = $_[0];
    return Promise->reject (_r is_error => 1, message => "|run| already invoked")
        if defined $self->{wait_promise};
    $self->{running} = 1;
    $self->{wait_promise} = Promise->new (sub {
      my ($ok, $ng) = @_;
      my %args = ('$$' => \($self->{pid}), on_prepare => sub {
        setpgrp if $self->{create_process_group};
        chdir $self->{wd} or die "Can't change working directory to |$self->{wd}|"
            if defined $self->{wd};
        my $envs = $self->{envs} || {};
        for (keys %$envs) {
          if (defined $envs->{$_}) {
            $ENV{$_} = $envs->{$_};
          } else {
            delete $ENV{$_};
          }
        }
      });
      $args{'<'} = $self->{stdin} if defined $self->{stdin};
      $args{'>'} = $self->{stdout} if defined $self->{stdout};
      $args{'2>'} = $self->{stderr} if defined $self->{stderr};
      if ($self->{propagate_signal}) {
        for my $sig (ref $self->{propagate_signal}
                         ? @{$self->{propagate_signal}}
                         : qw(INT TERM QUIT)) {
          my ($from, $to) = ref $sig ? @$sig : ($sig, $sig);
          require Promised::Command::Signals;
          $self->{signal_handlers}->{$from} = Promised::Command::Signals->add_handler ($from => sub {
            kill $to, $self->{pid} if $self->{running};
          });
        }
      }
      $self->{timer} = AE::timer $self->{timeout}, 0, sub {
        $self->send_signal ($self->timeout_signal);
        delete $self->{timer};
      } if $self->{timeout};
      if (defined $self->{abort_signal}) {
        $self->{abort_signal}->manakai_onabort (sub {
          $self->send_signal ($self->timeout_signal);
          delete $self->{timer};
        });
      }
      my $command = [$self->{command}, @{$self->{args}}];
      my $command_id = $CommandID++;
      warn "Command[$command_id]: Start |@$command|\n" if $DEBUG;
      (run_cmd $command, %args)->cb (sub {
        my $result = $_[0]->recv;
        delete $self->{running};
        delete $self->{signal_handlers};
        delete $self->{timer};
        if (defined $self->{abort_signal}) {
          $self->{abort_signal}->manakai_onabort (undef);
          delete $self->{abort_signal};
        }
        warn "Command[$command_id]: Done @{[$result >> 8]}\n" if $DEBUG;
        if ($result & 0x7F) {
          $ng->(_r is_error => 1, core_dump => !!($result & 0x80), signal => $result & 0x7F);
        } else {
          $ok->(_r exit_code => $result >> 8);
        }
      });
    });
    return Promise->resolve (_r);
  } # run
  
  sub pid ($) {
    return $_[0]->{pid} || die _r is_error => 1, message => "Not yet |run|";
  } # pid
  
  sub running ($) {
    return !!$_[0]->{running};
  } # running
  
  sub wait ($) {
    return $_[0]->{wait_promise} || Promise->reject (_r is_error => 1, message => "Not yet |run|");
  } # wait
  
  sub send_signal ($$) {
    my ($self, $signal) = @_;
    return Promise->new (sub {
      my $pid = $self->pid; # or die
      if ($self->running) {
        $_[0]->(_r killed => kill $signal, $pid);
      } else {
        $_[0]->(_r killed => 0);
      }
    });
  } # send_signal
  
  sub DESTROY ($) {
    my $self = $_[0];
    if ($self->{running}) {
      require Carp;
      warn "$$: $self is to be destroyed while the command ($self->{command}) is still running", Carp::shortmess;
      if (defined $self->{signal_before_destruction}) {
        kill $self->{signal_before_destruction}, $self->{pid};
      }
    }
  } # DESTROY
  
  package Promised::Command::Result;
  use overload '""' => 'stringify', bool => sub { 1 }, fallback => 1;
  
  sub is_success ($) {
    return not $_[0]->{is_error};
  } # is_success
  
  sub is_error ($) {
    return $_[0]->{is_error};
  } # is_error
  
  sub signal ($) { $_[0]->{signal} }
  sub core_dump ($) { $_[0]->{core_dump} }
  sub exit_code ($) { defined $_[0]->{exit_code} ? $_[0]->{exit_code} : -1 }
  sub message ($) { $_[0]->{message} }
  sub killed ($) { $_[0]->{killed} }
  
  sub stringify ($) {
    if ($_[0]->{is_error} and defined $_[0]->{message}) {
      return "Error: $_[0]->{message}";
    } elsif (defined $_[0]->{signal}) {
      return sprintf "Exit with signal %d%s",
          $_[0]->{signal}, $_[0]->{core_dump} ? ' with core dump' : '';
    } elsif (defined $_[0]->{exit_code}) {
      return sprintf "Exit code %d", $_[0]->{exit_code};
    } elsif ($_[0]->{is_error}) {
      return 'Unknown error';
    } else {
      return 'Success';
    }
  } # stringify
  
  1;
  
  =head1 LICENSE
  
  Copyright 2015-2020 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PROMISED_COMMAND

$fatpacked{"Promised/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PROMISED_FILE';
  package Promised::File;
  use strict;
  use warnings;
  our $VERSION = '6.0';
  use Carp;
  use AnyEvent::IO qw(:DEFAULT :flags);
  use AnyEvent::Util;
  use Promise;
  use Promised::Flow;
  
  push our @CARP_NOT, qw(
    Streams::IOError ReadableStream WritableStream
    TypedArray DataView Promise Promised::Flow
  );
  
  eval { require Web::Encoding };
  if (Web::Encoding->can ('encode_web_utf8')) {
    *encode_utf8 = Web::Encoding->can ('encode_web_utf8');
    *decode_utf8 = Web::Encoding->can ('decode_web_utf8');
  } else {
    require Encode;
    *encode_utf8 = sub ($) { return Encode::encode ("utf-8", $_[0]) };
    *decode_utf8 = sub ($) { return Encode::decode ("utf-8", $_[0]) };
  }
  
  sub new_from_path ($$) {
    my $path = $_[1];
    croak "No argument" unless defined $path;
    unless ($path =~ m{^/}) {
      require Cwd;
      $path = Cwd::getcwd () . '/' . $path;
    }
    $path = encode_utf8 ($path);
    return bless {path => $path}, $_[0];
  } # new_from_path
  
  sub new_temp_directory ($;%) {
    my ($class, %args) = @_;
    require File::Temp;
    my $temp = File::Temp->newdir (CLEANUP => !$args{no_cleanup});
    my $self = $class->new_from_path ($temp);
    $self->{_temp} = $temp;
    return $self;
  } # new_temp_directory
  
  sub path_string ($) {
    return $_[0]->{path};
  } # path_string
  
  sub stat ($) {
    my $self = $_[0];
    return Promise->resolve ($self->{stat}) if defined $self->{stat};
    return Promise->new (sub {
      my ($ok, $ng) = @_;
      aio_stat $self->{path}, sub {
        return $ng->("|$self->{path}|: $!") unless @_;
        require File::stat;
        $ok->($self->{stat} = File::stat::stat (\*_));
      };
    });
  } # stat
  
  sub lstat ($) {
    my $self = $_[0];
    return Promise->resolve ($self->{lstat}) if defined $self->{lstat};
    return Promise->new (sub {
      my ($ok, $ng) = @_;
      aio_lstat $self->{path}, sub {
        return $ng->("|$self->{path}|: $!") unless @_;
        require File::stat;
        $ok->($self->{lstat} = File::stat::stat (\*_));
      };
    });
  } # lstat
  
  sub is_file ($) {
    return $_[0]->stat->then (sub {
      return -f $_[0];
    }, sub {
      return 0;
    });
  } # is_file
  
  sub is_directory ($) {
    return $_[0]->stat->then (sub {
      return -d $_[0];
    }, sub {
      return 0;
    });
  } # is_directory
  
  sub is_symlink ($) {
    return $_[0]->lstat->then (sub {
      return -l $_[0];
    }, sub {
      return 0;
    });
  } # is_symlink
  
  sub is_executable ($) {
    return $_[0]->lstat->then (sub {
      return -x $_[0];
    }, sub {
      return 0;
    });
  } # is_executable
  
  sub mkpath ($) {
    my $self = $_[0];
    return $self->is_directory->then (sub {
      if ($_[0]) {
        return;
      } else {
        my $path = $self->{path};
        $path =~ s{/+[^/]*\z}{};
        return __PACKAGE__->new_from_path ($path)->mkpath->then (sub {
          return Promise->new (sub {
            my ($ok, $ng) = @_;
            aio_mkdir $self->{path}, 0755, sub {
              return $ng->("|$self->{path}|: $!") unless @_;
              delete $self->{stat};
              delete $self->{lstat};
              $ok->();
            };
          })->catch (sub {
            my $error = $_[0];
            delete $self->{stat};
            delete $self->{lstat};
            return $self->is_directory->then (sub {
              if ($_[0]) {
                return;
              } else {
                die $error;
              }
            });
          });
        });
      }
    });
  } # mkpath
  
  sub remove_tree ($) {
    my $self = $_[0];
    return $self->stat->then (sub {
      if (-e $_[0]) {
        return Promise->new (sub {
          my ($ok, $ng) = @_;
          my $path = $self->{path};
          fork_call {
            my $err;
            my $args = {error => \$err, safe => 1};
            require File::Path;
            File::Path::remove_tree ($path, $args);
            if (defined $err and @$err) {
              my ($file, $msg) = %{$err->[0]};
              die "$file: $msg\n";
            }
            return 1;
          } sub {
            return $ng->($@ || $!) unless @_;
            delete $self->{stat};
            delete $self->{lstat};
            $ok->();
          };
        });
      }
      return;
    }, sub { return });
  } # remove_tree
  
  sub get_child_names ($) {
    my $self = $_[0];
    return Promise->new (sub {
      my ($ok, $ng) = @_;
      aio_readdir $self->{path}, sub {
        return $ng->([0+$!, "".$!]) unless @_;
        $ok->($_[0]);
      };
    })->catch (sub {
      require Streams::IOError;
      die Streams::IOError->new_from_errno_and_message (@{$_[0]});
    });
  } # get_child_names
  
  sub read_bytes ($) {
    my $self = $_[0];
    require Streams::_Common;
    require Streams::IOError;
    require ArrayBuffer;
    require DataView;
    require ReadableStream;
    my $fh;
    my $rs = ReadableStream->new ({
      type => 'bytes',
      start => sub {
        my $rc = $_[1];
        return Promise->new (sub {
          my ($ok, $ng) = @_;
          aio_open $self->{path}, O_RDONLY, 0, sub {
            return $ng->([0+$!, "".$!]) unless @_;
            $fh = $_[0];
            $ok->();
          };
        })->catch (sub {
          die Streams::IOError->new_from_errno_and_message (@{$_[0]});
        });
      }, # start
      auto_allocate_chunk_size => $Streams::_Common::DefaultBufferSize,
      pull => sub {
        my $rc = $_[1];
        return ((promised_until {
          my $req = $rc->byob_request;
          return 'done' unless defined $req;
  
          my $length = $req->view->byte_length;
          return 'done' unless $length;
          return Promise->new (sub {
            my ($ok, $ng) = @_;
            return $ok->(undef) unless defined $fh;
            aio_read $fh, $length, sub {
              return $ng->([0+$!, ''.$!]) unless @_;
              $ok->(undef) unless length $_[0];
              $ok->(DataView->new (ArrayBuffer->new_from_scalarref (\($_[0]))));
            };
          })->then (sub {
            if (defined $_[0]) {
              $rc->enqueue ($_[0]); # will string-copy!
              return not 'done';
            } else { # eof
              $rc->close;
              $req->respond (0);
              undef $fh;
              return 'done';
            }
          }, sub {
            die Streams::IOError->new_from_errno_and_message (@{$_[0]});
          });
        })->catch (sub {
          undef $fh;
          die $_[0];
        }));
      }, # pull
      cancel => sub {
        undef $fh;
      }, # cancel
    });
    return $rs;
  } # read_bytes
  
  sub read_byte_string ($) {
    my $self = $_[0];
    return Promise->new (sub {
      my ($ok, $ng) = @_;
      aio_load $self->{path}, sub {
        return $ng->("|$self->{path}|: $!") unless @_;
        $ok->($_[0]);
      };
    });
  } # read_byte_string
  
  sub read_char_string ($) {
    return $_[0]->read_byte_string->then (sub {
      return decode_utf8 ($_[0]);
    });
  } # read_char_string
  
  sub _open_for_write ($$) {
    my ($self, $mode) = @_;
    my $path = $self->{path};
    $path =~ s{[^/]*\z}{};
    return __PACKAGE__->new_from_path ($path)->mkpath->then (sub {
      return Promise->new (sub {
        my ($ok, $ng) = @_;
        aio_open $self->{path}, $mode, 0644, sub {
          return $ng->([0+$!, "".$!]) unless @_;
          delete $self->{stat};
          delete $self->{lstat};
          $ok->($_[0]);
        };
      });
    });
  } # _open_for_write
  
  sub write_bytes ($) {
    my $self = $_[0];
    require Streams::IOError;
    require WritableStream;
    require DataView;
    my $fh;
    return WritableStream->new ({
      start => sub {
        return $self->_open_for_write (O_WRONLY | O_TRUNC | O_CREAT)->then (sub {
          $fh = $_[0];
        })->catch (sub {
          die Streams::IOError->new_from_errno_and_message (@{$_[0]})
              if ref $_[0] eq 'ARRAY';
          die $_[0];
        });
      }, # start
      write => sub {
        my $view = $_[1];
        return Promise->resolve->then (sub {
          die "The argument is not an ArrayBufferView"
              unless UNIVERSAL::isa ($view, 'ArrayBufferView');
          my $dv = DataView->new
              ($view->buffer, $view->byte_offset, $view->byte_length); # or throw
          return promised_until {
            return 'done' unless $dv->byte_length;
            return Promise->new (sub {
              my ($ok, $ng) = @_;
              aio_write $fh, $dv->manakai_to_string, sub {
                return $ng->([0+$!, "".$!]) unless @_;
                return $ok->($_[0]); # length
              };
            })->then (sub {
              $dv = DataView->new
                  ($dv->buffer, $dv->byte_offset + $_[0], $dv->byte_length - $_[0]); # or throw
            }, sub {
              die Streams::IOError->new_from_errno_and_message (@{$_[0]});
            });
            return not 'done';
          };
        })->catch (sub {
          my $error = $_[0];
          return Promise->new (sub {
            aio_close $fh, $_[0];
          })->then (sub {
            die $error;
          });
        });
      }, # write
      close => sub {
        return Promise->new (sub {
          aio_close $fh, $_[0];
        });
      }, # close
      abort => sub {
        return Promise->new (sub {
          aio_close $fh, $_[0];
        });
      }, # abort
    });
  } # write_bytes
  
  sub write_byte_string ($$) {
    my $self = $_[0];
    my $sref = \($_[1]);
    return $self->_open_for_write (O_WRONLY | O_TRUNC | O_CREAT)->catch (sub {
      die "|$self->{path}|: $_[0]->[1]" if ref $_[0] eq 'ARRAY';
      die $_[0];
    })->then (sub {
      my $fh = $_[0];
        my $write; $write = sub {
          return Promise->new (sub {
            my ($ok, $ng) = @_;
            aio_write $fh, $$sref, sub {
              return $ng->("|$self->{path}|: $!") unless @_;
              my $length = $_[0];
              if ($length < length $$sref) {
                my $s = substr $$sref, $length;
                $sref = \$s;
                $ok->($write->());
              } else {
                $ok->();
              }
            };
          });
        }; # $write
        return $write->()->then (sub {
          return Promise->new (sub {
            my ($ok, $ng) = @_;
            aio_close $fh, sub { $ok->() };
          });
        }, sub {
          my $error = $_[0];
          return Promise->new (sub {
            my ($ok, $ng) = @_;
            aio_close $fh, sub { $ok->() };
          })->then (sub { return $error });
        });
    });
  } # write_byte_string
  
  sub write_char_string ($$) {
    return $_[0]->write_byte_string (encode_utf8 ($_[1]));
  } # write_char_string
  
  sub lock_new_file ($;%) {
    my ($self, %args) = @_;
    return $self->_open_for_write (O_WRONLY | O_CREAT)->catch (sub {
      if (ref $_[0] eq 'ARRAY') {
        require Streams::IOError;
        die Streams::IOError->new_from_errno_and_message (@{$_[0]});
      }
      die $_[0];
    })->then (sub {
      my $fh = $_[0];
      return Promise->new (sub {
        my ($ok, $ng) = @_;
        my $sig = $args{signal} // die "No |signal| argument";
        die $sig->manakai_error if $sig->aborted;
        require AnyEvent::FileLock;
        my $w;
        $sig->manakai_onabort (sub {
          $ng->($sig->manakai_error);
          undef $w;
        });
        $w = AnyEvent::FileLock->flock (
          #file => $self->{path}, ## This option's error handling is broken!
          fh => $fh,
          mode => '>',
          timeout => $args{timeout},
          delay => $args{interval},
          cb => sub {
            my $fh = $_[0];
            if (defined $fh) {
              $sig->manakai_onabort (sub {
                #flock $fh, Fcntl::LOCK_UN
                undef $fh;
              });
              $ok->();
            } else {
              my $x = $!;
              require Streams::IOError;
              $ng->(Streams::IOError->new ($x));
              $sig->manakai_onabort (undef);
            }
            undef $w;
          },
        );
      });
    });
  } # lock_new_file
  
  1;
  
  =head1 LICENSE
  
  Copyright 2015-2020 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PROMISED_FILE

$fatpacked{"Promised/Flow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PROMISED_FLOW';
  package Promised::Flow;
  use strict;
  use warnings;
  our $VERSION = '4.0';
  use Carp;
  use AnyEvent;
  use Promise;
  use Promise::AbortError;
  use AbortController;
  
  our @EXPORT;
  push our @CARP_NOT, qw(Promise Promise::AbortError);
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
  } # import
  
  BEGIN {
    my $pr = Promise->resolve;
    eval q{ use constant PR => $pr };
    $pr->{is_global_variable} = 1;
    undef $pr;
  }
  
  push @EXPORT, qw(promised_cleanup);
  sub promised_cleanup (&$) {
    my ($code, $p) = @_;
    return $p->then (sub {
      my $return = $_[0];
      return PR->then ($code)->then (sub { return $return } );
    }, sub {
      my $error = $_[0];
      return PR->then ($code)->then (sub { die $error }, sub { die $error });
    });
  } # promised_cleanup
  
  push @EXPORT, qw(promised_sleep);
  sub promised_sleep ($;%) {
    my ($sec, %args) = @_;
    my $aborted = sub { };
    if (defined $args{signal}) {
      if ($args{signal}->aborted) {
        return Promise->reject (Promise::AbortError->new ('Aborted by signal'));
      } else {
        $args{signal}->manakai_onabort (sub {
          $aborted->();
        });
      }
    }
    return Promise->new (sub {
      my ($ok, $ng) = @_;
      my $timer;
      $aborted = sub {
        undef $timer;
        $ng->(Promise::AbortError->new ('Aborted by signal'));
        $aborted = $ok = $ng = sub { };
      };
      $timer = AE::timer $sec, 0, sub {
        undef $timer;
        $ok->();
        $aborted = $ok = $ng = sub { };
      };
    });
  } # promised_sleep
  
  push @EXPORT, qw(promised_timeout);
  sub promised_timeout (&$;%) {
    my ($code, $sec, %args) = @_;
    my $suffix = defined $args{name} ? " - $args{name}" : "";
    my $aborted = sub { };
    if (defined $args{signal}) {
      if ($args{signal}->aborted) {
        return Promise->reject (Promise::AbortError->new ('Aborted by signal' . $suffix));
      } else {
        $args{signal}->manakai_onabort (sub {
          $aborted->();
        });
      }
    }
    return PR->then ($code) unless defined $sec;
    return Promise->new (sub {
      my ($ok, $ng) = @_;
      my $to = Promise::AbortError->new ("Timeout ($sec s)$suffix");
      my $timer; $timer = AE::timer $sec, 0, sub {
        $ng->($to);
        undef $timer;
        $aborted = $ok = $ng = sub { };
      };
      $aborted = sub {
        undef $timer;
        $ng->(Promise::AbortError->new ('Aborted by signal' . $suffix));
        $aborted = $ok = $ng = sub { };
      };
      PR->then ($code)->then (sub {
        my $result = $_[0];
        undef $timer;
        $ok->($result);
        $aborted = $ok = $ng = sub { };
      }, sub {
        my $error = $_[0];
        undef $timer;
        $ng->($error);
        $aborted = $ok = $ng = sub { };
      });
    });
  } # promised_timeout
  
  push @EXPORT, qw(promised_for);
  sub promised_for (&$) {
    my ($code, $list) = @_;
    my $p = PR;
    for my $item (@$list) {
      $p = $p->then (sub {
        return $code->($item);
      });
    }
    return $p->then (sub { return undef });
  } # promised_for
  
  push @EXPORT, qw(promised_map);
  sub promised_map (&$) {
    my ($code, $list) = @_;
    my $p = Promise->resolve;
    my $new_list = [];
    for my $item (@$list) {
      $p = $p->then (sub {
        return $code->($item);
      })->then (sub {
        push @$new_list, $_[0];
      });
    }
    return $p->then (sub { return $new_list });
  } # promised_map
  
  push @EXPORT, qw(promised_until);
  sub promised_until (&;%) {
    my $cb = shift;
    my %args = @_;
  
    my ($f, $j);
    my $p = Promise->new (sub { ($f, $j) = @_ });
  
    my $iter; $iter = sub {
      if (defined $args{signal} and $args{signal}->aborted) {
        undef $iter;
        my $suffix = defined $args{name} ? " - $args{name}" : "";
        $j->(Promise::AbortError->new ('Aborted by signal' . $suffix));
        return undef;
      }
      PR->then ($cb)->then (sub {
        if ($_[0]) {
          undef $iter;
          $f->();
        } else {
          $iter->();
        }
        return undef;
      }, sub {
        undef $iter;
        $j->($_[0]);
      });
      return undef;
    }; # $iter
    $iter->();
  
    return $p;
  } # promised_until
  
  push @EXPORT, qw(promised_wait_until);
  sub promised_wait_until (&;%) {
    my ($code, %args) = @_;
    $args{interval} ||= 1;
  
    my $timer;
    my $ac = AbortController->new;
    return promised_cleanup {
      $ac->abort;
      undef $timer;
    } promised_timeout {
      return promised_until {
        return PR->then ($code)->then (sub {
          return 'done' if $_[0];
          return promised_sleep ($args{interval}, signal => $ac->signal)->then (sub {
            return not 'done';
          });
        });
      } signal => $args{signal}, name => $args{name};
    } $args{timeout}, name => $args{name};
  } # promised_wait_until
  
  push @EXPORT, qw(promised_cv);
  sub promised_cv () {
    my ($send, $croak);
    my $receive = Promise->new (sub { ($send, $croak) = @_ });
    return ($receive, $send, $croak);
  } # promised_cv
  
  1;
  
  =head1 LICENSE
  
  Copyright 2016-2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PROMISED_FLOW

$fatpacked{"ReadableStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'READABLESTREAM';
  package ReadableStream;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Scalar::Util qw(weaken);
  use ArrayBuffer;
  use TypedArray;
  use DataView;
  use Promise;
  use Streams::_Common;
  
  ## In JS (Streams Standard specification text), stream and controller
  ## are referencing each other by their internal slots:
  ##
  ##   stream.[[ReadableStreamController]] === controller
  ##   controller.[[ControlledReadableStream]] === stream
  ##
  ## In this module, a $stream is a blessed hash reference whose
  ## |readable_stream_controller| is a non-blessed hash reference
  ## containing controller's internal slots (except for
  ## [[ControlledReadableStream]]).  A $controller_obj is a blessed
  ## scalar reference to $stream.  $stream->{controller_obj} is a weak
  ## reference to $controller_obj.  $controller_obj is used when
  ## $underlying_sink methods are invoked.  If $stream->{controller_obj}
  ## is not defined, a new blessed scalar reference is created.
  ##
  ## Likewise, stream and reader are referencing each other in JS when
  ## there is a reader whose lock is not released:
  ##
  ##   stream.[[Reader]] === reader
  ##   reader.[[OwnerReadableStream]] === stream
  ##
  ## In this module, a $reader is a blessed scalar reference to $stream
  ## whose |reader| is a non-blessed hash reference containing reader's
  ## internal slots (except for [[OwnerReadableStream]]).  When the
  ## $reader's lock is released, $$reader is replaced by a new hash
  ## reference whose |reader| is $reader's hash reference (and
  ## $stream->{reader} is set to |undef|).
  ##
  ## A BYOB request object is represented as a blessed scalar reference
  ## to $stream whose |controller|'s |byob_request| is a non-blessed
  ## hash reference containing request's internal slots (except for
  ## [[AssociatedReadableStreamController]]) and |byob_request_obj| is
  ## weak reference to a BYOB request object.  When the request is
  ## invalidated, $$request is replaced by a new hash reference whose
  ## |controller| whose |byob_request| is $request's hash reference.
  
  sub new ($;$$) {
    die _type_error "Source is not a HASH"
        if defined $_[1] and not ref $_[1] eq 'HASH'; # Not in JS
    die _type_error "Options is not a HASH"
        if defined $_[2] and not ref $_[2] eq 'HASH'; # Not in JS
    my $self = bless {caller => [caller 0]}, $_[0];
    my $underlying_source = $_[1] || {};
    my $opts = $_[2] || {};
    $self->{state} = 'readable';
    $self->{reader} = undef;
    $self->{stored_error} = undef;
    $self->{disturbed} = undef;
    $self->{readable_stream_controller} = undef;
    my $hwm = $opts->{high_water_mark};
    if (not defined $underlying_source->{type}) {
      #$self->{readable_stream_controller} = # to be set in new
      ReadableStreamDefaultController->new
          ($self, $underlying_source, $opts->{size}, defined $hwm ? $hwm : 1);
    } else {
      my $type = ''.$underlying_source->{type}; # ToString
      if ($type eq 'bytes') {
        #$self->{readable_stream_controller} = # to be set in new
        ReadableByteStreamController->new
            ($self, $underlying_source, defined $hwm ? $hwm : 0);
      } else {
        die _range_error "Unknown type |$type|";
      }
    }
    return $self;
  } # new
  
  sub locked ($) {
    return defined $_[0]->{reader}; # IsReadableStreamLocked
  } # locked
  
  sub ReadableStream::_close ($) {
    my $stream = $_[0];
    $stream->{state} = 'closed';
    my $reader = $stream->{reader};
    if (defined $reader) {
      if (defined $reader->{read_requests}) { # IsReadableStreamDefaultReader
        for my $read_request (@{$reader->{read_requests}}) {
          $read_request->{promise}->{resolve}->({done => 1});
        }
        $reader->{read_requests} = [];
      }
      $reader->{closed_promise}->{resolve}->(undef);
    }
  } # ReadableStreamClose
  
  sub ReadableStream::_cancel ($$) {
    my $stream = $_[0];
    $stream->{disturbed} = 1;
    if ($stream->{state} eq 'closed') {
      return Promise->resolve (undef);
    } elsif ($stream->{state} eq 'errored') {
      return Promise->reject ($stream->{stored_error});
    }
    ReadableStream::_close $stream;
    my $controller_obj = $stream->{controller_obj};
    unless (defined $controller_obj) {
      weaken ($stream->{controller_obj} = bless \$stream, $stream->{controller_class});
      $controller_obj = $stream->{controller_obj};
    }
    return $controller_obj->_cancel_steps ($_[1])->then (sub {
      $stream->_terminate; # Not in JS
      return undef;
    });
  } # ReadableStreamCancel
  
  sub cancel ($;$) {
    return Promise->reject (_type_error "ReadableStream is locked")
        if defined $_[0]->{reader}; # IsReadableStreamLocked
    return ReadableStream::_cancel $_[0], $_[1];
  } # cancel
  
  sub get_reader ($;$) {
    if (defined $_[1]) {
      my $mode = ''.$_[1]; # ToString
      if ($mode eq 'byob') {
        ## AcquireReadableStreamBYOBReader
        return ReadableStreamBYOBReader->new ($_[0]);
      } else {
        die _range_error "Unknown mode |$mode|";
      }
    } else {
      ## AcquireReadableStreamDefaultReader
      return ReadableStreamDefaultReader->new ($_[0]);
    }
  } # getReader(mode)
  
  # XXX Not implemented yet:
  # $rs->pipe_to pipe_through tee
  
  ## XXX IsReadableStreamDisturbed hook
  
  # Not in JS
  sub _terminate ($) {
    my $stream = $_[0];
    delete $stream->{readable_stream_controller}->{underlying_source};
    $stream->{readable_stream_controller}->{underlying_byte_source} = {};
    delete $stream->{readable_stream_controller}->{strategy_size};
  } # _terminate
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/) {
      my $diag = '';
      if ($_[0]->{state} eq 'readable') {
        $diag = ' (Stream is not closed)';
      }
      warn "$$: Reference to @{[ref $_[0]]} created at $_[0]->{caller}->[1] line $_[0]->{caller}->[2] is not discarded before global destruction$diag\n";
    }
  } # DESTROY
  
  package ReadableStreamDefaultController;
  use Scalar::Util qw(weaken);
  use Streams::_Common;
  push our @CARP_NOT, qw(ReadableStream);
  
  sub ReadableStreamDefaultController::_get_desired_size ($$) {
    my $controller = $_[0];
    my $stream = $_[1]; #$controller->{controlled_readable_stream};
    my $state = $stream->{state};
    return undef if $state eq 'errored';
    return 0 if $state eq 'closed';
    return $controller->{strategy_hwm} - $controller->{queue_total_size};
  } # ReadableStreamDefaultControllerGetDesiredSize
  
  sub ReadableStream::_error ($$) {
    my $stream = $_[0];
    $stream->{state} = 'errored';
    $stream->{stored_error} = $_[1];
    my $reader = $stream->{reader};
    if (defined $reader) {
      if (defined $reader->{read_requests}) { # IsReadableStreamDefaultReader
        for my $read_request (@{$reader->{read_requests}}) {
          $read_request->{promise}->{reject}->($_[1]);
        }
        $reader->{read_requests} = [];
      } else {
        for my $read_into_request (@{$reader->{read_into_requests}}) {
          $read_into_request->{promise}->{reject}->($_[1]);
        }
        $reader->{read_into_requests} = [];
      }
      $reader->{closed_promise}->{reject}->($_[1]);
      $reader->{closed_promise}->{promise}->manakai_set_handled;
    }
    $stream->_terminate; # Not in JS
  } # ReadableStreamError
  
  sub ReadableStreamDefaultController::_error ($$$) {
    my $controller = $_[0];
    my $stream = $_[2]; #$controller->{controlled_readable_stream};
  
    ## ResetQueue
    $controller->{queue} = [];
    $controller->{queue_total_size} = 0;
  
    ReadableStream::_error $stream, $_[1];
  } # ReadableByteStreamControllerError
  
  sub ReadableStreamDefaultController::_call_pull_if_needed ($$) {
    my $controller = $_[0];
    my $stream = $_[1]; #$controller->{controlled_readable_stream};
  
    {
      ## return unless ReadableStreamDefaultControllerShouldCallPull
      return if $stream->{state} eq 'closed' or $stream->{state} eq 'errored';
      last if $controller->{close_requested};
      return unless $controller->{started};
      if (defined $controller->{reader} and # IsReadableStreamLocked
          (
            ## ReadableStreamGetNumReadRequests
            @{$controller->{reader}->{read_requests}}
          ) > 0) {
        last;
      }
      my $desired_size = ReadableStreamDefaultController::_get_desired_size
          $controller, $stream;
      return unless $desired_size > 0;
    }
  
    if ($controller->{pulling}) {
      $controller->{pull_again} = 1;
      return undef;
    }
    $controller->{pulling} = 1;
    my $controller_obj = $stream->{controller_obj};
    unless (defined $controller_obj) {
      weaken ($stream->{controller_obj} = bless \$stream, $stream->{controller_class});
      $controller_obj = $stream->{controller_obj};
    }
    _hashref_method ($controller->{underlying_source}, 'pull', [$controller_obj])->then (sub {
      $controller->{pulling} = 0;
      if ($controller->{pull_again}) {
        $controller->{pull_again} = 0;
        ReadableStreamDefaultController::_call_pull_if_needed
            ($controller, $stream);
      }
      return undef;
    }, sub {
      ## ReadableStreamDefaultControllerErrorIfNeeded
      if ($stream->{state} eq 'readable') {
        ReadableStreamDefaultController::_error ($controller, $_[0], $stream);
      } else {
        warn "Uncaught exception: $_[0]";
      }
    });
    return undef;
  } # ReadableStreamDefaultControllerCallPullIfNeeded
  
  sub new ($$$$$) {
    my ($class, $stream, $underlying_source, $size, $hwm) = @_;
    die _type_error "ReadableStream is closed"
        unless UNIVERSAL::isa ($stream, 'ReadableStream'); # IsReadableStream
    die _type_error "ReadableStream has a controller"
        if defined $stream->{readable_stream_controller};
    my $controller = {};
    my $controller_obj = bless \$stream, $class;
    #$controller->{controlled_readable_stream} = $stream;
    $controller->{underlying_source} = $underlying_source;
  
    ## ResetQueue
    $controller->{queue} = [];
    $controller->{queue_total_size} = 0;
  
    $controller->{started} = 0;
    $controller->{close_requested} = 0;
    $controller->{pull_again} = 0;
    $controller->{pulling} = 0;
  
    ## ValidateAndNormalizeQueuingStrategy
    {
      die _type_error "Size is not a CODE"
          if defined $size and not ref $size eq 'CODE';
      $controller->{strategy_size} = $size;
  
      ## ValidateAndNormalizeHighWaterMark
      $hwm = 0+($hwm || 0); # ToNumber
      $hwm = 0 if $hwm eq 'NaN' or $hwm eq 'nan'; # Not in JS
      $controller->{strategy_hwm} = $hwm;
      die _range_error "High water mark $hwm is negative" if $hwm < 0;
    }
  
    ## In spec, done within ReadableStream constructor
    $stream->{readable_stream_controller} = $controller;
    weaken ($stream->{controller_obj} = $controller_obj);
    $stream->{controller_class} = $_[0];
  
    _hashref_method_throws ($underlying_source, 'start', [$controller_obj])->then (sub { # requires Promise
      $controller->{started} = 1;
      ReadableStreamDefaultController::_call_pull_if_needed
          $controller, $stream;
    }, sub {
      ## ReadableStreamDefaultControllerErrorIfNeeded
      if ($stream->{state} eq 'readable') {
        ReadableStreamDefaultController::_error ($controller, $_[0], $stream);
      }
    });
  
    return $controller_obj;
  } # new
  
  sub desired_size ($) {
    return ReadableStreamDefaultController::_get_desired_size
        ${$_[0]}->{readable_stream_controller}, ${$_[0]};
  } # desired_size
  
  sub close ($) {
    my $controller = ${$_[0]}->{readable_stream_controller};
    my $stream = ${$_[0]}; #$controller->{controlled_readable_stream};
    die _type_error "ReadableStream is closed" if $controller->{close_requested};
    die _type_error "ReadableStream is closed"
        unless $stream->{state} eq 'readable';
  
    ## ReadableStreamDefaultControllerClose
    $controller->{close_requested} = 1;
    unless (@{$controller->{queue}}) {
      ReadableStream::_close $stream;
      $stream->_terminate; # Not in JS
    }
    return undef;
  } # close
  
  sub enqueue ($$) {
    my $controller = ${$_[0]}->{readable_stream_controller};
    my $stream = ${$_[0]}; #$controller->{controlled_readable_stream};
    die _type_error "ReadableStream is closed" if $controller->{close_requested};
    die _type_error "ReadableStream is closed"
        unless $stream->{state} eq 'readable';
  
    ## ReadableStreamDefaultControllerEnqueue
    if (defined $stream->{reader} and # IsReadableStreamLocked
        (
          ## ReadableStreamGetNumReadRequests
          @{$stream->{reader}->{read_requests}}
        ) > 0) {
      ## ReadableStreamFulfillReadRequest
      my $read_request = shift @{$stream->{reader}->{read_requests}};
      $read_request->{promise}->{resolve}->({value => $_[1]}); # CreateIterResultObject
    } else {
      my $chunk_size = 1;
      if (defined $controller->{strategy_size}) {
        $chunk_size = eval { $controller->{strategy_size}->($_[1]) };
        if ($@) {
          ## ReadableStreamDefaultControllerErrorIfNeeded
          if ($stream->{state} eq 'readable') {
            ReadableStreamDefaultController::_error ($controller, $@, $stream);
          }
  
          die $@;
        }
      }
  
      ## EnqueueValueWithSize
      my $size = eval { _to_size $chunk_size, 'Size' };
      if ($@) {
        ## ReadableStreamDefaultControllerErrorIfNeeded
        if ($stream->{state} eq 'readable') {
          ReadableStreamDefaultController::_error ($controller, $@, $stream);
        }
  
        die $@;
      }
      push @{$controller->{queue}}, {value => $_[1], size => $size};
      $controller->{queue_total_size} += $size;
    }
    ReadableStreamDefaultController::_call_pull_if_needed $controller, $stream;
    return undef;
  } # enqueue(chunk)
  
  sub error ($$) {
    my $stream = ${$_[0]}; #$_[0]->{controlled_readable_stream};
    die _type_error "ReadableStream is closed"
        unless $stream->{state} eq 'readable';
    ReadableStreamDefaultController::_error
        ${$_[0]}->{readable_stream_controller}, $_[1], $stream;
    return undef;
  } # error(e)
  
  sub _cancel_steps ($$) {
    my $controller = ${$_[0]}->{readable_stream_controller};
  
    ## ResetQueue
    $controller->{queue} = [];
    $controller->{queue_total_size} = 0;
  
    return _hashref_method ($controller->{underlying_source}, 'cancel', [$_[1]]);
  } # [[CancelSteps]]
  
  sub _pull_steps ($) {
    my $controller = ${$_[0]}->{readable_stream_controller};
    my $stream = ${$_[0]}; #$controller->{controlled_readable_stream};
    if (@{$controller->{queue}}) {
      ## DequeueValue
      my $pair = shift @{$controller->{queue}};
      $controller->{queue_total_size} -= $pair->{size};
      $controller->{queue_total_size} = 0 if $controller->{queue_total_size} < 0;
  
      if ($controller->{close_requested} and not @{$controller->{queue}}) {
        ReadableStream::_close $stream;
        $stream->_terminate; # Not in JS
      } else {
        ReadableStreamDefaultController::_call_pull_if_needed
            $controller, $stream;
      }
      return Promise->resolve ({value => $pair->{value}}); # CreateIterResultObject
    }
  
    ## ReadableStreamAddReadRequest
    my $p = _promise_capability;
    push @{$stream->{reader}->{read_requests}}, {promise => $p};
  
    ReadableStreamDefaultController::_call_pull_if_needed $controller, $stream;
    return $p->{promise};
  } # [[PullSteps]]
  
  #sub DESTROY ($) {
  #  local $@;
  #  eval { die };
  #  if ($@ =~ /during global destruction/) {
  #    warn "$$: Reference to @{[ref $_[0]]} is not discarded before global destruction\n";
  #  }
  #} # DESTROY
  
  package ReadableByteStreamController;
  use Scalar::Util qw(weaken);
  use Streams::_Common;
  push our @CARP_NOT, qw(
    ReadableStream
    DataView TypedArray
  );
  
  sub ReadableByteStreamController::_invalidate_byob_request ($) {
    return if not defined $_[0]->{byob_request};
    #$_[0]->{byob_request}->{associated_readable_byte_stream_controller} = undef;
    if (defined $_[0]->{byob_request_obj}) {
      ${$_[0]->{byob_request_obj}} = {readable_stream_controller => {byob_request => $_[0]->{byob_request}}};
    }
    $_[0]->{byob_request}->{view} = undef;
    $_[0]->{byob_request} = undef;
    $_[0]->{byob_request_obj} = undef;
  } # ReadableByteStreamControllerInvalidateBYOBRequest
  
  sub ReadableByteStreamController::_error ($$) {
    #my $controller = $_[0];
    #my $stream = $controller->{controlled_readable_stream};
    my $stream = $_[0];
    my $controller = $stream->{readable_stream_controller};
  
    ## ReadableByteStreamControllerClearPendingPullIntos
    ReadableByteStreamController::_invalidate_byob_request $controller;
    $controller->{pending_pull_intos} = [];
  
    ## ResetQueue
    $controller->{queue} = [];
    $controller->{queue_total_size} = 0;
  
    ReadableStream::_error $stream, $_[1];
  } # ReadableByteStreamControllerError
  
  sub ReadableByteStreamController::_get_desired_size ($) {
    #my $controller = $_[0];
    #my $stream = $controller->{controlled_readable_stream};
    my $stream = $_[0];
    my $controller = $stream->{readable_stream_controller};
  
    return undef if $stream->{state} eq 'errored';
    return 0 if $stream->{state} eq 'closed';
    return $controller->{strategy_hwm} - $controller->{queue_total_size};
  } ## ReadableByteStreamControllerGetDesiredSize
  
  sub ReadableByteStreamController::_call_pull_if_needed ($) {
    #my $controller = $_[0];
    #my $stream = $controller->{controlled_readable_stream};
    my $stream = $_[0];
    my $controller = $stream->{readable_stream_controller};
  
    {
      ## return unless ReadableByteStreamControllerShouldCallPull
      return unless $stream->{state} eq 'readable';
      return if $controller->{close_requested};
      return unless $controller->{started};
      if (
        ## ReadableStreamHasDefaultReader
        (defined $stream->{reader} and defined $stream->{reader}->{read_requests}) # IsReadableStreamDefaultReader
        and
        (
          ## ReadableStreamGetNumReadRequests
          @{$stream->{reader}->{read_requests}}
        ) > 0
      ) {
        last;
      }
      if (
        ## ReadableStreamHasBYOBReader
        (defined $stream->{reader} and defined $stream->{reader}->{read_into_requests}) # IsReadableStreamBYOBReader
        and
          (
            ## ReadableStreamGetNumReadIntoRequests
            @{$stream->{reader}->{read_into_requests}}
          ) > 0
      ) {
        last;
      }
      #if (ReadableByteStreamController::_get_desired_size ($controller) > 0) {
      if (ReadableByteStreamController::_get_desired_size ($stream) > 0) {
        last;
      }
      return;
    }
  
    if ($controller->{pulling}) {
      $controller->{pull_again} = 1;
      return;
    }
    $controller->{pulling} = 1;
    my $controller_obj = $stream->{controller_obj};
    unless (defined $controller_obj) {
      weaken ($stream->{controller_obj} = bless \$stream, $stream->{controller_class});
      $controller_obj = $stream->{controller_obj};
    }
    _hashref_method ($controller->{underlying_byte_source}, 'pull', [$controller_obj])->then (sub {
      $controller->{pulling} = 0;
      if ($controller->{pull_again}) {
        $controller->{pull_again} = 0;
        ReadableByteStreamController::_call_pull_if_needed ($stream);
        #ReadableByteStreamController::_call_pull_if_needed ($controller);
      }
    }, sub {
      if ($stream->{state} eq 'readable') {
        ReadableByteStreamController::_error $stream, $_[0];
        #ReadableByteStreamController::_error $controller, $_[0];
      } else {
        warn "Uncaught exception: $_[0]";
      }
    });
    return undef;
  } ## ReadableByteStreamControllerCallPullIfNeeded
  
  sub new ($$$$) {
    my ($class, $stream, $underlying_byte_source, $hwm) = @_;
    die _type_error "ReadableStream has a controller"
        if defined $stream->{readable_stream_controller};
    my $controller = {};
    my $controller_obj = bless \$stream, $class;
    #$controller->{controlled_readable_stream} = $stream;
    $controller->{underlying_byte_source} = $underlying_byte_source;
    $controller->{pull_again} = 0;
    $controller->{pulling} = 0;
  
    ## ReadableByteStreamControllerClearPendingPullIntos
    ReadableByteStreamController::_invalidate_byob_request $controller;
    $controller->{pending_pull_intos} = [];
  
    ## ResetQueue
    $controller->{queue} = [];
    $controller->{queue_total_size} = 0;
  
    $controller->{started} = 0;
    $controller->{close_requested} = 0;
  
    ## ValidateAndNormalizeHighWaterMark
    $hwm = 0+($hwm || 0); # ToNumber
    $hwm = 0 if $hwm eq 'NaN' or $hwm eq 'nan'; # Not in JS
    $controller->{strategy_hwm} = $hwm;
    die _range_error "High water mark $hwm is negative" if $hwm < 0;
  
    my $auto_allocate_chunk_size = $underlying_byte_source->{auto_allocate_chunk_size};
    if (defined $auto_allocate_chunk_size) {
      ## In the spec, RangeError if not IsInteger(size) or size <= 0.
      ## NaN handling is different here to be Perlish.
      my $size = int _to_size $auto_allocate_chunk_size, 'Chunk size';
      die _range_error "Chunk size $auto_allocate_chunk_size is not a positive integer"
          unless $size == $auto_allocate_chunk_size and $size > 0;
      $controller->{auto_allocate_chunk_size} = $size;
    }
    $controller->{pending_pull_intos} = [];
  
    ## In spec, done within ReadableStream constructor
    $stream->{readable_stream_controller} = $controller;
    weaken ($stream->{controller_obj} = $controller_obj);
    $stream->{controller_class} = $_[0];
  
    _hashref_method_throws ($underlying_byte_source, 'start', [$controller_obj])->then (sub {
      $controller->{started} = 1;
      ReadableByteStreamController::_call_pull_if_needed $stream;
      #ReadableByteStreamController::_call_pull_if_needed $controller;
    }, sub {
      if ($stream->{state} eq 'readable') {
        ReadableByteStreamController::_error $stream, $_[0];
        #ReadableByteStreamController::_error $controller, $_[0];
      }
    });
  
    return $controller_obj;
  } # new
  
  sub byob_request ($) {
    my $stream = ${$_[0]};
    my $controller = $stream->{readable_stream_controller};
    if (not defined $controller->{byob_request} and
        @{$controller->{pending_pull_intos}}) {
      my $first_descriptor = $controller->{pending_pull_intos}->[0];
      my $view = TypedArray::Uint8Array->new
          ($first_descriptor->{buffer},
           $first_descriptor->{byte_offset} + $first_descriptor->{bytes_filled},
           $first_descriptor->{byte_length} - $first_descriptor->{bytes_filled});
      return
      #$controller->{byob_request_obj} = # to be set in new
      ReadableStreamBYOBRequest->new ($_[0], $view);
    }
    if (defined $controller->{byob_request} and
        not defined $controller->{byob_request_obj}) {
      my $req = bless \$stream, 'ReadableStreamBYOBRequest';
      weaken ($controller->{byob_request_obj} = $req);
      return $req;
    }
    return $controller->{byob_request_obj};
  } # byob_request
  
  sub desired_size ($) {
    return ReadableByteStreamController::_get_desired_size ${$_[0]};
    #return ReadableByteStreamController::_get_desired_size
    #    ${$_[0]}->{readable_stream_controller};
  } # desired_size
  
  sub close ($) {
    my $controller = ${$_[0]}->{readable_stream_controller};
    my $stream = ${$_[0]}; #$controller->{controlled_readable_stream};
    die _type_error "ReadableStream is closed" if $controller->{close_requested};
    die _type_error "ReadableStream is closed"
        unless $stream->{state} eq 'readable';
  
    ## ReadableByteStreamControllerClose
    if ($controller->{queue_total_size} > 0) {
      $controller->{close_requested} = 1;
      return;
    }
    if (@{$controller->{pending_pull_intos}}) {
      my $first_pending_pull_into = $controller->{pending_pull_intos}->[0];
      if ($first_pending_pull_into->{bytes_filled} > 0) {
        my $e = _type_error "There is a pending read request";
        ReadableByteStreamController::_error $stream, $e;
        #ReadableByteStreamController::_error $controller, $e;
        die $e;
      }
    }
    ReadableStream::_close $stream;
    $stream->_terminate; # Not in JS
    return undef;
  } # close
  
  sub _min ($$) {
    return $_[0] > $_[1] ? $_[1] : $_[0];
  } # _min
  
  sub ReadableByteStreamController::_fill_pull_into_descriptor_from_queue ($$) {
    my ($controller, $pull_into_descriptor) = @_;
    my $element_size = $pull_into_descriptor->{element_size};
    my $current_aligned_bytes = $pull_into_descriptor->{bytes_filled} - ($pull_into_descriptor->{bytes_filled} % $element_size);
    my $max_bytes_to_copy = _min ($controller->{queue_total_size}, $pull_into_descriptor->{byte_length} - $pull_into_descriptor->{bytes_filled});
    my $max_bytes_filled = $pull_into_descriptor->{bytes_filled} + $max_bytes_to_copy;
    my $max_aligned_bytes = $max_bytes_filled - ($max_bytes_filled % $element_size);
    my $total_bytes_to_copy_remaining = $max_bytes_to_copy;
    my $ready = 0;
    if ($max_aligned_bytes > $current_aligned_bytes) {
      $total_bytes_to_copy_remaining = $max_aligned_bytes - $pull_into_descriptor->{bytes_filled};
      $ready = 1;
    }
    my $queue = $controller->{queue};
    while ($total_bytes_to_copy_remaining) {
      my $head_of_queue = $queue->[0];
      my $bytes_to_copy = _min ($total_bytes_to_copy_remaining, $head_of_queue->{byte_length});
      my $dest_start = $pull_into_descriptor->{byte_offset} + $pull_into_descriptor->{bytes_filled};
  
      ArrayBuffer::_copy_data_block_bytes
          $pull_into_descriptor->{buffer}, $dest_start,
          $head_of_queue->{buffer}, $head_of_queue->{byte_offset},
          $bytes_to_copy;
  
      if ($head_of_queue->{byte_length} == $bytes_to_copy) {
        shift @{$queue};
      } else {
        $head_of_queue->{byte_offset} += $bytes_to_copy;
        $head_of_queue->{byte_length} -= $bytes_to_copy;
      }
      $controller->{queue_total_size} -= $bytes_to_copy;
  
      ## ReadableByteStreamControllerFillHeadPullIntoDescriptor
      ReadableByteStreamController::_invalidate_byob_request $controller;
      $pull_into_descriptor->{bytes_filled} += $bytes_to_copy;
  
      $total_bytes_to_copy_remaining -= $bytes_to_copy;
    }
    return $ready;
  } # ReadableByteStreamControllerFillPullIntoDescriptorFromQueue
  
  sub ReadableByteStreamController::_commit_pull_into_descriptor ($$) {
    my $pull_into_descriptor = $_[1];
    my $done = $_[0]->{state} eq 'closed';
  
    ## ReadableByteStreamControllerConvertPullIntoDescriptor
    my $filled_view = $pull_into_descriptor->{ctor}->new
        ($pull_into_descriptor->{buffer},
         $pull_into_descriptor->{byte_offset},
         $pull_into_descriptor->{bytes_filled} / $pull_into_descriptor->{element_size});
  
    if ($pull_into_descriptor->{reader_type} eq 'default') {
      ## ReadableStreamFulfillReadRequest
      my $read_request = shift @{$_[0]->{reader}->{read_requests}};
      $read_request->{promise}->{resolve}->({value => $filled_view, done => $done}); # CreateIterResultObject
    } else {
      ## ReadableStreamFulfillReadIntoRequest
      my $read_into_request = shift @{$_[0]->{reader}->{read_into_requests}};
      $read_into_request->{promise}->{resolve}->({value => $filled_view, done => $done}); # CreateIterResultObject
    }
  } # ReadableByteStreamControllerCommitPullIntoDescriptor
  
  sub ReadableByteStreamController::_process_pull_into_descriptors_using_queue ($$) {
    my $controller = $_[0];
    my $stream = $_[1];
    while (@{$controller->{pending_pull_intos}}) {
      return if $controller->{queue_total_size} == 0;
      my $pull_into_descriptor = $controller->{pending_pull_intos}->[0];
      if (ReadableByteStreamController::_fill_pull_into_descriptor_from_queue
              $controller, $pull_into_descriptor) {
        ## ReadableByteStreamControllerShiftPendingPullInto
        shift @{$controller->{pending_pull_intos}};
        ReadableByteStreamController::_invalidate_byob_request $controller;
  
        ReadableByteStreamController::_commit_pull_into_descriptor
            $stream, $pull_into_descriptor;
      }
    }
  } # ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue
  
  sub enqueue ($$) {
    my $controller = ${$_[0]}->{readable_stream_controller};
    my $stream = ${$_[0]}; #$controller->{controlled_readable_stream};
    die _type_error "ReadableStream is closed" if $controller->{close_requested};
    die _type_error "ReadableStream is closed"
        unless $stream->{state} eq 'readable';
    die _type_error "The argument is not an ArrayBufferView"
        unless UNIVERSAL::isa ($_[1], 'ArrayBufferView'); # has [[ViewedArrayBuffer]]
    die _type_error 'ArrayBuffer is detached'
        if not defined $_[1]->buffer->{array_buffer_data}; ## IsDetachedBuffer
  
    ## ReadableByteStreamControllerEnqueue
    my $buffer = $_[1]->{viewed_array_buffer};
    my $byte_offset = $_[1]->{byte_offset};
    my $byte_length = $_[1]->{byte_length};
    my $transferred_buffer = $buffer->_transfer;
    if (
      ## ReadableStreamHasDefaultReader
      (defined $stream->{reader} and $stream->{reader}->{read_requests}) # IsReadableStreamDefaultReader
    ) {
      if (
        ## ReadableStreamGetNumReadRequests
        @{$stream->{reader}->{read_requests}}
      == 0) {
        ## ReadableByteStreamControllerEnqueueChunkToQueue
        push @{$controller->{queue}}, {
          buffer => $transferred_buffer,
          byte_offset => $byte_offset,
          byte_length => $byte_length,
        };
        $controller->{queue_total_size} += $byte_length;
      } else {
        my $transferred_view = TypedArray::Uint8Array->new
            ($transferred_buffer, $byte_offset, $byte_length);
  
        ## ReadableStreamFulfillReadRequest
        my $read_request = shift @{$stream->{reader}->{read_requests}};
        $read_request->{promise}->{resolve}->({value => $transferred_view}); # CreateIterResultObject
      }
    } elsif (
      ## ReadableStreamHasBYOBReader
      (defined $stream->{reader} and defined $stream->{reader}->{read_into_requests}) # IsReadableStreamBYOBReader
    ) {
      ## ReadableByteStreamControllerEnqueueChunkToQueue
      push @{$controller->{queue}}, {
        buffer => $transferred_buffer,
        byte_offset => $byte_offset,
        byte_length => $byte_length,
      };
      $controller->{queue_total_size} += $byte_length;
  
      ReadableByteStreamController::_process_pull_into_descriptors_using_queue
          $controller, $stream;
    } else {
      ## ReadableByteStreamControllerEnqueueChunkToQueue
      push @{$controller->{queue}}, {
        buffer => $transferred_buffer,
        byte_offset => $byte_offset,
        byte_length => $byte_length,
      };
      $controller->{queue_total_size} += $byte_length;
    }
    return undef;
  } # enqueue(chunk)
  
  sub error ($$) {
    die _type_error "ReadableStream is closed"
        unless ${$_[0]}->{state} eq 'readable';
        #unless $_[0]->{controlled_readable_stream}->{state} eq 'readable';
    ReadableByteStreamController::_error ${$_[0]}, $_[1];
    #ReadableByteStreamController::_error ${$_[0]}->{readable_stream_controller}, $_[1];
    return undef;
  } # error(e)
  
  sub _cancel_steps ($$) {
    my $controller = ${$_[0]}->{readable_stream_controller};
  
    if (@{$controller->{pending_pull_intos}}) {
      my $first_descriptor = $controller->{pending_pull_intos}->[0];
      $first_descriptor->{bytes_filled} = 0;
    }
  
    ## ResetQueue
    $controller->{queue} = [];
    $controller->{queue_total_size} = 0;
  
    return _hashref_method ($controller->{underlying_byte_source}, 'cancel', [$_[1]]);
  } # [[CancelSteps]]
  
  sub _pull_steps ($) {
    my $controller = ${$_[0]}->{readable_stream_controller};
    my $stream = ${$_[0]}; #$controller->{controlled_readable_stream};
    if ($controller->{queue_total_size}) {
      my $entry = shift @{$controller->{queue}};
      $controller->{queue_total_size} -= $entry->{byte_length};
  
      ## ReadableByteStreamControllerHandleQueueDrain
      if ($controller->{queue_total_size} == 0 and
          $controller->{close_requested}) {
        ReadableStream::_close $stream;
        $stream->_terminate; # Not in JS
      } else {
        ReadableByteStreamController::_call_pull_if_needed $stream;
        #ReadableByteStreamController::_call_pull_if_needed $controller;
      }
  
      my $view = TypedArray::Uint8Array->new
          ($entry->{buffer}, $entry->{byte_offset}, $entry->{byte_length});
      return Promise->resolve ({value => $view}); # CreateIterResultObject
    }
    my $auto_allocate_chunk_size = $controller->{auto_allocate_chunk_size};
    if (defined $auto_allocate_chunk_size) {
      my $buffer = eval { ArrayBuffer->new ($auto_allocate_chunk_size) };
      return Promise->reject ($@) if $@;
      $buffer->manakai_label ('auto-allocation');
      push @{$controller->{pending_pull_intos}}, {
        buffer => $buffer,
        byte_offset => 0, byte_length => $auto_allocate_chunk_size,
        bytes_filled => 0, element_size => 1, ctor => 'TypedArray::Uint8Array',
        reader_type => 'default',
      };
    }
  
    ## ReadableStreamAddReadRequest
    my $p = _promise_capability;
    push @{$stream->{reader}->{read_requests}}, {promise => $p};
  
    #ReadableByteStreamController::_call_pull_if_needed $controller;
    ReadableByteStreamController::_call_pull_if_needed $stream;
    return $p->{promise};
  } # [[PullSteps]
  
  #sub DESTROY ($) {
  #  local $@;
  #  eval { die };
  #  if ($@ =~ /during global destruction/) {
  #    warn "$$: Reference to @{[ref $_[0]]} is not discarded before global destruction\n";
  #  }
  #} # DESTROY
  
  package ReadableStreamBYOBRequest;
  use Scalar::Util qw(weaken);
  use Streams::_Common;
  push our @CARP_NOT, qw(ReadableByteStreamController);
  
  sub ReadableByteStreamController::_respond_internal ($$) {
    #my $controller = $_[0];
    #my $stream = $controller->{controlled_readable_stream};
    my $stream = $_[0];
    my $controller = $_[0]->{readable_stream_controller};
    my $first_descriptor = $controller->{pending_pull_intos}->[0];
    if ($stream->{state} eq 'closed') {
      die _type_error "ReadableStream is closed" unless $_[1] == 0;
  
      ## ReadableByteStreamControllerRespondInClosedState
      $first_descriptor->{buffer} = $first_descriptor->{buffer}->_transfer;
      if (
        ## ReadableStreamHasBYOBReader
        (defined $stream->{reader} and defined $stream->{reader}->{read_into_requests}) # IsReadableStreamBYOBReader
      ) {
        while (
          ## ReadableStreamGetNumReadIntoRequests
          @{$stream->{reader}->{read_into_requests}}
        ) {
          ## ReadableByteStreamControllerShiftPendingPullInto
          shift @{$controller->{pending_pull_intos}};
          ReadableByteStreamController::_invalidate_byob_request $controller;
  
          ReadableByteStreamController::_commit_pull_into_descriptor
              $stream, $first_descriptor;
        }
      }
    } else { ## ReadableByteStreamControllerRespondInReadableState
      die _range_error "Byte length $_[1] is greater than requested length @{[$first_descriptor->{byte_length} - $first_descriptor->{bytes_filled}]}"
          if $first_descriptor->{bytes_filled} + $_[1] > $first_descriptor->{byte_length};
  
      ## ReadableByteStreamControllerFillHeadPullIntoDescriptor
      ReadableByteStreamController::_invalidate_byob_request $controller;
      $first_descriptor->{bytes_filled} += $_[1];
  
      return if $first_descriptor->{bytes_filled} < $first_descriptor->{element_size};
  
      ## ReadableByteStreamControllerShiftPendingPullInto
      shift @{$controller->{pending_pull_intos}};
      ReadableByteStreamController::_invalidate_byob_request $controller;
  
      my $remainder_size = $first_descriptor->{bytes_filled} % $first_descriptor->{element_size};
      if ($remainder_size > 0) {
        my $end = $first_descriptor->{byte_offset} + $first_descriptor->{bytes_filled};
        my $remainder = ArrayBuffer->_clone
            ($first_descriptor->{buffer},
             $end - $remainder_size, $remainder_size);
  
        ## ReadableByteStreamControllerEnqueueChunkToQueue
        push @{$controller->{queue}}, {
          buffer => $remainder,
          byte_offset => 0,
          byte_length => $remainder->{byte_length},
        };
        $controller->{queue_total_size} += $remainder->{byte_length};
      }
      $first_descriptor->{buffer} = $first_descriptor->{buffer}->_transfer;
      $first_descriptor->{bytes_filled} -= $remainder_size;
      ReadableByteStreamController::_commit_pull_into_descriptor 
          $stream, $first_descriptor;
      ReadableByteStreamController::_process_pull_into_descriptors_using_queue
          $controller, $stream;
    }
  } # ReadableByteStreamControllerRespondInternal
  
  sub new ($$$) {
    die _type_error "The argument is not a ReadableByteStreamController"
        unless UNIVERSAL::isa ($_[1], 'ReadableByteStreamController');
    my $stream = ${$_[1]};
    my $controller = $stream->{readable_stream_controller};
  
    my $byob_request = {};
    #$byob_request->{associated_readable_byte_stream_controller} = $controller;
    $controller->{byob_request} = $byob_request;
  
    my $self = bless \$stream, $_[0];
    weaken ($controller->{byob_request_obj} = $self);
  
    $byob_request->{view} = $_[2];
    return $self;
  } # new
  
  sub view ($) {
    return ${$_[0]}->{readable_stream_controller}->{byob_request}->{view};
  } # view
  
  sub respond ($$) {
    die _type_error "There is no controller"
        unless defined ${$_[0]}->{state};
        #unless defined $_[0]->{associated_readable_byte_stream_controller};
    die _type_error 'ArrayBuffer is detached'
        if not defined $_[0]->view->buffer->{array_buffer_data}; ## IsDetachedBuffer
  
    ## ReadableByteStreamControllerRespond
    my $bytes_written = _to_size $_[1], 'Byte length';
    ReadableByteStreamController::_respond_internal ${$_[0]}, $bytes_written;
        #$_[0]->{associated_readable_byte_stream_controller}, $bytes_written;
    return undef;
  } # respond(bytesWritten)
  
  sub manakai_respond_zero ($) {
    die _type_error "There is no controller"
        unless defined ${$_[0]}->{state};
        #unless defined $_[0]->{associated_readable_byte_stream_controller};
  
    ## ReadableByteStreamControllerRespond
    ReadableByteStreamController::_respond_internal ${$_[0]}, 0;
        #$_[0]->{associated_readable_byte_stream_controller}, 0;
    return undef;
  } # manakai_respond_zero
  
  ## Not in JS.  Applications should not use this method.
  sub manakai_respond_by_sysread ($$) {
    die _type_error "There is no controller"
        unless defined ${$_[0]}->{state};
        #unless defined $_[0]->{associated_readable_byte_stream_controller};
    my $view = $_[0]->view;
    die _type_error 'ArrayBuffer is detached'
        if not defined $view->buffer->{array_buffer_data}; ## IsDetachedBuffer
  
    $view->buffer->{array_buffer_data} = \(my $x = ''),
        delete $view->buffer->{allocation_delayed}
        unless ref $view->buffer->{array_buffer_data};
    my $bytes_read = sysread $_[1],
        ${$view->buffer->{array_buffer_data}},
        $view->byte_length, $view->byte_offset;
    die _io_error $! unless defined $bytes_read;
    ## Note that sysread can truncate array_buffer_data and
    ## ArrayBuffer's internal status might become inconsitent.
  
    if ($bytes_read) {
      _note_buffer_copy $bytes_read, 'sysread', $view->buffer->debug_info;
  
      ## ReadableByteStreamControllerRespond
      #my $bytes_written = _to_size $bytes_read, 'Byte length';
      ReadableByteStreamController::_respond_internal ${$_[0]}, $bytes_read;
          #$_[0]->{associated_readable_byte_stream_controller}, $bytes_read;
    }
  
    return $bytes_read;
  } # manakai_respond_by_sysread
  
  sub respond_with_new_view ($$) {
    die _type_error "There is no controller"
        unless defined ${$_[0]}->{state};
        #unless defined $_[0]->{associated_readable_byte_stream_controller};
    die _type_error "The argument is not an ArrayBufferView"
        unless UNIVERSAL::isa ($_[1], 'ArrayBufferView'); # has [[ViewedArrayBuffer]]
    die _type_error 'ArrayBuffer is detached'
        if not defined $_[1]->buffer->{array_buffer_data}; ## IsDetachedBuffer
  
    ## ReadableByteStreamControllerRespondWithNewView
    #my $controller = $_[0]->{associated_readable_byte_stream_controller};
    #my $first_descriptor = $controller->{pending_pull_intos}->[0];
    my $first_descriptor = ${$_[0]}->{readable_stream_controller}->{pending_pull_intos}->[0];
    die _range_error "Bad byte offset $_[1]->{byte_offset} != @{[$first_descriptor->{byte_offset} + $first_descriptor->{bytes_filled}]}"
        unless $first_descriptor->{byte_offset} + $first_descriptor->{bytes_filled} == $_[1]->{byte_offset};
    die _range_error "Bad byte length $_[1]->{byte_length} != $first_descriptor->{byte_length}"
        unless $first_descriptor->{byte_length} == $_[1]->{byte_length};
    $first_descriptor->{buffer} = $_[1]->{viewed_array_buffer};
    ReadableByteStreamController::_respond_internal ${$_[0]}, $_[1]->{byte_length};
        #$controller, $_[1]->{byte_length};
    return undef;
  } # respondWithNewView(view)
  
  ## Not in JS.  Applications should not use this method.
  sub manakai_respond_with_new_view ($$) {
    die _type_error "There is no controller"
        unless defined ${$_[0]}->{state};
        #unless defined $_[0]->{associated_readable_byte_stream_controller};
    die _type_error "The argument is not an ArrayBufferView"
        unless UNIVERSAL::isa ($_[1], 'ArrayBufferView'); # has [[ViewedArrayBuffer]]
    die _type_error 'ArrayBuffer is detached'
        if not defined $_[1]->buffer->{array_buffer_data}; ## IsDetachedBuffer
  
    ## A modified version of ReadableByteStreamControllerRespondWithNewView
    #my $controller = $_[0]->{associated_readable_byte_stream_controller};
    #my $first_descriptor = $controller->{pending_pull_intos}->[0];
    my $first_descriptor = ${$_[0]}->{readable_stream_controller}->{pending_pull_intos}->[0];
    die _range_error "Bad byte offset $_[1]->{byte_offset} != @{[$first_descriptor->{byte_offset} + $first_descriptor->{bytes_filled}]}"
        unless $first_descriptor->{byte_offset} + $first_descriptor->{bytes_filled} == $_[1]->{byte_offset};
    die "RangeError: not $first_descriptor->{byte_length} >= $_[1]->{byte_length}"
        unless $first_descriptor->{byte_length} >= $_[1]->{byte_length};
    $first_descriptor->{buffer} = $_[1]->{viewed_array_buffer};
    $first_descriptor->{byte_length} = $_[1]->{byte_length};
    ReadableByteStreamController::_respond_internal ${$_[0]}, $_[1]->{byte_length};
        #$controller, $_[1]->{byte_length};
    return undef;
  } # manakai_respond_with_new_value
  
  sub DESTROY ($) {
    unless (defined ${$_[0]}->{state}) { # not detached
      local $@;
      eval { die };
      if ($@ =~ /during global destruction/) {
        warn "$$: Reference to @{[ref $_[0]]} is not discarded before global destruction\n";
      }
    }
  } # DESTROY
  
  package ReadableStreamDefaultReader;
  use Scalar::Util qw(weaken);
  use Streams::_Common;
  push our @CARP_NOT, qw(ReadableStream);
  
  sub new ($$) {
    my $stream = $_[1];
    die _type_error "The argument is not a ReadableStream"
        unless UNIVERSAL::isa ($stream, 'ReadableStream'); # IsReadableStream
    die _type_error "ReadableStream is locked"
        if defined $stream->{reader}; # IsReadableStreamLocked
    my $reader = {};
    my $self = bless \$stream, $_[0];
  
    ## ReadableStreamReaderGenericInitialize
    #$reader->{owner_readable_stream} = $stream;
    $stream->{reader} = $reader;
    $reader->{closed_promise} = _promise_capability;
    if ($stream->{state} eq 'readable') {
      #
    } elsif ($stream->{state} eq 'closed') {
      $reader->{closed_promise}->{resolve}->(undef);
    } else {
      $reader->{closed_promise}->{reject}->($stream->{stored_error});
      $reader->{closed_promise}->{promise}->manakai_set_handled;
    }
  
    $reader->{read_requests} = [];
    return $self;
  } # new
  
  sub read ($) {
    my $stream = ${$_[0]};
    #my $stream = $_[0]->{owner_readable_stream};
    return Promise->reject (_type_error "Reader's lock is released")
        unless defined $stream->{state};
  
    ## ReadableStreamDefaultReaderRead
    $stream->{disturbed} = 1;
    if ($stream->{state} eq 'closed') {
      return Promise->resolve ({done => 1}); # CreateIterResultObject
    } elsif ($stream->{state} eq 'errored') {
      return Promise->reject ($stream->{stored_error});
    }
    my $controller_obj = $stream->{controller_obj};
    unless (defined $controller_obj) {
      weaken ($stream->{controller_obj} = bless \$stream, $stream->{controller_class});
      $controller_obj = $stream->{controller_obj};
    }
    return $controller_obj->_pull_steps;
  } # read
  
  sub closed ($) {
    my $reader = ${$_[0]}->{reader};
    return $reader->{closed_promise}->{promise};
  } # closed
  
  sub cancel ($$) {
    my $stream = ${$_[0]};
    return Promise->reject (_type_error "Reader's lock is released")
        unless defined $stream->{state}; #$_[0]->{owner_readable_stream};
  
    ## ReadableStreamReaderGenericCancel
    return ReadableStream::_cancel $stream, $_[1];
    #return ReadableStream::_cancel $_[0]->{owner_readable_stream}, $_[1];
  } # cancel
  
  sub release_lock ($) {
    my $reader = ${$_[0]}->{reader};
    return undef unless defined ${$_[0]}->{state}; #$reader->{owner_readable_stream};
    die _type_error "There is a pending read request"
        if @{$reader->{read_requests}};
  
    ## ReadableStreamReaderGenericRelease
    $reader->{closed_promise} ||= _promise_capability;
    #if ($reader->{owner_readable_stream}->{state} eq 'readable') {
    if (${$_[0]}->{state} eq 'readable') {
      $reader->{closed_promise}->{reject}->(_type_error "Reader's lock is released");
    }
    $reader->{closed_promise}->{promise}->manakai_set_handled;
  
    ${$_[0]}->{reader} = undef;
    ${$_[0]} = {reader => $reader};
    #$reader->{owner_readable_stream}->{reader} = undef;
    #$reader->{owner_readable_stream} = undef;
  
    return undef;
  } # releaseLock
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/) {
      warn "$$: Reference to @{[ref $_[0]]} is not discarded before global destruction\n";
    }
  } # DESTROY
  
  package ReadableStreamBYOBReader;
  use Streams::_Common;
  push our @CARP_NOT, qw(ReadableStream ReadableByteStreamController);
  
  sub new ($$) {
    my $stream = $_[1];
    die _type_error "The argument is not a ReadableStream"
        unless UNIVERSAL::isa ($stream, 'ReadableStream'); # IsReadableStream
    die _type_error "ReadableStream is not a byte stream"
        unless defined $stream->{readable_stream_controller}->{underlying_byte_source}; # IsReadableByteStreamController
    die _type_error "ReadableStream is locked"
        if defined $stream->{reader}; # IsReadableStreamLocked
    my $reader = {};
    my $self = bless \$stream, $_[0];
  
    ## ReadableStreamReaderGenericInitialize
    #$reader->{owner_readable_stream} = $stream;
    $stream->{reader} = $reader;
    $reader->{closed_promise} = _promise_capability;
    if ($stream->{state} eq 'readable') {
      #
    } elsif ($stream->{state} eq 'closed') {
      $reader->{closed_promise}->{resolve}->(undef);
    } else {
      $reader->{closed_promise}->{reject}->($stream->{stored_error});
      $reader->{closed_promise}->{promise}->manakai_set_handled;
    }
  
    $reader->{read_into_requests} = [];
    return $self;
  } # new
  
  sub closed ($) {
    my $reader = ${$_[0]}->{reader};
    return $reader->{closed_promise}->{promise};
  } # closed
  
  sub cancel ($$) {
    my $stream = ${$_[0]};
    return Promise->reject (_type_error "Reader's lock is released")
        unless defined $stream->{state}; #$_[0]->{owner_readable_stream};
  
    ## ReadableStreamReaderGenericCancel
    return ReadableStream::_cancel $stream, $_[1];
    #return ReadableStream::_cancel $_[0]->{owner_readable_stream}, $_[1];
  } # cancel
  
  sub read ($$) {
    my $stream = ${$_[0]}; #$_[0]->{owner_readable_stream};
    my $view = $_[1];
    return Promise->reject (_type_error "Reader's lock is released")
        unless defined $stream->{state};
    return Promise->reject (_type_error "The argument is not an ArrayBufferView")
        unless UNIVERSAL::isa ($view, 'ArrayBufferView'); # has [[ViewedArrayBuffer]]
    return Promise->reject (_type_error ('ArrayBuffer is detached'))
        if not defined $view->buffer->{array_buffer_data}; ## IsDetachedBuffer
    return Promise->reject (_type_error "The ArrayBufferView is empty")
        if $view->{byte_length} == 0;
  
    ## ReadableStreamBYOBReaderRead
    {
      $stream->{disturbed} = 1;
      return Promise->reject ($stream->{stored_error})
          if $stream->{state} eq 'errored';
  
      ## ReadableByteStreamControllerPullInto
      my $controller = $stream->{readable_stream_controller};
      #my $stream = $controller->{controlled_readable_stream};
      my $element_size = 1;
      my $ctor = 'DataView';
      if ($view->isa ('TypedArray')) { ## has [[TypedArrayName]]
        $element_size = $view->BYTES_PER_ELEMENT; # Table
        $ctor = ref $view; ## [[TypedArrayName]]
      }
      my $pull_into_descriptor = {
        buffer => $view->{viewed_array_buffer}->_transfer,
        byte_offset => $view->{byte_offset},
        byte_length => $view->{byte_length},
        bytes_filled => 0,
        element_size => $element_size,
        ctor => $ctor,
        reader_type => 'byob',
      };
      if (@{$controller->{pending_pull_intos}}) {
        push @{$controller->{pending_pull_intos}}, $pull_into_descriptor;
  
        ## ReadableStreamAddReadIntoRequest
        my $read_into_request = {promise => _promise_capability};
        push @{$stream->{reader}->{read_into_requests}}, $read_into_request;
        return $read_into_request->{promise}->{promise};
      }
      if ($stream->{state} eq 'closed') {
        my $empty_view = $ctor->new
            ($pull_into_descriptor->{buffer}, $pull_into_descriptor->{byte_offset}, 0);
        return Promise->resolve
            ({value => $empty_view, done => 1}); # CreateIterResultObject
      }
      if ($controller->{queue_total_size} > 0) {
        if (ReadableByteStreamController::_fill_pull_into_descriptor_from_queue
                $controller, $pull_into_descriptor) {
          ## ReadableByteStreamControllerConvertPullIntoDescriptor
          my $filled_view = $pull_into_descriptor->{ctor}->new
              ($pull_into_descriptor->{buffer},
               $pull_into_descriptor->{byte_offset},
               $pull_into_descriptor->{bytes_filled} / $pull_into_descriptor->{element_size});
  
          ## ReadableByteStreamControllerHandleQueueDrain
          if ($controller->{queue_total_size} == 0 and
              $controller->{close_requested}) {
            ReadableStream::_close $stream;
            $stream->_terminate; # Not in JS
          } else {
            ReadableByteStreamController::_call_pull_if_needed $stream;
            #ReadableByteStreamController::_call_pull_if_needed $controller;
          }
  
          return Promise->resolve ({value => $filled_view}); # CreateIterResultObject
        }
        if ($controller->{close_requested}) {
          my $e = _type_error "ReadableStream is closed";
          ReadableByteStreamController::_error $stream, $e;
          #ReadableByteStreamController::_error $controller, $e;
          return Promise->reject ($e);
        }
      }
      push @{$controller->{pending_pull_intos}}, $pull_into_descriptor;
  
      ## ReadableStreamAddReadIntoRequest
      my $read_into_request = {promise => _promise_capability};
      push @{$stream->{reader}->{read_into_requests}}, $read_into_request;
  
      ReadableByteStreamController::_call_pull_if_needed $stream;
      #ReadableByteStreamController::_call_pull_if_needed $controller;
      return $read_into_request->{promise}->{promise};
    }
  } # read
  
  sub release_lock ($) {
    my $reader = ${$_[0]}->{reader};
    return undef unless defined ${$_[0]}->{state}; #$reader->{owner_readable_stream};
    die _type_error "There is a pending read request"
        if @{$reader->{read_into_requests}};
  
    ## ReadableStreamReaderGenericRelease
    $reader->{closed_promise} ||= _promise_capability;
    if (${$_[0]}->{state} eq 'readable') {
    #if ($reader->{owner_readable_stream}->{state} eq 'readable') {
      $reader->{closed_promise}->{reject}->(_type_error "Reader's lock is released");
    }
    $reader->{closed_promise}->{promise}->manakai_set_handled;
  
    ${$_[0]}->{reader} = undef;
    ${$_[0]} = {reader => $reader};
    #$reader->{owner_readable_stream}->{reader} = undef;
    #$reader->{owner_readable_stream} = undef;
  
    return undef;
  } # releaseLock
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/) {
      warn "$$: Reference to @{[ref $_[0]]} is not discarded before global destruction\n";
    }
  } # DESTROY
  
  1;
  
  =head1 LICENSE
  
  Copyright 2017-2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
READABLESTREAM

$fatpacked{"Streams/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STREAMS_ALL';
  package Streams::All;
  use strict;
  use warnings;
  
  use ArrayBuffer;
  use TypedArray;
  use DataView;
  use ReadableStream;
  use WritableStream;
  use Streams::Devel;
  use Streams::Error;
  use Streams::Filehandle;
  use Streams::IOError;
  use Streams::RangeError;
  use Streams::TypeError;
  use Streams::_Common;
  
  1;
  
  ## License: Public Domain.
STREAMS_ALL

$fatpacked{"Streams/Devel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STREAMS_DEVEL';
  package Streams::Devel;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Carp;
  use Streams::_Common;
  
  our @EXPORT;
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    no warnings 'once';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
    push @{$to_class.'::CARP_NOT'}, $from_class;
  } # import
  
  push @EXPORT, qw(note_buffer_copy);
  *note_buffer_copy = \&_note_buffer_copy;
  
  1;
  
  =head1 LICENSE
  
  Copyright 2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
STREAMS_DEVEL

$fatpacked{"Streams/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STREAMS_ERROR';
  package Streams::Error;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '2.0';
  use Carp;
  
  ## This module should not be used directly from applications.
  
  $Web::DOM::Error::L1ObjectClass->{(__PACKAGE__)} = 1;
  
  use overload
      '""' => 'stringify', bool => sub { 1 },
      cmp => sub {
        carp "Use of uninitialized value in string comparison (cmp)"
            unless defined $_[1];
        overload::StrVal ($_[0]) cmp overload::StrVal ($_[1])
      },
      fallback => 1;
  
  sub new ($$) {
    my $self = bless {name => 'Error',
                      message => defined $_[1] ? ''.$_[1] : ''}, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new
  
  sub wrap ($$) {
    return $_[1] if $Web::DOM::Error::L1ObjectClass->{ref $_[1]};
    return $_[0]->new (
      (defined $_[1] && length $_[1]) ? $_[1] : "Something's wrong"
    );
  } # wrap
  
  sub _set_stacktrace ($) {
    my $self = $_[0];
    if (Carp::shortmess =~ /at (.+) line ([0-9]+)\.?$/) {
      $self->{file_name} = $1;
      $self->{line_number} = $2;
    }
  } # _set_stacktrace
  
  sub name ($) { $_[0]->{name} }
  sub file_name ($) { $_[0]->{file_name} }
  sub line_number ($) { $_[0]->{line_number} || 0 }
  sub message ($) { $_[0]->{message} }
  
  sub stringify ($) {
    my $self = $_[0];
    my $name = $self->name;
    my $msg = $self->message;
    if (length $msg) {
      $msg = $name . ': ' . $msg if length $name;
    } else {
      $msg = $name;
    }
    my $fn = $self->file_name;
    return sprintf "%s at %s line %d.\n",
        $msg, defined $fn ? $fn : '(unknown)', $self->line_number || 0;
  } # stringify
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
STREAMS_ERROR

$fatpacked{"Streams/Filehandle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STREAMS_FILEHANDLE';
  package Streams::Filehandle;
  use strict;
  use warnings;
  our $VERSION = '2.0';
  use Errno qw(EAGAIN EWOULDBLOCK EINTR);
  use Socket qw(SOL_SOCKET SO_LINGER);
  use Streams::_Common;
  use AnyEvent;
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  use Promise;
  use Promised::Flow;
  use Streams::Error;
  use Streams::TypeError;
  use DataView;
  use ReadableStream;
  use WritableStream;
  
  ## Semi-public API - Utility functions for building filehandle-based
  ## stream modules.  Used by Web::Transport::TCPStream in
  ## perl-web-resources and Promised::Command in perl-promised-command.
  ## This might be changed into a public API in future, if desired.
  
  push our @CARP_NOT, qw(
    Streams::Error Streams::TypeError
    ArrayBuffer DataView
    ReadableStream ReadableStreamBYOBRequest WritableStream
    Promised::Flow
  );
  
  sub _writing (&$$) {
    my ($code, $fh, $cancel) = @_;
    my $cancelled = 0;
    $$cancel = sub { $cancelled = 1 };
    return promised_until {
      return 'done' if $cancelled or $code->();
      return Promise->new (sub {
        my $ok = $_[0];
        my $w; $w = AE::io $fh, 1, sub {
          undef $w;
          $$cancel = sub { $cancelled = 1 };
          $ok->(not 'done');
        };
        $$cancel = sub {
          $cancelled = 1;
          undef $w;
          $$cancel = sub { };
          $ok->(not 'done');
        };
      });
    };
  } # _writing
  
  sub write_to_fhref ($$;%) {
    my ($fhref, $view, %args) = @_;
    return Promise->resolve->then (sub {
      die Streams::TypeError->new ("The argument is not an ArrayBufferView")
          unless UNIVERSAL::isa ($view, 'ArrayBufferView');
      return if $view->byte_length == 0;
      return _writing {
        return 1 unless defined $$fhref; # end
        my $l = eval { $view->buffer->manakai_syswrite
                           ($$fhref, $view->byte_length, $view->byte_offset) };
        if ($@) {
          my $errno = UNIVERSAL::isa ($@, 'Streams::IOError') ? $@->errno : 0;
          if ($errno != EAGAIN && $errno != EINTR &&
              $errno != EWOULDBLOCK && $errno != WSAEWOULDBLOCK) {
            die $@;
          } else { # retry later
            return 0; # repeat
          }
        } else {
          $view = DataView->new
              ($view->buffer, $view->byte_offset + $l, $view->byte_length - $l);
          return 1 if $view->byte_length == 0; # end
          return 0; # repeat
        }
      } $$fhref, $args{cancel_ref} || \my $dummy;
    });
  } # write_to_fhref
  
  sub fh_to_streams ($$$) {
    my ($fh, $use_r, $use_w) = @_;
  
    my ($r_fh_closed, $s_fh_closed) = promised_cv;
    my $read_active = $use_r ? 1 : 0;
    my $rcancel = sub { };
    my $wc;
    my $wcancel;
  
    my $pull = sub {
      my ($rc, $req, $rcancelref) = @_;
      return Promise->new (sub {
        my $ready = $_[0];
        my $failed = $_[1];
        return $failed->() unless defined $fh;
  
        my $w;
        $$rcancelref = sub {
          eval { $rc->error ($_[0]) } if $read_active;
          my $req = $rc->byob_request;
          $req->manakai_respond_zero if defined $req;
  
          undef $w;
          $failed->($_[0]);
        };
        $w = AE::io $fh, 0, sub {
          $$rcancelref = sub {
            eval { $rc->error ($_[0]) } if $read_active;
            my $req = $rc->byob_request;
            $req->manakai_respond_zero if defined $req;
          };
  
          undef $w;
          $ready->();
        };
      })->then (sub {
        my $bytes_read = eval { $req->manakai_respond_by_sysread ($fh) };
        if ($@) {
          my $error = Streams::Error->wrap ($@);
          my $errno = $error->isa ('Streams::IOError') ? $error->errno : 0;
          if ($errno != EAGAIN && $errno != EINTR &&
              $errno != EWOULDBLOCK && $errno != WSAEWOULDBLOCK) {
            $rcancel->($error) if defined $rcancel;
            $read_active = $rcancel = undef;
            if (defined $wc) {
              $wc->error ($error);
              $wcancel->() if defined $wcancel;
              $wc = $wcancel = undef;
            }
            undef $fh;
            $s_fh_closed->();
            return 0;
          }
          return 1;
        } # $@
        if (defined $bytes_read and $bytes_read <= 0) {
          $rc->close;
          $req->manakai_respond_zero;
          $read_active = undef;
          $rcancel->(undef);
          $rcancel = undef;
          unless (defined $wc) {
            undef $fh;
            $s_fh_closed->();
          }
          return 0;
        }
        return 1;
      }, sub {
        $read_active = $rcancel = undef;
        unless (defined $wc) {
          undef $fh;
          $s_fh_closed->();
        }
        return 0;
      });
    }; # $pull
  
    my $read_stream = $use_r ? ReadableStream->new ({
      type => 'bytes',
      auto_allocate_chunk_size => $Streams::_Common::DefaultBufferSize,
      pull => sub {
        my $rc = $_[1];
        $rcancel = sub {
          eval { $rc->error ($_[0]) } if $read_active;
          my $req = $rc->byob_request;
          $req->manakai_respond_zero if defined $req;
        };
        return promised_until {
          my $req = $rc->byob_request;
          return 'done' unless defined $req;
          return $pull->($rc, $req, \$rcancel)->then (sub {
            return not $_[0];
          });
        };
      }, # pull
      cancel => sub {
        my $reason = defined $_[1] ? $_[1] : "Handle reader canceled";
        $rcancel->($reason) if defined $rcancel;
        $read_active = $rcancel = undef;
        if (defined $wc) {
          $wc->error ($reason);
          $wcancel->() if defined $wcancel;
          $wc = $wcancel = undef;
        }
        shutdown $fh, 2; # can result in EPIPE
        undef $fh;
        $s_fh_closed->();
      }, # cancel
    }) : undef; # $read_stream
    my $write_stream = $use_w ? WritableStream->new ({
      start => sub {
        $wc = $_[1];
      },
      write => sub {
        return Streams::Filehandle::write_to_fhref (\$fh, $_[1], cancel_ref => \$wcancel)->catch (sub {
          my $e = $_[0];
          if (defined $wc) {
            $wc->error ($e);
            $wcancel->() if defined $wcancel;
            $wc = $wcancel = undef;
          }
          if ($read_active) {
            $rcancel->($e);
            $read_active = $rcancel = undef;
          }
          undef $fh;
          $s_fh_closed->();
          die $e;
        });
      }, # write
      close => sub {
        shutdown $fh, 1; # can result in EPIPE
        $wcancel->() if defined $wcancel;
        $wc = $wcancel = undef;
        unless ($read_active) {
          undef $fh;
          $s_fh_closed->();
        }
        return undef;
      }, # close
      abort => sub {
        ## For TCP tests only
        if (UNIVERSAL::isa ($_[1], 'Web::Transport::TCPStream::Reset')) {
          setsockopt $fh, SOL_SOCKET, SO_LINGER, pack "II", 1, 0;
          $wcancel->() if defined $wcancel;
          $wc = $wcancel = undef;
          if ($read_active) {
            $rcancel->($_[1]);
            $read_active = $rcancel = undef;
          }
          undef $fh;
          $s_fh_closed->();
          return undef;
        }
  
        $wcancel->() if defined $wcancel;
        $wc = $wcancel = undef;
        if ($read_active) {
          my $reason = defined $_[1] ? $_[1] : "Handle writer aborted";
          $rcancel->($reason);
          $read_active = $rcancel = undef;
        }
        shutdown $fh, 2; # can result in EPIPE
        undef $fh;
        $s_fh_closed->();
      }, # abort
    }) : undef; # $write_stream
  
    AnyEvent::Util::fh_nonblocking $fh, 1;
  
    return ($read_stream, $write_stream, $r_fh_closed);
  } # fh_to_streams
  
  sub create_readable ($$) {
    my ($rs, undef, undef) = Streams::Filehandle::fh_to_streams $_[1], 1, 0;
    return $rs;
  } # create_readable
  
  sub create_writable ($$) {
    my (undef, $ws, undef) = Streams::Filehandle::fh_to_streams $_[1], 0, 1;
    return $ws;
  } # create_writable
  
  1;
  
  =head1 LICENSE
  
  Copyright 2016-2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
STREAMS_FILEHANDLE

$fatpacked{"Streams/IOError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STREAMS_IOERROR';
  package Streams::IOError;
  use strict;
  use warnings;
  use Streams::Error;
  push our @ISA, qw(Streams::Error);
  our $VERSION = '2.0';
  
  $Web::DOM::Error::L1ObjectClass->{(__PACKAGE__)} = 1;
  
  sub new ($$) {
    my $self = bless {
      name => 'Perl I/O error',
      error => 0+$_[1],
      message => ''.$_[1],
    }, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new
  
  sub new_from_errno_and_message ($$$) {
    my $self = bless {
      name => 'Perl I/O error',
      error => 0+$_[1],
      message => ''.$_[2],
    }, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new_from_errno_and_message
  
  sub errno ($) {
    return $_[0]->{error};
  } # errno
  
  1;
  
  =head1 LICENSE
  
  Copyright 2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
STREAMS_IOERROR

$fatpacked{"Streams/RangeError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STREAMS_RANGEERROR';
  package Streams::RangeError;
  use strict;
  use warnings;
  use Streams::Error;
  push our @ISA, qw(Streams::Error);
  our $VERSION = '2.0';
  
  $Web::DOM::Error::L1ObjectClass->{(__PACKAGE__)} = 1;
  
  sub new ($$) {
    my $self = bless {name => 'RangeError',
                      message => defined $_[1] ? ''.$_[1] : ''}, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
STREAMS_RANGEERROR

$fatpacked{"Streams/TypeError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STREAMS_TYPEERROR';
  package Streams::TypeError;
  use strict;
  use warnings;
  use Streams::Error;
  push our @ISA, qw(Streams::Error);
  our $VERSION = '2.0';
  
  $Web::DOM::Error::L1ObjectClass->{(__PACKAGE__)} = 1;
  
  sub new ($$) {
    my $self = bless {name => 'TypeError',
                      message => defined $_[1] ? ''.$_[1] : ''}, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
STREAMS_TYPEERROR

$fatpacked{"Streams/_Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STREAMS__COMMON';
  package Streams::_Common;
  use strict;
  use warnings;
  use Carp;
  use Streams::TypeError;
  use Streams::RangeError;
  use Streams::IOError;
  push our @CARP_NOT, qw(
    Streams::TypeError Streams::RangeError Streams::IOError Promise
  );
  
  our @EXPORT;
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    no warnings 'once';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
    push @{$to_class.'::CARP_NOT'}, $from_class;
  } # import
  
  our $DefaultBufferSize ||= 512*1024;
  
  sub _type_error ($) { Streams::TypeError->new ($_[0]) }
  sub _range_error ($) { Streams::RangeError->new ($_[0]) }
  sub _io_error ($) { Streams::IOError->new ($_[0]) }
  push @EXPORT, qw(_type_error _range_error _io_error);
  
  ## c.f. <http://search.cpan.org/~rjbs/perl-5.20.0/pod/perldelta.pod#Better_64-bit_support>
  my $MaxIndex = defined [0]->[2**32] ? 2**53-1 : 2**32-1;
  
  ## ToIndex for Perl
  sub _to_index ($$) {
    my $index = int $_[0];
    die _range_error "$_[1] $index is negative" if $index < 0;
    die _range_error "$_[1] $index is too large" if $index > $MaxIndex;
    return 0 if $index eq 'nan' or $index eq 'NaN';
    return $index;
  } # to_index
  push @EXPORT, qw(_to_index);
  
  sub _to_size ($$) {
    ## ToNumber
    my $size = 0+$_[0];
  
    ## IsFiniteNonNegativeNumber
    die _range_error "$_[1] $size is negative" if $size < 0;
    die _range_error "$_[1] $size is too large" if $size eq 'Inf' or $size eq 'inf';
  
    ## This is different from JS's IsFiniteNonNegativeNumber, to match
    ## with Perl's convention.
    return 0 if $size eq 'NaN' or $size eq 'nan';
  
    return $size;
  } # _to_size
  push @EXPORT, qw(_to_size);
  
  # requires Promise
  sub _promise_capability () {
    my ($resolve, $reject);
    my $promise = Promise->new (sub { ($resolve, $reject) = @_ });
    return {promise => $promise, resolve => $resolve, reject => $reject};
  } # _promise_capability
  push @EXPORT, qw(_promise_capability);
  
  # requires Promise
  sub _hashref_method_throws ($$$) {
    ## InvokeOrNoop whose non-abrupt result is wrapped with a Promise
    my $code = $_[0]->{$_[1]};
    return Promise->resolve (undef) unless defined $code;
    die _type_error "The |$_[1]| member is not a CODE" unless ref $code eq 'CODE';
    my $result = $code->($_[0], @{$_[2]}); # or throws
    return Promise->resolve ($result);
  } # _hashref_method_throws
  push @EXPORT, qw(_hashref_method_throws);
  
  # requires Promise
  sub _hashref_method ($$$) {
    ## PromiseInvokeOrNoop
    my $code = $_[0]->{$_[1]};
    return Promise->resolve (undef) unless defined $code;
    return Promise->reject (_type_error "The |$_[1]| member is not a CODE")
        unless ref $code eq 'CODE';
    my $args = [$_[0], @{$_[2]}];
    return Promise->new (sub { $_[0]->(scalar $code->(@$args)) });
  } # _hashref_method
  push @EXPORT, qw(_hashref_method);
  
  if ($ENV{STREAMS_DEBUG}) {
    eval q{
      sub _note_buffer_copy ($$$) {
        warn sprintf "Buffer copy l=%d from %s to %s\n",
            $_[0], $_[1], $_[2];
      } # _note_buffer_copy
      1;
     } or die $@;
  } else {
    eval q{ sub _note_buffer_copy ($$$) { } 1 } or die $@;
  }
  push @EXPORT, qw(_note_buffer_copy);
  
  package ArrayBufferView;
  
  1;
  
  =head1 LICENSE
  
  Copyright 2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
STREAMS__COMMON

$fatpacked{"TypedArray.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPEDARRAY';
  package TypedArray;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  push our @ISA, qw(ArrayBufferView);
  use Streams::_Common;
  use ArrayBuffer;
  
  ## TypedArray ()
  ## TypedArray (length)
  ## TypedArray (typedArray) - not supported
  ## TypedArray (object) - not supported
  ## TypedArray (buffer)
  ## TypedArray (buffer, byteOffset)
  ## TypedArray (buffer, byteOffset, length)
  sub new ($;$$$) {
    die _type_error __PACKAGE__ . " is an abstract class"
        if $_[0] eq __PACKAGE__;
    my $self = bless {}, $_[0];
  
    my $length;
    if (not defined $_[1]) {
      $length = 0;
    } elsif (ref $_[1]) {
      if (UNIVERSAL::isa ($_[1], 'ArrayBuffer')) { ## has [[ArrayBufferData]]
        #
      } else {
        die _range_error 'The argument is not an ArrayBuffer or length';
      }
    } else {
      $length = _to_index $_[1], 'Length';
    }
  
    if (defined $length) {
      ## AllocateTypedArray
      {
        #$self->{viewed_array_buffer} = undef;
        #$self->{typed_array_name} = ref $self;
  
        ## AllocateTypedArrayBuffer
        {
          my $element_size = $self->BYTES_PER_ELEMENT; ## Table->{ref $_[0]}
          my $byte_length = $element_size * $length;
          local $ArrayBuffer::CallerLevel = $ArrayBuffer::CallerLevel + 1;
          $self->{viewed_array_buffer}
              = ArrayBuffer->new ($byte_length); ## AllocateArrayBuffer
          $self->{byte_length} = $byte_length;
          $self->{byte_offset} = 0;
          $self->{array_length} = $length;
        }
      }
    } else { # $_[1] is an array buffer
      ## AllocateTypedArray
      #$self->{viewed_array_buffer} = undef;
      #$self->{typed_array_name} = ref $self;
      #$self->{byte_length} = 0;
      #$self->{byte_offset} = 0;
      #$self->{array_length} = 0;
  
      my $element_size = $self->BYTES_PER_ELEMENT; ## Table->{ref $_[0]}
  
      my $offset = _to_index $_[2] || 0, 'Offset';
      die _range_error "Offset $offset % element size $element_size != 0"
          unless ($offset % $element_size) == 0;
      die _type_error "ArrayBuffer is detached"
          if not defined $_[1]->{array_buffer_data}; ## IsDetachedBuffer
      my $buffer_byte_length = $_[1]->{array_buffer_byte_length};
      my $new_byte_length;
      if (not defined $_[3]) {
        die _range_error
            "Buffer length $buffer_byte_length % element size $element_size != 0"
                unless ($buffer_byte_length % $element_size) == 0;
        $new_byte_length = $buffer_byte_length - $offset;
        die _range_error "Buffer length $buffer_byte_length < offset $offset"
            if $new_byte_length < 0;
      } else { # $length specified
        my $new_length = _to_index $_[3], 'Array length';
        $new_byte_length = $new_length * $element_size;
        die _range_error
            "Buffer length $buffer_byte_length < offset $offset + array length $new_length * element size $element_size"
                if $offset + $new_byte_length > $buffer_byte_length;
      }
      $self->{viewed_array_buffer} = $_[1];
      $self->{byte_length} = $new_byte_length;
      $self->{byte_offset} = $offset;
      $self->{array_length} = $new_byte_length / $element_size; # integer
    }
    return $self;
  } # new
  
  sub buffer ($) {
    return $_[0]->{viewed_array_buffer};
  } # buffer
  
  sub byte_length ($) {
    return 0 if not defined $_[0]->{viewed_array_buffer}
        ->{array_buffer_data}; ## IsDetachedBuffer
    return $_[0]->{byte_length};
  } # byte_length
  
  sub byte_offset ($) {
    return 0 if not defined $_[0]->{viewed_array_buffer}
        ->{array_buffer_data}; ## IsDetachedBuffer
    return $_[0]->{byte_offset};
  } # byte_offset
  
  sub length ($) {
    return 0 if not defined $_[0]->{viewed_array_buffer}
        ->{array_buffer_data}; ## IsDetachedBuffer
    return $_[0]->{array_length};
  } # length
  
  ## XXX Not implemented:
  ## $subclass->from
  ## $subclass->of
  ## $object->copy_within
  ## $object->entries
  ## $object->every
  ##          fill filter find find_index for_each includes index_of
  ##          join keys last_index_of map reduce reduce_right
  ##          reverse set slice some sort subarray values
  ## $object->[$n] getter / setter
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/) {
      warn "$$: Reference to @{[ref $_[0]]}@{[
        (not defined $_[0]->{viewed_array_buffer}->{array_buffer_data})
            ? ' (detached)' : ''
      ]} is not discarded before global destruction\n";
    }
  } # DESTROY
  
  package TypedArray::Uint8Array;
  push our @ISA, qw(TypedArray);
  use Streams::_Common;
  
  ## Not in JS
  sub new_by_sysread ($$) {
    my ($class, $fh, $byte_length) = @_;
    my $buffer = '';
    my $bytes_read = sysread $fh, $buffer, (_to_index $byte_length, 'Byte length'), 0;
    die _io_error $! unless defined $bytes_read;
    local $ArrayBuffer::CallerLevel = $ArrayBuffer::CallerLevel + 1;
    return $class->new
        (ArrayBuffer->new_from_scalarref (\$buffer), 0, $bytes_read);
  } # new_by_sysread
  
  ## Table->{$_[0]}
  sub BYTES_PER_ELEMENT () { 1 }
  
  # XXX Not implemented: other subclasses
  
  1;
  
  =head1 LICENSE
  
  Copyright 2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
TYPEDARRAY

$fatpacked{"Web/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_ENCODING';
  package Web::Encoding;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '8.0';
  use Carp;
  use Web::Encoding::_Defs;
  use Web::Encoding::Decoder;
  
  our @EXPORT = qw(
    encode_web_utf8
    decode_web_utf8
    decode_web_utf8_no_bom
    encode_web_charset
    decode_web_charset
    is_ascii_compat_charset_name
    encoding_names
  );
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
  } # import
  
  sub encode_web_utf8 ($) {
    if (not defined $_[0]) {
      carp "Use of uninitialized value in subroutine entry";
      return '';
    } else {
      my $x = $_[0];
      if (utf8::is_utf8 $x) {
        $x =~ s/[^\x00-\x{D7FF}\x{E000}-\x{10FFFF}]/\x{FFFD}/g;
      } else {
        utf8::upgrade $x;
      }
      utf8::encode $x;
      return $x;
    }
  } # encode_web_utf8
  
  sub _decode8 ($$$;$$) {
    # $states, $x, $final, $index_offset, $onerror
    my $x = defined $_[0]->{lead} ? (delete $_[0]->{lead}) . $_[1] : $_[1]; # string copy!
    my $pos_offset = 0;
    pos ($x) = 0;
    my $xlength = length $x;
    while (pos ($x) < $xlength) {
      if ($x =~ /\G[\x00-\x7F]+/gc) {
        #
      } elsif ($x =~ m{\G(?:[\xC2-\xDF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:\xE0[\xA0-\xBF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:[\xE1-\xEC\xEE\xEF][\x80-\xBF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:\xED[\x80-\x9F][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:\xF0[\x90-\xBF][\x80-\xBF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:\xF4[\x80-\x8F][\x80-\xBF][\x80-\xBF])+}gc) {
        #
      } else {
        my $pos = pos $x;
        if ($x =~ m{\G
     ((?:[\xC2-\xDF]                                      |
         \xE0               [\xA0-\xBF]?                  |
         [\xE1-\xEC\xEE\xEF][\x80-\xBF]?                  |
         \xED               [\x80-\x9F]?                  |
         \xF0               (?:[\x90-\xBF][\x80-\xBF]?|)  |
         [\xF1-\xF3]        (?:[\x80-\xBF][\x80-\xBF]?|)  |
         \xF4               (?:[\x80-\x8F][\x80-\xBF]?|))(\z)?)
      }gcx) {
            if ($_[2] or not defined $2) { # final or not at eof
              my $length = length $1;
              $_[4]->(type => 'utf-8:bad bytes', level => 'm', fatal => 1,
                      index => $_[3] + $pos - $pos_offset, value => $1) if $_[4];
              substr ($x, $pos, $length) = qq{\xEF\xBF\xBD}; # U+FFFD
              pos ($x) = $pos + 3;
              $pos_offset += 3 - $length;
              $xlength += 3 - $length;
            } else { # at end of chunk
              $_[0]->{lead} .= $1;
              substr ($x, $pos) = '';
              pos ($x) = $pos;
              #$pos_offset -= length $1;
              $xlength = $pos;
            }
          } else {
            my $value = substr $x, $pos, 1;
            substr ($x, $pos, 1) = qq{\xEF\xBF\xBD}; # U+FFFD
            $_[4]->(type => 'utf-8:bad bytes', level => 'm', fatal => 1,
                    index => $_[3] + $pos - $pos_offset, value => $value) if $_[4];
            pos ($x) = $pos + 3;
            $pos_offset += 2;
            $xlength += 2;
          }
      }
    } # while
    utf8::decode ($x);
    return $x;
  } # _decode8
  
  sub decode_web_utf8 ($) {
    if (not defined $_[0]) {
      carp "Use of uninitialized value in subroutine entry";
      return '';
    } elsif (utf8::is_utf8 $_[0]) {
      croak "Cannot decode string with wide characters";
    } else {
      return _decode8
          ({},
           substr ($_[0], 0, 3) eq "\xEF\xBB\xBF" ? substr $_[0], 3 : $_[0],
           1);
    }
  } # decode_web_utf8
  
  sub decode_web_utf8_no_bom ($) {
    if (not defined $_[0]) {
      carp "Use of uninitialized value an argument";
      return '';
    } elsif (utf8::is_utf8 $_[0]) {
      croak "Cannot decode string with wide characters";
    } else {
      return _decode8 {}, $_[0], 1;
    }
  } # decode_web_utf8_no_bom
  
  sub _encode_16 ($$) {
    if (not defined $_[0]) {
      carp "Use of uninitialized value an argument";
      return '';
    }
    my @s;
    for (split //, $_[0]) {
      my $c = ord $_;
      if ($c <= 0xFFFF) {
        push @s, pack $_[1], $c;
      } elsif ($c <= 0x10FFFF) {
        $c -= 0x10000;
        push @s, pack $_[1].$_[1], ($c >> 10) + 0xD800, ($c & 0x3FF) + 0xDC00;
      } else {
        push @s, $_[1] eq 'n' ? "\xFF\xFD" : "\xFD\xFF";
      }
    }
    return join '', @s;
  } # _encode_16
  
  sub _encode_mb ($$$$$) {
    my @s;
    pos ($_[0]) = 0;
    while ($_[0] =~ m{\G(?:([\x00-\x7F]+)|(.))}gs) {
      if (defined $1) {
        push @s, $1;
        utf8::downgrade $s[-1];
      } else {
        my $c = ord $2;
        if ($c > 0xFFFF) {
          my $v = $_[2]->{$c};
          if (defined $v) {
            push @s, $v;
            next;
          } else {
            #
          }
        } else {
          my $v = substr $_[1], $c * 2, 2;
          if ($v eq "\x00\x00") {
            #
          } elsif (substr ($v, 0, 1) eq "\x00") {
            push @s, substr $v, 1, 1;
            next;
          } else {
            push @s, $v;
            next;
          }
        }
  
        if ($c == 0x20AC) {
          push @s, $_[4] == 2 ? "\xA2\xE3" : "\x80";
          next;
        }
  
        if (@{$_[3]}) {
          ## <https://encoding.spec.whatwg.org/#index-gb18030-ranges-pointer>
  
          my $pointer;
          if ($c == 0xE5E5) {
            #
          } elsif ($c == 0xE7C7) {
            $pointer = 7457;
          } else {
            for (@{$_[3]}) {
              if ($_->[1] <= $c) {
                $pointer = $_->[0] + $c - $_->[1];
              }
            }
          }
  
          if (defined $pointer) {
            my $byte1 = int ($pointer / (10 * 126 * 10));
            $pointer = $pointer % (10 * 126 * 10);
            my $byte2 = int ($pointer / (10 * 126));
            $pointer = $pointer % (10 * 126);
            my $byte3 = int ($pointer / 10);
            my $byte4 = $pointer % 10;
            push @s, pack 'CCCC',
                $byte1 + 0x81, $byte2 + 0x30, $byte3 + 0x81, $byte4 + 0x30;
            next;
          }
        }
  
        push @s, sprintf '&#%d;', $c;
      }
    } # while
    return join '', @s;
  } # _encode_mb
  
  sub _encode_iso2022jp ($$$) {
    # $states $s $final
  
    my @s;
  
    for (split //, $_[1]) {
      my $c = ord $_;
      
      if ($c == 0x000E or $c == 0x000F or $c == 0x1B) {
        if (defined $_[0]->{state} and not $_[0]->{state} eq 'J') {
          delete $_[0]->{state};
          push @s, "\x1B\x28\x42";
        }
        push @s, '&#65533;'; # U+FFFD
      } elsif ($c == 0x5C or $c == 0x7E) {
        if (defined $_[0]->{state}) {
          delete $_[0]->{state};
          push @s, "\x1B\x28\x42";
        }
        push @s, pack 'C', $c;
      } elsif ($c <= 0x7F) {
        if (defined $_[0]->{state} and not $_[0]->{state} eq 'J') {
          delete $_[0]->{state};
          push @s, "\x1B\x28\x42";
        }
        push @s, pack 'C', $c;
      } elsif ($c == 0xA5) {
        if (not defined $_[0]->{state} or not $_[0]->{state} eq 'J') {
          $_[0]->{state} = 'J';
          push @s, "\x1B\x28\x4A";
        }
        push @s, "\x5C";
      } elsif ($c == 0x203E) {
        if (not defined $_[0]->{state} or not $_[0]->{state} eq 'J') {
          $_[0]->{state} = 'J';
          push @s, "\x1B\x28\x4A";
        }
        push @s, "\x7E";
      } elsif ($c > 0xFFFF) {
        if (defined $_[0]->{state} and not $_[0]->{state} eq 'J') {
          delete $_[0]->{state};
          push @s, "\x1B\x28\x42";
        }
        push @s, sprintf '&#%d;', $c;
      } else {
        if (0xFF61 <= $c and $c <= 0xFF9F) {
          $c = $Web::Encoding::_JIS::KatakanaHF->[$c - 0xFF61];
        }
  
        my $v = substr $Web::Encoding::_JIS::EncodeBMPEUC, $c * 2, 2;
        if ($v =~ /^[\xA1-\xFE]/) {
          if (not defined $_[0]->{state} or not $_[0]->{state} eq 'B') {
            $_[0]->{state} = 'B';
            push @s, "\x1B\x24\x42";
          }
          $v =~ tr/\x80-\xFF/\x00-\x7F/;
          push @s, $v;
        } else {
          if (defined $_[0]->{state} and not $_[0]->{state} eq 'J') {
            delete $_[0]->{state};
            push @s, "\x1B\x28\x42";
          }
          push @s, sprintf '&#%d;', $c;
        }
      }
    }
  
    if ($_[2]) {
      if (defined $_[0]->{state}) {
        delete $_[0]->{state};
        push @s, "\x1B\x28\x42";
      }
    }
  
    return join '', @s;
  } # _encode_iso2022jp
  
  sub _is_single ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0]} || {})->{single_byte});
  } # _is_single
  
  sub encode_web_charset ($$) {
    if ($_[0] eq 'utf-8') {
      return encode_web_utf8 $_[1];
    } elsif (_is_single $_[0]) {
      if (not defined $_[1]) {
        carp "Use of uninitialized value an argument";
        return '';
      }
      require Web::Encoding::_Single;
      my $s = $_[1]; # string copy!
      my $Map = $Web::Encoding::_Single::Encoder->{$_[0]};
      $s =~ s{([^\x00-\x7F])}{
        defined $Map->{$1} ? $Map->{$1} : sprintf '&#%d;', ord $1;
      }ge;
      utf8::downgrade $s if utf8::is_utf8 $s;
      return $s;
    } elsif ($_[0] eq 'utf-16be') {
      return _encode_16 $_[1], 'n';
    } elsif ($_[0] eq 'utf-16le') {
      return _encode_16 $_[1], 'v';
    } elsif ($_[0] eq 'gb18030') {
      require Web::Encoding::_GB;
      return _encode_mb $_[1], $Web::Encoding::_GB::EncodeBMP, {},
          $Web::Encoding::_GB::Ranges, 2;
    } elsif ($_[0] eq 'gbk') {
      require Web::Encoding::_GB;
      return _encode_mb $_[1], $Web::Encoding::_GB::EncodeBMP, {}, [], 1;
    } elsif ($_[0] eq 'big5') {
      require Web::Encoding::_Big5;
      return _encode_mb $_[1],
          $Web::Encoding::_Big5::EncodeBMP,
          $Web::Encoding::_Big5::EncodeNonBMP, [], 0;
    } elsif ($_[0] eq 'shift_jis') {
      require Web::Encoding::_JIS;
      return _encode_mb $_[1], $Web::Encoding::_JIS::EncodeBMPSJIS, {}, [], 0;
    } elsif ($_[0] eq 'euc-jp') {
      require Web::Encoding::_JIS;
      return _encode_mb $_[1], $Web::Encoding::_JIS::EncodeBMPEUC, {}, [], 0;
    } elsif ($_[0] eq 'euc-kr') {
      require Web::Encoding::_EUCKR;
      return _encode_mb $_[1], $Web::Encoding::_EUCKR::EncodeBMP, {}, [], 0;
    } elsif ($_[0] eq 'iso-2022-jp') {
      require Web::Encoding::_JIS;
      return _encode_iso2022jp {}, $_[1], 1;
    } elsif ($_[0] eq 'replacement') {
      croak "The replacement encoding has no encoder";
    } else {
      croak "Bad encoding key |$_[0]|";
    }
  } # encode_web_charset
  
  sub decode_web_charset ($$) {
    if ($_[0] eq 'utf-8') { # shortcut
      return decode_web_utf8 $_[1];
    } else {
      require Web::Encoding::Decoder;
      my $decoder = Web::Encoding::Decoder->new_from_encoding_key ($_[0]);
      $decoder->ignore_bom (1);
      return join '', @{$decoder->bytes ($_[1])}, @{$decoder->eof};
    }
  } # decode_web_charset
  
  push @EXPORT, qw(encoding_label_to_name);
  sub encoding_label_to_name ($) {
    ## Get an encoding
    ## <https://encoding.spec.whatwg.org/#concept-encoding-get>.
    my $label = $_[0] || '';
    $label =~ s/\A[\x09\x0A\x0C\x0D\x20]+//; ## ASCII whitespace
    $label =~ s/[\x09\x0A\x0C\x0D\x20]+\z//; ## ASCII whitespace
    $label =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
    ## Returns the encoding key.
    return $Web::Encoding::_Defs->{supported_labels}->{$label}; # or undef
  } # encoding_label_to_name
  
  push @EXPORT, qw(is_encoding_label);
  sub is_encoding_label ($) {
    my $label = $_[0] || '';
    $label =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
    return !!$Web::Encoding::_Defs->{supported_labels}->{$label};
  } # is_encoding_label
  
  push @EXPORT, qw(encoding_name_to_compat_name);
  sub encoding_name_to_compat_name ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{compat_name});
  } # encoding_name_to_compat_name
  
  push @EXPORT, qw(is_utf16_encoding_key);
  sub is_utf16_encoding_key ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{utf16});
  } # is_utf16_encoding_key
  
  push @EXPORT, qw(is_ascii_compat_encoding_name);
  sub is_ascii_compat_encoding_name ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{ascii_compat});
  } # is_ascii_compat_encoding_name
  
  push @EXPORT, qw(get_output_encoding_key);
  sub get_output_encoding_key ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{output}); # or undef
  } # get_output_encoding_key
  
  push @EXPORT, qw(fixup_html_meta_encoding_name);
  sub fixup_html_meta_encoding_name ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{html_decl_mapped}); # or undef
  } # fixup_html_meta_encoding_name
  
  # XXX can this deleted?
  sub is_ascii_compat_charset_name ($) {
    my $name = $_[0] or return 0;
    if ($name =~ m{^
      utf-8|
      iso-8859-[0-9]+|
      us-ascii|
      shift_jis|
      euc-jp|
      windows-[0-9]+|
      iso-2022-[0-9a-zA-Z-]+|
      hz-gb-2312
    $}xi) {
      return 1;
    } else {
      return 0;
    }
  } # is_ascii_compat_charset_name
  
  push @EXPORT, qw(locale_default_encoding_name);
  sub locale_default_encoding_name ($) {
    my $locale = $_[0] or return undef;
    $locale =~ tr/A-Z/a-z/;
    return $Web::Encoding::_Defs->{locale_default}->{$locale}; # or undef
  } # locale_default_encoding_name
  
  sub encoding_names () {
    return $Web::Encoding::_Defs->{names};
  } # encoding_names
  
  1;
  
  =head1 LICENSE
  
  Copyright 2011-2020 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_ENCODING

$fatpacked{"Web/Encoding/Decoder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_ENCODING_DECODER';
  package Web::Encoding::Decoder;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Carp;
  use Web::Encoding;
  
  push our @CARP_NOT, qw(Web::Encoding);
  
  sub new_from_encoding_key ($$) {
    return bless {
      key => $_[1],
      states => {},
    }, $_[0];
  } # new_from_encoding_key
  
  sub ignore_bom ($;$) {
    if (@_ > 1) {
      $_[0]->{ignore_bom} = $_[1];
    }
    return $_[0]->{ignore_bom};
  } # ignore_bom
  
  sub fatal ($;$) {
    if (@_ > 1) {
      $_[0]->{fatal} = 1;
    }
    return $_[0]->{fatal};
  } # fatal
  
  sub onerror ($;$) {
    if (@_ > 1) {
      $_[0]->{onerror} = $_[1];
    }
    return $_[0]->{onerror} || sub { };
  } # onerror
  
  sub _onerror ($) {
    my $onerror = $_[0]->{onerror};
    return $_[0]->{fatal} ? sub {
      my %args = @_;
      my $fatal = delete $args{fatal};
      $onerror->(%args);
      die "Input has invalid bytes" if $fatal;
    } : $onerror || sub { };
  } # _onerror
  
  sub used_encoding_key ($) {
    return $_[0]->{key};
  } # used_encoding_key
  
  sub _u16 ($$$$$) {
    #$states, $u, \@s, $onerror, $index;
    if ($_[1] < 0xD800 or 0xDFFF < $_[1]) {
      if (defined $_[0]->{lead_surrogate}) {
        $_[3]->(type => 'utf-16:lone high surrogate', level => 'm', fatal => 1,
                index => $_[0]->{index} + $_[4] - 2,
                text => sprintf '0x%04X', $_[0]->{lead_surrogate});
        push @{$_[2]}, "\x{FFFD}";
        delete $_[0]->{lead_surrogate};
      }
      push @{$_[2]}, chr $_[1];
    } elsif ($_[1] <= 0xDBFF) { # [U+D800, U+DBFF]
      if (defined $_[0]->{lead_surrogate}) {
        $_[3]->(type => 'utf-16:lone high surrogate', level => 'm', fatal => 1,
                index => $_[0]->{index} + $_[4] - 2,
                text => sprintf '0x%04X', $_[0]->{lead_surrogate});
        push @{$_[2]}, "\x{FFFD}";
        delete $_[0]->{lead_surrogate};
      }
      $_[0]->{lead_surrogate} = $_[1];
    } else { # [U+DC00, U+DFFF]
      if (defined $_[0]->{lead_surrogate}) {
        push @{$_[2]}, chr (0x10000
                            + ((delete ($_[0]->{lead_surrogate}) - 0xD800) << 10)
                            + $_[1] - 0xDC00);
      } else {
        $_[3]->(type => 'utf-16:lone low surrogate', level => 'm', fatal => 1,
                index => $_[0]->{index} + $_[4],
                text => sprintf '0x%04X', $_[1]);
        push @{$_[2]}, "\x{FFFD}";
      }
    }
  } # _u16
  
  sub _decode_16 ($$$$$) {
    my $states = $_[0];
    #my $onerror = $_[1];
    #my $is_last = $_[3];
    #my $endian = $_[4]
    my $offset = 0;
    my @s;
    my $len = length $_[2];
    if (defined $states->{lead_byte}) {
      if ($len) {
        my $lead = unpack 'C', delete $states->{lead_byte};
        my $sec = unpack 'C', substr $_[2], 0, 1;
        if ($_[4] eq 'n') {
          _u16 $states, $lead * 0x100 + $sec, \@s, $_[1], -1;
        } else {
          _u16 $states, $sec * 0x100 + $lead, \@s, $_[1], -1;
        }
        $offset++;
      } else { # empty
        if ($_[3]) { # $is_last
          $_[1]->(type => 'utf-16:lone byte', level => 'm', fatal => 1,
                  index => $states->{index} - 1, value => $states->{lead_byte});
          push @s, "\x{FFFD}";
          delete $states->{lead_surrogate};
        }
      }
    }
    my $Length = ($len - $offset) / 2;
    my $length = int $Length;
    my $i = 0;
    while ($i < $length) {
      _u16 $states, (unpack $_[4], substr $_[2], $offset + $i * 2, 2), \@s, $_[1], $offset + $i * 2;
      $i++;
    }
    if (defined $states->{lead_surrogate} and $_[3]) { # $is_last
      $_[1]->(type => 'utf-16:lone high surrogate', level => 'm', fatal => 1,
              index => $states->{index} + $len - 2,
              text => sprintf '0x%04X', $_[0]->{lead_surrogate});
      push @s, "\x{FFFD}";
    } elsif ($length != $Length) {
      if ($_[3]) { # $is_last
        $_[1]->(type => 'utf-16:lone byte', level => 'm', fatal => 1,
                index => $states->{index} + $len - 1,
                value => substr $_[2], -1);
        push @s, "\x{FFFD}";
      } else {
        $states->{lead_byte} = substr $_[2], -1;
      }
    }
  
    $states->{index} += $len;
  
    ## @s can't contain an empty string for the convenience of later BOM
    ## stripping.
    return \@s;
  } # _decode_16
  
  sub _gb ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    if ($_[1] < 0x40 or $_[1] == 0x7F or $_[1] == 0xFF) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CC', $_[0], $_[1]);
      push @{$_[2]}, chr $_[1] if $_[1] < 0x80;
    } else {
      my $pointer = ($_[0] - 0x81) * 190 + $_[1] - ($_[1] < 0x7F ? 0x40 : 0x41);
      my $c = $Web::Encoding::_GB::DecodeIndex->[$pointer];
      if (defined $c) {
        if ($pointer == (0xA3 - 0x81) * 190 + 0xA0 - 0x41) {
          $_[4]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
        push @{$_[2]}, $c;
      } else {
        if ($_[1] < 0x80) {
          push @{$_[2]}, "\x{FFFD}", chr $_[1];
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } else {
          push @{$_[2]}, "\x{FFFD}";
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
      }
    }
  } # _gb
  
  sub _gb4 ($$$$$$) {
    # $b1b2 $b3 $b4 $out $index_offset $onerror
    my $pointer = ($_[0]->[0] - 0x81) * (10 * 126 * 10)
        + ($_[0]->[1] - 0x30) * (10 * 126)
        + ($_[1] - 0x81) * 10
        + $_[2] - 0x30;
  
    if (($pointer > 39419 and $pointer < 189000) or $pointer > 1237575) {
      push @{$_[3]}, "\x{FFFD}";
      $_[5]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[4],
              value => pack 'CCCC', $_[0]->[0], $_[0]->[1], $_[1], $_[2]);
      return undef;
    }
  
    if ($pointer == 7457) {
      push @{$_[3]}, "\x{E7C7}";
      return undef;
    }
  
    my $offset;
    my $cp;
    for (@{$Web::Encoding::_GB::Ranges}) {
      if ($_->[0] <= $pointer) {
        $offset = $_->[0];
        $cp = $_->[1];
      }
    }
    push @{$_[3]}, chr ($cp + $pointer - $offset);
    return undef;
  } # _gb4
  
  sub _b5 ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    if ((0x7F <= $_[1] and $_[1] <= 0xA0) or $_[1] == 0xFF) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CC', $_[0], $_[1]);
      push @{$_[2]}, chr $_[1] if $_[1] < 0x80;
    } else {
      my $pointer = ($_[0] - 0x81) * 157
          + $_[1] - ($_[1] < 0x7F ? 0x40 : 0x62);
      my $c = $Web::Encoding::_Big5::DecodeIndex->[$pointer];
      if (defined $c) {
        if ($pointer < (0xA1 - 0x81) * 157) {
          $_[4]->(type => 'big5:hkscs', level => 'w',
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } elsif ($Web::Encoding::_Big5::NonCanonical->{$pointer}) {
          $_[4]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
        push @{$_[2]}, $c;
      } else {
        if ($_[1] < 0x80) {
          push @{$_[2]}, "\x{FFFD}", chr $_[1];
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } else {
          push @{$_[2]}, "\x{FFFD}";
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
      }
    }
  } # _b5
  
  sub _kr ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    if ($_[1] < 0x41 or $_[1] == 0xFF) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CC', $_[0], $_[1]);
      push @{$_[2]}, chr $_[1] if $_[1] < 0x80;
    } else {
      my $pointer = ($_[0] - 0x81) * 190 + $_[1] - 0x41;
      my $c = $Web::Encoding::_EUCKR::DecodeIndex->[$pointer];
      if (defined $c) {
        push @{$_[2]}, $c;
      } else {
        if ($_[1] < 0x80) {
          push @{$_[2]}, "\x{FFFD}", chr $_[1];
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } else {
          push @{$_[2]}, "\x{FFFD}";
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
      }
    }
  } # _kr
  
  sub _sjis ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    unless (0x40 <= $_[1] and $_[1] <= 0xFC and not $_[1] == 0x7F) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CC', $_[0], $_[1]);
      push @{$_[2]}, chr $_[1] if $_[1] < 0x80;
    } else {
      my $pointer = ($_[0] - ($_[0] < 0xA0 ? 0x81 : 0xC1)) * 188
          + $_[1] - ($_[1] < 0x7F ? 0x40 : 0x41);
      my $c = $Web::Encoding::_JIS::DecodeIndex->[$pointer];
      if (defined $c) {
        if ((8272 <= $pointer and $pointer <= 8835) or
            $Web::Encoding::_JIS::NonCanonicalSJIS->{$pointer}) {
          $_[4]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
        push @{$_[2]}, $c;
      } elsif (8836 <= $pointer and $pointer <= 10715) {
        ## EUDC.  Though they are not roundtrippable, we don't emit any
        ## warning here, as we will report them at Unicode character
        ## validation.  PUA code points are not interoperable anyway.
        push @{$_[2]}, chr (0xE000 - 8836 + $pointer);
      } else {
        if ($_[1] < 0x80) {
          push @{$_[2]}, "\x{FFFD}", chr $_[1];
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } else {
          push @{$_[2]}, "\x{FFFD}";
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
      }
    }
  } # _sjis
  
  sub _jis ($$$$$$) {
    # $b1 $b2 $out $index_offset $onerror $delta
    unless (0xA1 <= $_[1] and $_[1] <= 0xFE) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3],
              value => pack 'CC', $_[0] - $_[5], $_[1] - $_[5]);
    } elsif ($_[0] == 0x8E) {
      if ($_[1] <= 0xDF) {
        push @{$_[2]}, chr (0xFF61 - 0xA1 + $_[1]);
      } else {
        push @{$_[2]}, "\x{FFFD}";
        $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[3],
                value => pack 'CC', $_[0] - $_[5], $_[1] - $_[5]);
      }
    } else {
      my $pointer = ($_[0] - 0xA1) * 94 + $_[1] - 0xA1;
      my $c = $Web::Encoding::_JIS::DecodeIndex->[$pointer];
      if (defined $c) {
        push @{$_[2]}, $c;
        if ($Web::Encoding::_JIS::NonCanonicalEUC->{$pointer}) {
          $_[4]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[3],
                  value => pack 'CC', $_[0] - $_[5], $_[1] - $_[5]);
        }
      } else {
        push @{$_[2]}, "\x{FFFD}";
        $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[3],
                value => pack 'CC', $_[0] - $_[5], $_[1] - $_[5]);
      }
    }
  } # _jis
  
  sub _eucjp0212 ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    unless (0xA1 <= $_[1] and $_[1] <= 0xFE) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CCC', 0x8F, $_[0], $_[1]);
    } else {
      my $pointer = ($_[0] - 0xA1) * 94 + $_[1] - 0xA1;
      my $c = $Web::Encoding::_JIS::DecodeIndex0212->[$pointer];
      if (defined $c) {
        push @{$_[2]}, $c;
        $_[4]->(type => 'eucjp:0212', level => 'w',
                index => $_[3], value => pack 'CCC', 0x8F, $_[0], $_[1]);
      } else {
        push @{$_[2]}, "\x{FFFD}";
        $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[3], value => pack 'CCC', 0x8F, $_[0], $_[1]);
      }
    }
  } # _eucjp0212
  
  sub _decode_mb ($$$$$) {
    # $states $s $final $onerror $char
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    my @s;
    pos ($_[1]) = 0;
    if (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ /\G([\x40-\xFF])/gc) {
        $_[4]->($_[0]->{lead_byte}, ord $1, \@s, $_[0]->{index} - 1, $_[3]);
        delete $_[0]->{lead_byte};
      } elsif ($_[1] eq '' and not $_[2]) {
        #
      } else {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1, value => pack 'C', $_[0]->{lead_byte});
        delete $_[0]->{lead_byte};
      }
    } # lead_byte
    while ($_[1] =~ m{
      \G(?:
        ([\x81-\xFE](?:[\x40-\xFF]|(\z)?)) |
        ([\x80\xFF]) |
        ([\x00-\x7F]+)
      )
    }gx) {
      if (defined $1) {
        if (2 == length $1) {
          $_[4]->(ord substr ($1, 0, 1), ord substr ($1, 1, 1), \@s, $_[0]->{index} + $-[0], $_[3]);
        } else {
          if (defined $2 and not $_[2]) {
            $_[0]->{lead_byte} = ord $1;
          } else {
            push @s, "\x{FFFD}";
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} + $-[0], value => $1);
          }
        }
      } elsif (defined $3) {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[0]->{index} + $-[0], value => $3);
      } else {
        push @s, $4;
      }
    }
    $_[0]->{index} += length $_[1];
    return \@s;
  } # _decode_mb
  
  sub _decode_sjis ($$$$) {
    # $states $s $final $onerror
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    my @s;
    pos ($_[1]) = 0;
    if (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ /\G([\x40-\xFF])/gc) {
        _sjis $_[0]->{lead_byte}, ord $1, \@s, $_[0]->{index} - 1, $_[3];
        delete $_[0]->{lead_byte};
      } elsif ($_[1] eq '' and not $_[2]) {
        #
      } else {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1, value => pack 'C', $_[0]->{lead_byte});
        delete $_[0]->{lead_byte};
      }
    } # lead_byte
    while ($_[1] =~ m{
      \G(?:
        ([\x81-\x9F\xE0-\xFC](?:[\x40-\xFF]|(\z)?)) |
        ([\xA0-\xDF\xFD\xFE\xFF]) |
        ([\x00-\x7F\x80]+)
      )
    }gx) {
      if (defined $1) {
        if (2 == length $1) {
          _sjis ord substr ($1, 0, 1), ord substr ($1, 1, 1), \@s, $_[0]->{index} + $-[0], $_[3];
        } else {
          if (defined $2 and not $_[2]) {
            $_[0]->{lead_byte} = ord $1;
          } else {
            push @s, "\x{FFFD}";
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} + $-[0], value => $1);
          }
        }
      } elsif (defined $3) {
        my $c = ord $3;
        if (0xA1 <= $c and $c <= 0xDF) {
          push @s, chr (0xFF61 - 0xA1 + $c);
        } else {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $3);
        }
      } else {
        push @s, $4;
      }
    }
    $_[0]->{index} += length $_[1];
    return \@s;
  } # _decode_sjis
  
  sub _decode_eucjp ($$$$) {
    # $states $s $final $onerror
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    my @s;
    pos ($_[1]) = 0;
    if ($_[0]->{is_0212}) {
      if (defined $_[0]->{lead_byte}) {
        if ($_[1] =~ /\G([\x80-\xFF])/gc) {
          _eucjp0212 $_[0]->{lead_byte}, ord $1, \@s, $_[0]->{index} - 2, $_[3];
          delete $_[0]->{lead_byte};
          delete $_[0]->{is_0212};
        } elsif ($_[1] eq '' and not $_[2]) {
          #
        } else {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 2,
                  value => pack 'CC', 0x8F, $_[0]->{lead_byte});
          delete $_[0]->{lead_byte};
          delete $_[0]->{is_0212};
        }
      } else {
        if ($_[1] =~ /\G([\x80-\xFF])([\x80-\xFF])?/gc) {
          if (defined $2) {
            _eucjp0212 ord $1, ord $2, \@s, $_[0]->{index} - 1, $_[3];
            delete $_[0]->{is_0212};
          } else {
            if (1 == length $_[1] and not $_[2]) {
              $_[0]->{lead_byte} = ord $1;
            } else {
              push @s, "\x{FFFD}";
              $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                      index => $_[0]->{index} - 1,
                      value => "\x8F" . $1);
              delete $_[0]->{is_0212};
            }
          }
        } elsif ($_[1] eq '' and not $_[2]) {
          #
        } else {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 1, value => "\x8F");
          delete $_[0]->{is_0212};
        }
      }
    } elsif (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ /\G([\x80-\xFF])/gc) {
        _jis $_[0]->{lead_byte}, ord $1, \@s, $_[0]->{index} - 1, $_[3], 0;
        delete $_[0]->{lead_byte};
      } elsif ($_[1] eq '' and not $_[2]) {
        #
      } else {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1, value => pack 'C', $_[0]->{lead_byte});
        delete $_[0]->{lead_byte};
      }
    } # lead_byte
    while ($_[1] =~ m{
      \G(?:
        ([\x8E\xA1-\xFE](?:[\x80-\xFF]|(\z)?)) |
        \x8F ( (?:[\x80-\xFF] (?:[\x80-\xFF] |) |) (\z)? ) |
        ([\x80-\x8D\x90-\xA0\xFF]) |
        ([\x00-\x7F]+)
      )
    }gx) {
      if (defined $1) {
        if (2 == length $1) {
          _jis ord substr ($1, 0, 1), ord substr ($1, 1, 1), \@s, $_[0]->{index} + $-[0], $_[3], 0;
        } else {
          if (defined $2 and not $_[2]) {
            $_[0]->{lead_byte} = ord $1;
          } else {
            push @s, "\x{FFFD}";
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} + $-[0], value => $1);
          }
        }
      } elsif (defined $3) {
        if (2 == length $3) {
          _eucjp0212 ord substr ($3, 0, 1), ord substr ($3, 1, 1), \@s, $_[0]->{index} + $-[0], $_[3];
        } else {
          if (defined $4 and not $_[2]) {
            $_[0]->{lead_byte} = length $3 ? ord $3 : undef;
            $_[0]->{is_0212} = 1;
          } else {
            push @s, "\x{FFFD}";
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} + $-[0], value => "\x8F" . $3);
          }
        }
      } elsif (defined $5) {
        my $c = ord $5;
        push @s, "\x{FFFD}";
        $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[0]->{index} + $-[0], value => $5);
      } else {
        push @s, $6;
      }
    }
    $_[0]->{index} += length $_[1];
    return \@s;
  } # _decode_eucjp
  
  sub _decode_gb18030 ($$$$) {
    # $states $s $final $onerror
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    my @s;
    pos ($_[1]) = 0;
    if (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ /\G([\x30-\x39\x40-\xFF])/gc) {
        my $b2 = ord $1;
        if (0x30 <= $b2 and $b2 <= 0x39) {
          if (defined $_[0]->{lead_surrogate}) {
            $_[0]->{lead_surrogate} = _gb4 $_[0]->{lead_surrogate}, $_[0]->{lead_byte}, $b2, \@s, $_[0]->{index} - 2, $_[3];
          } else {
            $_[0]->{lead_surrogate} = [$_[0]->{lead_byte}, $b2];
          }
        } else {
          if (defined $_[0]->{lead_surrogate}) {
            push @s, "\x{FFFD}", chr $_[0]->{lead_surrogate}->[1];
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} - 3,
                    value => pack 'CC', @{delete $_[0]->{lead_surrogate}});
          }
          _gb $_[0]->{lead_byte}, $b2, \@s, $_[0]->{index} - 1, $_[3];
        }
        delete $_[0]->{lead_byte};
      } elsif ($_[1] eq '' and not $_[2]) {
        #
      } else {
        push @s, "\x{FFFD}";
        if (defined $_[0]->{lead_surrogate}) {
          push @s, chr $_[0]->{lead_surrogate}->[1] unless $_[2];
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 3,
                  value => pack 'CCC', @{delete $_[0]->{lead_surrogate}}, $_[0]->{lead_byte});
        } else {
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 1, value => pack 'C', $_[0]->{lead_byte});
        }
        delete $_[0]->{lead_byte};
      }
    } elsif (defined $_[0]->{lead_surrogate}) {
      if ($_[1] eq '') {
        if ($_[2]) { # final
          push @s, "\x{FFFD}";
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 2,
                  value => pack 'CC', @{$_[0]->{lead_surrogate}});
          delete $_[0]->{lead_surrogate};
        }
      }
    } # lead_surrogate
  
    while ($_[1] =~ m{
      \G(?:
        ([\x81-\xFE](?:[\x30-\x39\x40-\xFF]|(\z)?)) |
        ([\x80\xFF]) |
        ([\x00-\x7F]+)
      )
    }gx) {
      if (defined $1) {
        if (2 == length $1) {
          my $b1 = ord substr ($1, 0, 1);
          my $b2 = ord substr ($1, 1, 1);
          if (0x30 <= $b2 and $b2 <= 0x39) {
            if (defined $_[0]->{lead_surrogate}) {
              $_[0]->{lead_surrogate} = _gb4 $_[0]->{lead_surrogate}, $b1, $b2, \@s, $_[0]->{index} + $-[0] - 2, $_[3];
            } else {
              $_[0]->{lead_surrogate} = [$b1, $b2];
            }
          } else {
            if (defined $_[0]->{lead_surrogate}) {
              push @s, "\x{FFFD}", chr $_[0]->{lead_surrogate}->[1];
              $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                      index => $_[0]->{index} + $-[0] - 2,
                      value => (pack 'CC', @{delete $_[0]->{lead_surrogate}}));
            }
            _gb $b1, $b2, \@s, $_[0]->{index} + $-[0], $_[3];
          }
        } else {
          if (defined $2 and not $_[2]) {
            $_[0]->{lead_byte} = ord $1;
          } else {
            push @s, "\x{FFFD}";
            if (defined $_[0]->{lead_surrogate}) {
              push @s, chr $_[0]->{lead_surrogate}->[1];
              $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                      index => $_[0]->{index} + $-[0] - 2,
                      value => (pack 'CC', @{delete $_[0]->{lead_surrogate}}).$1);
            } else {
              $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                      index => $_[0]->{index} + $-[0], value => $1);
            }
          }
        }
      } elsif (defined $3) {
        if (defined $_[0]->{lead_surrogate}) {
          push @s, "\x{FFFD}", chr $_[0]->{lead_surrogate}->[1];
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0] - 2,
                  value => pack 'CC', @{delete $_[0]->{lead_surrogate}});
        }
        if ($3 eq "\x80") {
          $_[3]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[0]->{index} + $-[0], value => $3);
          push @s, "\x{20AC}";
        } else {
          my $c = ord $3;
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $3);
        }
      } else {
        if (defined $_[0]->{lead_surrogate}) {
          push @s, "\x{FFFD}", chr $_[0]->{lead_surrogate}->[1];
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0] - 2,
                  value => pack 'CC', @{delete $_[0]->{lead_surrogate}});
        }
        push @s, $4;
      }
    }
    $_[0]->{index} += length $_[1];
    return \@s;
  } # _decode_gb18030
  
  sub _esc ($$$$$) {
    # $states $s $final $onerror $out
    my $length = length $_[0]->{lead_escape};
    if ($length == 0) {
      if ($_[1] =~ m{\G(\x24[\x40\x42]?|\x28[BIJ]?)}gc) {
        $_[0]->{lead_escape} .= $1;
      }
    } elsif ($length == 1) {
      if ($_[0]->{lead_escape} eq "\x24" and $_[1] =~ m{\G([\x40\x42])}gc) {
        $_[0]->{lead_escape} .= $1;
      } elsif ($_[0]->{lead_escape} eq "\x28" and $_[1] =~ m{\G([BIJ])}gc) {
        $_[0]->{lead_escape} .= $1;
      }
    }
  
    my $new_state;
    if ($_[0]->{lead_escape} eq "\x24\x42") {
      $new_state = '0208';
    } elsif ($_[0]->{lead_escape} eq "\x24\x40") {
      $new_state = '6226';
      $_[3]->(type => 'iso2022jp:jis78', level => 'm',
              index => $_[0]->{index} + pos ($_[1]) - 2 - 1,
              value => "\x1B\x24\x40");
    } elsif ($_[0]->{lead_escape} eq "\x28\x42") {
      $new_state = 'ASCII';
    } elsif ($_[0]->{lead_escape} eq "\x28\x4A") {
      $new_state = 'Latin';
    } elsif ($_[0]->{lead_escape} eq "\x28\x49") {
      $new_state = 'Katakana';
    } else {
      if (not $_[2] and $_[1] =~ m{\G\z}gc) {
        return;
      } else {
        push @{$_[4]}, "\x{FFFD}", $_[0]->{lead_escape};
        $_[3]->(type => 'iso2022jp:lone escape', level => 'm', fatal => 1,
                index => $_[0]->{index} + pos ($_[1]) - length ($_[0]->{lead_escape}) - 1,
                value => "\x1B");
        delete $_[0]->{after_escape};
        delete $_[0]->{lead_escape};
        return;
      }
    }
  
    if ($_[0]->{after_escape}) {
      push @{$_[4]}, "\x{FFFD}";
      $_[3]->(type => 'iso2022jp:redundant escape',
              level => 'm', fatal => 1,
              index => $_[0]->{index} + pos ($_[1]) - length ($_[0]->{lead_escape}) - 1 - 3,
              value => {
                '0208' => "\x1B\x24\x42",
                '6226' => "\x1B\x24\x40",
                'ASCII' => "\x1B\x28\x42",
                'Latin' => "\x1B\x28\x4A",
                'Katakana' => "\x1B\x28\x49",
              }->{$_[0]->{state}});
    }
    $_[0]->{state} = $new_state;
    $_[0]->{after_escape} = 1;
    delete $_[0]->{lead_escape};
  } # _esc
  
  sub _decode_iso2022jp ($$$$) {
    # $states $s $final $onerror
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    $_[0]->{state} = 'ASCII' unless defined $_[0]->{state};
    my @s;
  
    pos ($_[1]) = 0;
  
    if (defined $_[0]->{lead_escape}) {
      _esc $_[0], $_[1], $_[2], $_[3], \@s;
    }
  
    if (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ m{\G([\x21-\x7E])}gc) {
        _jis 0x80 + $_[0]->{lead_byte}, 0x80 + ord $1, \@s, $_[0]->{index} - 1, $_[3], 0x80;
        delete $_[0]->{after_escape};
        delete $_[0]->{lead_byte};
      } elsif ($_[1] =~ m{\G([^\x1B])}gc) {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1,
                value => (pack 'C', $_[0]->{lead_byte}) . $1);
        delete $_[0]->{after_escape};
        delete $_[0]->{lead_byte};
      } elsif ($_[2]) {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1,
                value => pack 'C', $_[0]->{lead_byte});
        delete $_[0]->{lead_byte};
      }
    } # lead_byte
  
    my $length = length $_[1];
    while (pos ($_[1]) < $length) {
      if ($_[0]->{state} eq 'ASCII') {
        if ($_[1] =~ m{\G([\x00-\x0D\x10-\x1A\x1C-\x7F]+)}gc) {
          push @s, $1;
          delete $_[0]->{after_escape};
        } elsif ($_[1] =~ m{\G([^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        }
      } elsif ($_[0]->{state} eq 'Latin') {
        if ($_[1] =~ m{\G([\x00-\x0D\x10-\x1A\x1C-\x7F]+)}gc) {
          push @s, $1;
          $s[-1] =~ tr/\x5C\x7E/\xA5\x{203E}/;
          delete $_[0]->{after_escape};
        } elsif ($_[1] =~ m{\G([^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        }
      } elsif ($_[0]->{state} eq '0208' or $_[0]->{state} eq '6226') {
        while ($_[1] =~ m{\G([\x21-\x7E])([\x21-\x7E])}gc) {
          _jis 0x80 + ord $1, 0x80 + ord $2, \@s, $_[0]->{index} + $-[0], $_[3], 0x80;
          delete $_[0]->{after_escape};
        }
        if ($_[1] =~ m{\G([\x21-\x7E][^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        } elsif (not $_[2] and $_[1] =~ m{\G([\x21-\x7E])\z}gc) {
          $_[0]->{lead_byte} = ord $1;
          delete $_[0]->{after_escape};
        } elsif ($_[1] =~ m{\G([^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        }
      } elsif ($_[0]->{state} eq 'Katakana') {
        while ($_[1] =~ m{\G([\x21-\x5F])}gc) {
          push @s, chr (0xFF61 - 0x21 + ord $1);
          delete $_[0]->{after_escape};
        }
        if ($_[1] =~ m{\G([^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        }
      }
  
      if ($_[1] =~ m{\G\x1B}gc) {
        $_[0]->{lead_escape} = '';
        _esc $_[0], $_[1], $_[2], $_[3], \@s;
      }
    } # while
  
    $_[0]->{index} += length $_[1];
  
    if ($_[2]) {
      unless ($_[0]->{state} eq 'ASCII') {
        $_[3]->(type => 'iso2022jp:not ascii at end', level => 'w',
                index => $_[0]->{index});
      }
    }
  
    return \@s;
  } # _decode_iso2022jp
  
  sub bytes ($$) {
    my $key = $_[0]->{key};
    if (not defined $_[1]) {
      carp "Use of uninitialized value an argument";
      return [];
    } elsif (utf8::is_utf8 $_[1]) {
      croak "Cannot decode string with wide characters";
    } elsif ($_[1] eq '') {
      return [];
    }
  
    $_[0]->{states}->{index} = 0 unless defined $_[0]->{states}->{index};
    if ($key eq 'utf-8') {
      my $offset = $_[0]->{states}->{index}
                 + (defined $_[0]->{states}->{lead} ? -length $_[0]->{states}->{lead} : 0);
      my $decoded = [Web::Encoding::_decode8 ($_[0]->{states}, $_[1], 0, $offset, $_[0]->_onerror)];
  
      $_[0]->{states}->{index} += length $_[1];
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded and length $decoded->[0]) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif (Web::Encoding::_is_single ($key)) {
      require Web::Encoding::_Single;
      my $s = $_[1]; # string copy!
      my $Map = \($Web::Encoding::_Single::Decoder->{$_[0]->{key}});
      $s =~ s{([\x80-\xFF])}{substr $$Map, -0x80 + ord $1, 1}ge;
      while ($s =~ m{\x{FFFD}}g) {
        $_[0]->_onerror->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                          index => $_[0]->{states}->{index} + $-[0],
                          value => substr $_[1], $-[0], 1);
      }
      $_[0]->{states}->{index} += length $_[1];
      return [$s];
    } elsif ($key eq 'utf-16be') {
      my $decoded = _decode_16 $_[0]->{states}, $_[0]->_onerror, $_[1], 0, 'n';
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif ($key eq 'utf-16le') {
      my $decoded = _decode_16 $_[0]->{states}, $_[0]->_onerror, $_[1], 0, 'v';
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif ($key eq 'gb18030' or $key eq 'gbk') {
      require Web::Encoding::_GB;
      return _decode_gb18030 $_[0]->{states}, $_[1], 0, $_[0]->_onerror;
    } elsif ($key eq 'big5') {
      require Web::Encoding::_Big5;
      return _decode_mb $_[0]->{states}, $_[1], 0, $_[0]->_onerror, \&_b5;
    } elsif ($key eq 'shift_jis') {
      require Web::Encoding::_JIS;
      return _decode_sjis $_[0]->{states}, $_[1], 0, $_[0]->_onerror;
    } elsif ($key eq 'euc-jp') {
      require Web::Encoding::_JIS;
      return _decode_eucjp $_[0]->{states}, $_[1], 0, $_[0]->_onerror;
    } elsif ($key eq 'euc-kr') {
      require Web::Encoding::_EUCKR;
      return _decode_mb $_[0]->{states}, $_[1], 0, $_[0]->_onerror, \&_kr;
    } elsif ($key eq 'iso-2022-jp') {
      require Web::Encoding::_JIS;
      return _decode_iso2022jp $_[0]->{states}, $_[1], 0, $_[0]->_onerror;
    } elsif ($key eq 'replacement') {
      if (not $_[0]->{states}->{written}) {
        $_[0]->{states}->{written} = 1;
        $_[0]->_onerror->(type => 'encoding:replacement', level => 'm', fatal => 1,
                          index => 0);
        return ["\x{FFFD}"];
      } else {
        return [];
      }
    } else {
      croak "Bad encoding key |$key|";
    }
  } # bytes
  
  sub eof ($) {
    my $key = $_[0]->{key};
    if ($key eq 'utf-8') {
      $_[0]->{states}->{index} = 0 unless defined $_[0]->{states}->{index};
      my $offset = $_[0]->{states}->{index} + (defined $_[0]->{states}->{lead} ? -length $_[0]->{states}->{lead} : 0);
      ## Returns zero or more U+FFFD.
      return [Web::Encoding::_decode8 ($_[0]->{states}, '', 1, $offset, $_[0]->_onerror)];
    } elsif ($key eq 'utf-16be') {
      my $decoded = _decode_16 $_[0]->{states}, $_[0]->_onerror, '', 1, 'n';
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif ($key eq 'utf-16le') {
      my $decoded = _decode_16 $_[0]->{states}, $_[0]->_onerror, '', 1, 'v';
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif ($key eq 'gb18030' or $key eq 'gbk') {
      require Web::Encoding::_GB;
      return _decode_gb18030 $_[0]->{states}, '', 1, $_[0]->_onerror;
    } elsif ($key eq 'big5') {
      require Web::Encoding::_Big5;
      return _decode_mb $_[0]->{states}, '', 1, $_[0]->_onerror, \&_b5;
    } elsif ($key eq 'shift_jis') {
      require Web::Encoding::_JIS;
      return _decode_sjis $_[0]->{states}, '', 1, $_[0]->_onerror;
    } elsif ($key eq 'euc-jp') {
      require Web::Encoding::_JIS;
      return _decode_eucjp $_[0]->{states}, '', 1, $_[0]->_onerror;
    } elsif ($key eq 'euc-kr') {
      require Web::Encoding::_EUCKR;
      return _decode_mb $_[0]->{states}, '', 1, $_[0]->_onerror, \&_kr;
    } elsif ($key eq 'iso-2022-jp') {
      require Web::Encoding::_JIS;
      return _decode_iso2022jp $_[0]->{states}, '', 1, $_[0]->_onerror;
    } elsif ($key eq 'replacement' or Web::Encoding::_is_single ($key)) {
      return [];
    } else {
      croak "Bad encoding key |$key|";
    }
  } # eof
  
  1;
  
  =head1 LICENSE
  
  Copyright 2011-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_ENCODING_DECODER

$fatpacked{"Web/Encoding/_Defs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_ENCODING__DEFS';
  $Web::Encoding::_Defs = {
            "encodings" => {
                             "big5" => {
                                         "ascii_compat" => 1,
                                         "compat_name" => "Big5",
                                         "html_conformance" => "avoid",
                                         "html_decl_mapped" => "big5",
                                         "key" => "big5",
                                         "labels" => {
                                                       "big5" => {},
                                                       "big5-hkscs" => {},
                                                       "cn-big5" => {},
                                                       "csbig5" => {},
                                                       "x-x-big5" => {}
                                                     },
                                         "name" => "Big5",
                                         "output" => "big5"
                                       },
                             "euc-jp" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "EUC-JP",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "euc-jp",
                                           "key" => "euc-jp",
                                           "labels" => {
                                                         "cseucpkdfmtjapanese" => {},
                                                         "euc-jp" => {},
                                                         "x-euc-jp" => {}
                                                       },
                                           "name" => "EUC-JP",
                                           "output" => "euc-jp"
                                         },
                             "euc-kr" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "EUC-KR",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "euc-kr",
                                           "key" => "euc-kr",
                                           "labels" => {
                                                         "cseuckr" => {},
                                                         "csksc56011987" => {},
                                                         "euc-kr" => {},
                                                         "iso-ir-149" => {},
                                                         "korean" => {},
                                                         "ks_c_5601-1987" => {},
                                                         "ks_c_5601-1989" => {},
                                                         "ksc5601" => {},
                                                         "ksc_5601" => {},
                                                         "windows-949" => {}
                                                       },
                                           "name" => "EUC-KR",
                                           "output" => "euc-kr"
                                         },
                             "gb18030" => {
                                            "ascii_compat" => 1,
                                            "compat_name" => "gb18030",
                                            "html_conformance" => "avoid",
                                            "html_decl_mapped" => "gb18030",
                                            "key" => "gb18030",
                                            "labels" => {
                                                          "gb18030" => {}
                                                        },
                                            "name" => "gb18030",
                                            "output" => "gb18030"
                                          },
                             "gbk" => {
                                        "ascii_compat" => 1,
                                        "compat_name" => "GBK",
                                        "html_conformance" => "avoid",
                                        "html_decl_mapped" => "gbk",
                                        "key" => "gbk",
                                        "labels" => {
                                                      "chinese" => {},
                                                      "csgb2312" => {},
                                                      "csiso58gb231280" => {},
                                                      "gb2312" => {},
                                                      "gb_2312" => {},
                                                      "gb_2312-80" => {},
                                                      "gbk" => {},
                                                      "iso-ir-58" => {},
                                                      "x-gbk" => {}
                                                    },
                                        "name" => "GBK",
                                        "output" => "gbk"
                                      },
                             "ibm866" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "IBM866",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "ibm866",
                                           "key" => "ibm866",
                                           "labels" => {
                                                         "866" => {},
                                                         "cp866" => {},
                                                         "csibm866" => {},
                                                         "ibm866" => {}
                                                       },
                                           "name" => "IBM866",
                                           "output" => "ibm866",
                                           "single_byte" => 1
                                         },
                             "iso-2022-jp" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-2022-JP",
                                                "html_conformance" => "bad",
                                                "html_decl_mapped" => "iso-2022-jp",
                                                "key" => "iso-2022-jp",
                                                "labels" => {
                                                              "csiso2022jp" => {},
                                                              "iso-2022-jp" => {}
                                                            },
                                                "name" => "ISO-2022-JP",
                                                "output" => "iso-2022-jp"
                                              },
                             "iso-8859-10" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-10",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-10",
                                                "key" => "iso-8859-10",
                                                "labels" => {
                                                              "csisolatin6" => {},
                                                              "iso-8859-10" => {},
                                                              "iso-ir-157" => {},
                                                              "iso8859-10" => {},
                                                              "iso885910" => {},
                                                              "l6" => {},
                                                              "latin6" => {}
                                                            },
                                                "name" => "ISO-8859-10",
                                                "output" => "iso-8859-10",
                                                "single_byte" => 1
                                              },
                             "iso-8859-13" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-13",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-13",
                                                "key" => "iso-8859-13",
                                                "labels" => {
                                                              "iso-8859-13" => {},
                                                              "iso8859-13" => {},
                                                              "iso885913" => {}
                                                            },
                                                "name" => "ISO-8859-13",
                                                "output" => "iso-8859-13",
                                                "single_byte" => 1
                                              },
                             "iso-8859-14" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-14",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-14",
                                                "key" => "iso-8859-14",
                                                "labels" => {
                                                              "iso-8859-14" => {},
                                                              "iso8859-14" => {},
                                                              "iso885914" => {}
                                                            },
                                                "name" => "ISO-8859-14",
                                                "output" => "iso-8859-14",
                                                "single_byte" => 1
                                              },
                             "iso-8859-15" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-15",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-15",
                                                "key" => "iso-8859-15",
                                                "labels" => {
                                                              "csisolatin9" => {},
                                                              "iso-8859-15" => {},
                                                              "iso8859-15" => {},
                                                              "iso885915" => {},
                                                              "iso_8859-15" => {},
                                                              "l9" => {}
                                                            },
                                                "name" => "ISO-8859-15",
                                                "output" => "iso-8859-15",
                                                "single_byte" => 1
                                              },
                             "iso-8859-16" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-16",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-16",
                                                "key" => "iso-8859-16",
                                                "labels" => {
                                                              "iso-8859-16" => {}
                                                            },
                                                "name" => "ISO-8859-16",
                                                "output" => "iso-8859-16",
                                                "single_byte" => 1
                                              },
                             "iso-8859-2" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-2",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-2",
                                               "key" => "iso-8859-2",
                                               "labels" => {
                                                             "csisolatin2" => {},
                                                             "iso-8859-2" => {},
                                                             "iso-ir-101" => {},
                                                             "iso8859-2" => {},
                                                             "iso88592" => {},
                                                             "iso_8859-2" => {},
                                                             "iso_8859-2:1987" => {},
                                                             "l2" => {},
                                                             "latin2" => {}
                                                           },
                                               "name" => "ISO-8859-2",
                                               "output" => "iso-8859-2",
                                               "single_byte" => 1
                                             },
                             "iso-8859-3" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-3",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-3",
                                               "key" => "iso-8859-3",
                                               "labels" => {
                                                             "csisolatin3" => {},
                                                             "iso-8859-3" => {},
                                                             "iso-ir-109" => {},
                                                             "iso8859-3" => {},
                                                             "iso88593" => {},
                                                             "iso_8859-3" => {},
                                                             "iso_8859-3:1988" => {},
                                                             "l3" => {},
                                                             "latin3" => {}
                                                           },
                                               "name" => "ISO-8859-3",
                                               "output" => "iso-8859-3",
                                               "single_byte" => 1
                                             },
                             "iso-8859-4" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-4",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-4",
                                               "key" => "iso-8859-4",
                                               "labels" => {
                                                             "csisolatin4" => {},
                                                             "iso-8859-4" => {},
                                                             "iso-ir-110" => {},
                                                             "iso8859-4" => {},
                                                             "iso88594" => {},
                                                             "iso_8859-4" => {},
                                                             "iso_8859-4:1988" => {},
                                                             "l4" => {},
                                                             "latin4" => {}
                                                           },
                                               "name" => "ISO-8859-4",
                                               "output" => "iso-8859-4",
                                               "single_byte" => 1
                                             },
                             "iso-8859-5" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-5",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-5",
                                               "key" => "iso-8859-5",
                                               "labels" => {
                                                             "csisolatincyrillic" => {},
                                                             "cyrillic" => {},
                                                             "iso-8859-5" => {},
                                                             "iso-ir-144" => {},
                                                             "iso8859-5" => {},
                                                             "iso88595" => {},
                                                             "iso_8859-5" => {},
                                                             "iso_8859-5:1988" => {}
                                                           },
                                               "name" => "ISO-8859-5",
                                               "output" => "iso-8859-5",
                                               "single_byte" => 1
                                             },
                             "iso-8859-6" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-6",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-6",
                                               "key" => "iso-8859-6",
                                               "labels" => {
                                                             "arabic" => {},
                                                             "asmo-708" => {},
                                                             "csiso88596e" => {},
                                                             "csiso88596i" => {},
                                                             "csisolatinarabic" => {},
                                                             "ecma-114" => {},
                                                             "iso-8859-6" => {},
                                                             "iso-8859-6-e" => {},
                                                             "iso-8859-6-i" => {},
                                                             "iso-ir-127" => {},
                                                             "iso8859-6" => {},
                                                             "iso88596" => {},
                                                             "iso_8859-6" => {},
                                                             "iso_8859-6:1987" => {}
                                                           },
                                               "name" => "ISO-8859-6",
                                               "output" => "iso-8859-6",
                                               "single_byte" => 1
                                             },
                             "iso-8859-7" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-7",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-7",
                                               "key" => "iso-8859-7",
                                               "labels" => {
                                                             "csisolatingreek" => {},
                                                             "ecma-118" => {},
                                                             "elot_928" => {},
                                                             "greek" => {},
                                                             "greek8" => {},
                                                             "iso-8859-7" => {},
                                                             "iso-ir-126" => {},
                                                             "iso8859-7" => {},
                                                             "iso88597" => {},
                                                             "iso_8859-7" => {},
                                                             "iso_8859-7:1987" => {},
                                                             "sun_eu_greek" => {}
                                                           },
                                               "name" => "ISO-8859-7",
                                               "output" => "iso-8859-7",
                                               "single_byte" => 1
                                             },
                             "iso-8859-8" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-8",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-8",
                                               "key" => "iso-8859-8",
                                               "labels" => {
                                                             "csiso88598e" => {},
                                                             "csisolatinhebrew" => {},
                                                             "hebrew" => {},
                                                             "iso-8859-8" => {},
                                                             "iso-8859-8-e" => {},
                                                             "iso-ir-138" => {},
                                                             "iso8859-8" => {},
                                                             "iso88598" => {},
                                                             "iso_8859-8" => {},
                                                             "iso_8859-8:1988" => {},
                                                             "visual" => {}
                                                           },
                                               "name" => "ISO-8859-8",
                                               "output" => "iso-8859-8",
                                               "single_byte" => 1
                                             },
                             "iso-8859-8-i" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "ISO-8859-8-I",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "iso-8859-8-i",
                                                 "key" => "iso-8859-8-i",
                                                 "labels" => {
                                                               "csiso88598i" => {},
                                                               "iso-8859-8-i" => {},
                                                               "logical" => {}
                                                             },
                                                 "name" => "ISO-8859-8-I",
                                                 "output" => "iso-8859-8-i",
                                                 "single_byte" => 1
                                               },
                             "koi8-r" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "KOI8-R",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "koi8-r",
                                           "key" => "koi8-r",
                                           "labels" => {
                                                         "cskoi8r" => {},
                                                         "koi" => {},
                                                         "koi8" => {},
                                                         "koi8-r" => {},
                                                         "koi8_r" => {}
                                                       },
                                           "name" => "KOI8-R",
                                           "output" => "koi8-r",
                                           "single_byte" => 1
                                         },
                             "koi8-u" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "KOI8-U",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "koi8-u",
                                           "key" => "koi8-u",
                                           "labels" => {
                                                         "koi8-ru" => {},
                                                         "koi8-u" => {}
                                                       },
                                           "name" => "KOI8-U",
                                           "output" => "koi8-u",
                                           "single_byte" => 1
                                         },
                             "macintosh" => {
                                              "ascii_compat" => 1,
                                              "compat_name" => "macintosh",
                                              "html_conformance" => "avoid",
                                              "html_decl_mapped" => "macintosh",
                                              "key" => "macintosh",
                                              "labels" => {
                                                            "csmacintosh" => {},
                                                            "mac" => {},
                                                            "macintosh" => {},
                                                            "x-mac-roman" => {}
                                                          },
                                              "name" => "macintosh",
                                              "output" => "macintosh",
                                              "single_byte" => 1
                                            },
                             "replacement" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "replacement",
                                                "html_conformance" => "broken",
                                                "html_decl_mapped" => "replacement",
                                                "key" => "replacement",
                                                "labels" => {
                                                              "csiso2022kr" => {},
                                                              "hz-gb-2312" => {},
                                                              "iso-2022-cn" => {},
                                                              "iso-2022-cn-ext" => {},
                                                              "iso-2022-kr" => {},
                                                              "replacement" => {}
                                                            },
                                                "name" => "replacement",
                                                "output" => "utf-8"
                                              },
                             "shift_jis" => {
                                              "ascii_compat" => 1,
                                              "compat_name" => "Shift_JIS",
                                              "html_conformance" => "avoid",
                                              "html_decl_mapped" => "shift_jis",
                                              "key" => "shift_jis",
                                              "labels" => {
                                                            "csshiftjis" => {},
                                                            "ms932" => {},
                                                            "ms_kanji" => {},
                                                            "shift-jis" => {},
                                                            "shift_jis" => {},
                                                            "sjis" => {},
                                                            "windows-31j" => {},
                                                            "x-sjis" => {}
                                                          },
                                              "name" => "Shift_JIS",
                                              "output" => "shift_jis"
                                            },
                             "utf-16be" => {
                                             "ascii_compat" => 0,
                                             "compat_name" => "UTF-16BE",
                                             "html_conformance" => "avoid",
                                             "html_decl_mapped" => "utf-8",
                                             "key" => "utf-16be",
                                             "labels" => {
                                                           "unicodefffe" => {},
                                                           "utf-16be" => {}
                                                         },
                                             "name" => "UTF-16BE",
                                             "output" => "utf-8",
                                             "utf16" => 1
                                           },
                             "utf-16le" => {
                                             "ascii_compat" => 0,
                                             "compat_name" => "UTF-16LE",
                                             "html_conformance" => "avoid",
                                             "html_decl_mapped" => "utf-8",
                                             "key" => "utf-16le",
                                             "labels" => {
                                                           "csunicode" => {},
                                                           "iso-10646-ucs-2" => {},
                                                           "ucs-2" => {},
                                                           "unicode" => {},
                                                           "unicodefeff" => {},
                                                           "utf-16" => {},
                                                           "utf-16le" => {}
                                                         },
                                             "name" => "UTF-16LE",
                                             "output" => "utf-8",
                                             "utf16" => 1
                                           },
                             "utf-8" => {
                                          "ascii_compat" => 1,
                                          "compat_name" => "UTF-8",
                                          "conforming" => 1,
                                          "html_conformance" => "good",
                                          "html_decl_mapped" => "utf-8",
                                          "key" => "utf-8",
                                          "labels" => {
                                                        "unicode-1-1-utf-8" => {},
                                                        "unicode11utf8" => {},
                                                        "unicode20utf8" => {},
                                                        "utf-8" => {
                                                                     "conforming" => 1
                                                                   },
                                                        "utf8" => {},
                                                        "x-unicode20utf8" => {}
                                                      },
                                          "name" => "UTF-8",
                                          "output" => "utf-8"
                                        },
                             "windows-1250" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1250",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1250",
                                                 "key" => "windows-1250",
                                                 "labels" => {
                                                               "cp1250" => {},
                                                               "windows-1250" => {},
                                                               "x-cp1250" => {}
                                                             },
                                                 "name" => "windows-1250",
                                                 "output" => "windows-1250",
                                                 "single_byte" => 1
                                               },
                             "windows-1251" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1251",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1251",
                                                 "key" => "windows-1251",
                                                 "labels" => {
                                                               "cp1251" => {},
                                                               "windows-1251" => {},
                                                               "x-cp1251" => {}
                                                             },
                                                 "name" => "windows-1251",
                                                 "output" => "windows-1251",
                                                 "single_byte" => 1
                                               },
                             "windows-1252" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1252",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1252",
                                                 "key" => "windows-1252",
                                                 "labels" => {
                                                               "ansi_x3.4-1968" => {},
                                                               "ascii" => {},
                                                               "cp1252" => {},
                                                               "cp819" => {},
                                                               "csisolatin1" => {},
                                                               "ibm819" => {},
                                                               "iso-8859-1" => {},
                                                               "iso-ir-100" => {},
                                                               "iso8859-1" => {},
                                                               "iso88591" => {},
                                                               "iso_8859-1" => {},
                                                               "iso_8859-1:1987" => {},
                                                               "l1" => {},
                                                               "latin1" => {},
                                                               "us-ascii" => {},
                                                               "windows-1252" => {},
                                                               "x-cp1252" => {}
                                                             },
                                                 "name" => "windows-1252",
                                                 "output" => "windows-1252",
                                                 "single_byte" => 1
                                               },
                             "windows-1253" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1253",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1253",
                                                 "key" => "windows-1253",
                                                 "labels" => {
                                                               "cp1253" => {},
                                                               "windows-1253" => {},
                                                               "x-cp1253" => {}
                                                             },
                                                 "name" => "windows-1253",
                                                 "output" => "windows-1253",
                                                 "single_byte" => 1
                                               },
                             "windows-1254" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1254",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1254",
                                                 "key" => "windows-1254",
                                                 "labels" => {
                                                               "cp1254" => {},
                                                               "csisolatin5" => {},
                                                               "iso-8859-9" => {},
                                                               "iso-ir-148" => {},
                                                               "iso8859-9" => {},
                                                               "iso88599" => {},
                                                               "iso_8859-9" => {},
                                                               "iso_8859-9:1989" => {},
                                                               "l5" => {},
                                                               "latin5" => {},
                                                               "windows-1254" => {},
                                                               "x-cp1254" => {}
                                                             },
                                                 "name" => "windows-1254",
                                                 "output" => "windows-1254",
                                                 "single_byte" => 1
                                               },
                             "windows-1255" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1255",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1255",
                                                 "key" => "windows-1255",
                                                 "labels" => {
                                                               "cp1255" => {},
                                                               "windows-1255" => {},
                                                               "x-cp1255" => {}
                                                             },
                                                 "name" => "windows-1255",
                                                 "output" => "windows-1255",
                                                 "single_byte" => 1
                                               },
                             "windows-1256" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1256",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1256",
                                                 "key" => "windows-1256",
                                                 "labels" => {
                                                               "cp1256" => {},
                                                               "windows-1256" => {},
                                                               "x-cp1256" => {}
                                                             },
                                                 "name" => "windows-1256",
                                                 "output" => "windows-1256",
                                                 "single_byte" => 1
                                               },
                             "windows-1257" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1257",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1257",
                                                 "key" => "windows-1257",
                                                 "labels" => {
                                                               "cp1257" => {},
                                                               "windows-1257" => {},
                                                               "x-cp1257" => {}
                                                             },
                                                 "name" => "windows-1257",
                                                 "output" => "windows-1257",
                                                 "single_byte" => 1
                                               },
                             "windows-1258" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1258",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1258",
                                                 "key" => "windows-1258",
                                                 "labels" => {
                                                               "cp1258" => {},
                                                               "windows-1258" => {},
                                                               "x-cp1258" => {}
                                                             },
                                                 "name" => "windows-1258",
                                                 "output" => "windows-1258",
                                                 "single_byte" => 1
                                               },
                             "windows-874" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "windows-874",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "windows-874",
                                                "key" => "windows-874",
                                                "labels" => {
                                                              "dos-874" => {},
                                                              "iso-8859-11" => {},
                                                              "iso8859-11" => {},
                                                              "iso885911" => {},
                                                              "tis-620" => {},
                                                              "windows-874" => {}
                                                            },
                                                "name" => "windows-874",
                                                "output" => "windows-874",
                                                "single_byte" => 1
                                              },
                             "x-mac-cyrillic" => {
                                                   "ascii_compat" => 1,
                                                   "compat_name" => "x-mac-cyrillic",
                                                   "html_conformance" => "avoid",
                                                   "html_decl_mapped" => "x-mac-cyrillic",
                                                   "key" => "x-mac-cyrillic",
                                                   "labels" => {
                                                                 "x-mac-cyrillic" => {},
                                                                 "x-mac-ukrainian" => {}
                                                               },
                                                   "name" => "x-mac-cyrillic",
                                                   "output" => "x-mac-cyrillic",
                                                   "single_byte" => 1
                                                 },
                             "x-user-defined" => {
                                                   "ascii_compat" => 1,
                                                   "compat_name" => "x-user-defined",
                                                   "html_conformance" => "avoid",
                                                   "html_decl_mapped" => "windows-1252",
                                                   "key" => "x-user-defined",
                                                   "labels" => {
                                                                 "x-user-defined" => {}
                                                               },
                                                   "name" => "x-user-defined",
                                                   "output" => "x-user-defined",
                                                   "single_byte" => 1
                                                 }
                           },
            "html_decl_map" => {
                                 "utf-16be" => "utf-8",
                                 "utf-16le" => "utf-8",
                                 "x-user-defined" => "windows-1252"
                               },
            "locale_default" => {
                                  "*" => "windows-1252",
                                  "ar" => "windows-1256",
                                  "ba" => "windows-1251",
                                  "be" => "windows-1251",
                                  "bg" => "windows-1251",
                                  "cs" => "windows-1250",
                                  "el" => "iso-8859-7",
                                  "et" => "windows-1257",
                                  "fa" => "windows-1256",
                                  "he" => "windows-1255",
                                  "hr" => "windows-1250",
                                  "hu" => "iso-8859-2",
                                  "ja" => "shift_jis",
                                  "kk" => "windows-1251",
                                  "ko" => "euc-kr",
                                  "ku" => "windows-1254",
                                  "ky" => "windows-1251",
                                  "lt" => "windows-1257",
                                  "lv" => "windows-1257",
                                  "mk" => "windows-1251",
                                  "pl" => "iso-8859-2",
                                  "ru" => "windows-1251",
                                  "sah" => "windows-1251",
                                  "sk" => "windows-1250",
                                  "sl" => "iso-8859-2",
                                  "sr" => "windows-1251",
                                  "tg" => "windows-1251",
                                  "th" => "windows-874",
                                  "tr" => "windows-1254",
                                  "tt" => "windows-1251",
                                  "uk" => "windows-1251",
                                  "vi" => "windows-1258",
                                  "zh-cn" => "gb18030",
                                  "zh-tw" => "big5"
                                },
            "names" => [
                         "utf-8",
                         "big5",
                         "euc-jp",
                         "euc-kr",
                         "gb18030",
                         "gbk",
                         "ibm866",
                         "iso-2022-jp",
                         "iso-8859-10",
                         "iso-8859-13",
                         "iso-8859-14",
                         "iso-8859-15",
                         "iso-8859-16",
                         "iso-8859-2",
                         "iso-8859-3",
                         "iso-8859-4",
                         "iso-8859-5",
                         "iso-8859-6",
                         "iso-8859-7",
                         "iso-8859-8",
                         "iso-8859-8-i",
                         "koi8-r",
                         "koi8-u",
                         "macintosh",
                         "shift_jis",
                         "utf-16be",
                         "utf-16le",
                         "windows-1250",
                         "windows-1251",
                         "windows-1252",
                         "windows-1253",
                         "windows-1254",
                         "windows-1255",
                         "windows-1256",
                         "windows-1257",
                         "windows-1258",
                         "windows-874",
                         "x-mac-cyrillic",
                         "x-user-defined",
                         "replacement"
                       ],
            "supported_labels" => {
                                    "866" => "ibm866",
                                    "ansi_x3.4-1968" => "windows-1252",
                                    "arabic" => "iso-8859-6",
                                    "ascii" => "windows-1252",
                                    "asmo-708" => "iso-8859-6",
                                    "big5" => "big5",
                                    "big5-hkscs" => "big5",
                                    "chinese" => "gbk",
                                    "cn-big5" => "big5",
                                    "cp1250" => "windows-1250",
                                    "cp1251" => "windows-1251",
                                    "cp1252" => "windows-1252",
                                    "cp1253" => "windows-1253",
                                    "cp1254" => "windows-1254",
                                    "cp1255" => "windows-1255",
                                    "cp1256" => "windows-1256",
                                    "cp1257" => "windows-1257",
                                    "cp1258" => "windows-1258",
                                    "cp819" => "windows-1252",
                                    "cp866" => "ibm866",
                                    "csbig5" => "big5",
                                    "cseuckr" => "euc-kr",
                                    "cseucpkdfmtjapanese" => "euc-jp",
                                    "csgb2312" => "gbk",
                                    "csibm866" => "ibm866",
                                    "csiso2022jp" => "iso-2022-jp",
                                    "csiso2022kr" => "replacement",
                                    "csiso58gb231280" => "gbk",
                                    "csiso88596e" => "iso-8859-6",
                                    "csiso88596i" => "iso-8859-6",
                                    "csiso88598e" => "iso-8859-8",
                                    "csiso88598i" => "iso-8859-8-i",
                                    "csisolatin1" => "windows-1252",
                                    "csisolatin2" => "iso-8859-2",
                                    "csisolatin3" => "iso-8859-3",
                                    "csisolatin4" => "iso-8859-4",
                                    "csisolatin5" => "windows-1254",
                                    "csisolatin6" => "iso-8859-10",
                                    "csisolatin9" => "iso-8859-15",
                                    "csisolatinarabic" => "iso-8859-6",
                                    "csisolatincyrillic" => "iso-8859-5",
                                    "csisolatingreek" => "iso-8859-7",
                                    "csisolatinhebrew" => "iso-8859-8",
                                    "cskoi8r" => "koi8-r",
                                    "csksc56011987" => "euc-kr",
                                    "csmacintosh" => "macintosh",
                                    "csshiftjis" => "shift_jis",
                                    "csunicode" => "utf-16le",
                                    "cyrillic" => "iso-8859-5",
                                    "dos-874" => "windows-874",
                                    "ecma-114" => "iso-8859-6",
                                    "ecma-118" => "iso-8859-7",
                                    "elot_928" => "iso-8859-7",
                                    "euc-jp" => "euc-jp",
                                    "euc-kr" => "euc-kr",
                                    "gb18030" => "gb18030",
                                    "gb2312" => "gbk",
                                    "gb_2312" => "gbk",
                                    "gb_2312-80" => "gbk",
                                    "gbk" => "gbk",
                                    "greek" => "iso-8859-7",
                                    "greek8" => "iso-8859-7",
                                    "hebrew" => "iso-8859-8",
                                    "hz-gb-2312" => "replacement",
                                    "ibm819" => "windows-1252",
                                    "ibm866" => "ibm866",
                                    "iso-10646-ucs-2" => "utf-16le",
                                    "iso-2022-cn" => "replacement",
                                    "iso-2022-cn-ext" => "replacement",
                                    "iso-2022-jp" => "iso-2022-jp",
                                    "iso-2022-kr" => "replacement",
                                    "iso-8859-1" => "windows-1252",
                                    "iso-8859-10" => "iso-8859-10",
                                    "iso-8859-11" => "windows-874",
                                    "iso-8859-13" => "iso-8859-13",
                                    "iso-8859-14" => "iso-8859-14",
                                    "iso-8859-15" => "iso-8859-15",
                                    "iso-8859-16" => "iso-8859-16",
                                    "iso-8859-2" => "iso-8859-2",
                                    "iso-8859-3" => "iso-8859-3",
                                    "iso-8859-4" => "iso-8859-4",
                                    "iso-8859-5" => "iso-8859-5",
                                    "iso-8859-6" => "iso-8859-6",
                                    "iso-8859-6-e" => "iso-8859-6",
                                    "iso-8859-6-i" => "iso-8859-6",
                                    "iso-8859-7" => "iso-8859-7",
                                    "iso-8859-8" => "iso-8859-8",
                                    "iso-8859-8-e" => "iso-8859-8",
                                    "iso-8859-8-i" => "iso-8859-8-i",
                                    "iso-8859-9" => "windows-1254",
                                    "iso-ir-100" => "windows-1252",
                                    "iso-ir-101" => "iso-8859-2",
                                    "iso-ir-109" => "iso-8859-3",
                                    "iso-ir-110" => "iso-8859-4",
                                    "iso-ir-126" => "iso-8859-7",
                                    "iso-ir-127" => "iso-8859-6",
                                    "iso-ir-138" => "iso-8859-8",
                                    "iso-ir-144" => "iso-8859-5",
                                    "iso-ir-148" => "windows-1254",
                                    "iso-ir-149" => "euc-kr",
                                    "iso-ir-157" => "iso-8859-10",
                                    "iso-ir-58" => "gbk",
                                    "iso8859-1" => "windows-1252",
                                    "iso8859-10" => "iso-8859-10",
                                    "iso8859-11" => "windows-874",
                                    "iso8859-13" => "iso-8859-13",
                                    "iso8859-14" => "iso-8859-14",
                                    "iso8859-15" => "iso-8859-15",
                                    "iso8859-2" => "iso-8859-2",
                                    "iso8859-3" => "iso-8859-3",
                                    "iso8859-4" => "iso-8859-4",
                                    "iso8859-5" => "iso-8859-5",
                                    "iso8859-6" => "iso-8859-6",
                                    "iso8859-7" => "iso-8859-7",
                                    "iso8859-8" => "iso-8859-8",
                                    "iso8859-9" => "windows-1254",
                                    "iso88591" => "windows-1252",
                                    "iso885910" => "iso-8859-10",
                                    "iso885911" => "windows-874",
                                    "iso885913" => "iso-8859-13",
                                    "iso885914" => "iso-8859-14",
                                    "iso885915" => "iso-8859-15",
                                    "iso88592" => "iso-8859-2",
                                    "iso88593" => "iso-8859-3",
                                    "iso88594" => "iso-8859-4",
                                    "iso88595" => "iso-8859-5",
                                    "iso88596" => "iso-8859-6",
                                    "iso88597" => "iso-8859-7",
                                    "iso88598" => "iso-8859-8",
                                    "iso88599" => "windows-1254",
                                    "iso_8859-1" => "windows-1252",
                                    "iso_8859-15" => "iso-8859-15",
                                    "iso_8859-1:1987" => "windows-1252",
                                    "iso_8859-2" => "iso-8859-2",
                                    "iso_8859-2:1987" => "iso-8859-2",
                                    "iso_8859-3" => "iso-8859-3",
                                    "iso_8859-3:1988" => "iso-8859-3",
                                    "iso_8859-4" => "iso-8859-4",
                                    "iso_8859-4:1988" => "iso-8859-4",
                                    "iso_8859-5" => "iso-8859-5",
                                    "iso_8859-5:1988" => "iso-8859-5",
                                    "iso_8859-6" => "iso-8859-6",
                                    "iso_8859-6:1987" => "iso-8859-6",
                                    "iso_8859-7" => "iso-8859-7",
                                    "iso_8859-7:1987" => "iso-8859-7",
                                    "iso_8859-8" => "iso-8859-8",
                                    "iso_8859-8:1988" => "iso-8859-8",
                                    "iso_8859-9" => "windows-1254",
                                    "iso_8859-9:1989" => "windows-1254",
                                    "koi" => "koi8-r",
                                    "koi8" => "koi8-r",
                                    "koi8-r" => "koi8-r",
                                    "koi8-ru" => "koi8-u",
                                    "koi8-u" => "koi8-u",
                                    "koi8_r" => "koi8-r",
                                    "korean" => "euc-kr",
                                    "ks_c_5601-1987" => "euc-kr",
                                    "ks_c_5601-1989" => "euc-kr",
                                    "ksc5601" => "euc-kr",
                                    "ksc_5601" => "euc-kr",
                                    "l1" => "windows-1252",
                                    "l2" => "iso-8859-2",
                                    "l3" => "iso-8859-3",
                                    "l4" => "iso-8859-4",
                                    "l5" => "windows-1254",
                                    "l6" => "iso-8859-10",
                                    "l9" => "iso-8859-15",
                                    "latin1" => "windows-1252",
                                    "latin2" => "iso-8859-2",
                                    "latin3" => "iso-8859-3",
                                    "latin4" => "iso-8859-4",
                                    "latin5" => "windows-1254",
                                    "latin6" => "iso-8859-10",
                                    "logical" => "iso-8859-8-i",
                                    "mac" => "macintosh",
                                    "macintosh" => "macintosh",
                                    "ms932" => "shift_jis",
                                    "ms_kanji" => "shift_jis",
                                    "replacement" => "replacement",
                                    "shift-jis" => "shift_jis",
                                    "shift_jis" => "shift_jis",
                                    "sjis" => "shift_jis",
                                    "sun_eu_greek" => "iso-8859-7",
                                    "tis-620" => "windows-874",
                                    "ucs-2" => "utf-16le",
                                    "unicode" => "utf-16le",
                                    "unicode-1-1-utf-8" => "utf-8",
                                    "unicode11utf8" => "utf-8",
                                    "unicode20utf8" => "utf-8",
                                    "unicodefeff" => "utf-16le",
                                    "unicodefffe" => "utf-16be",
                                    "us-ascii" => "windows-1252",
                                    "utf-16" => "utf-16le",
                                    "utf-16be" => "utf-16be",
                                    "utf-16le" => "utf-16le",
                                    "utf-8" => "utf-8",
                                    "utf8" => "utf-8",
                                    "visual" => "iso-8859-8",
                                    "windows-1250" => "windows-1250",
                                    "windows-1251" => "windows-1251",
                                    "windows-1252" => "windows-1252",
                                    "windows-1253" => "windows-1253",
                                    "windows-1254" => "windows-1254",
                                    "windows-1255" => "windows-1255",
                                    "windows-1256" => "windows-1256",
                                    "windows-1257" => "windows-1257",
                                    "windows-1258" => "windows-1258",
                                    "windows-31j" => "shift_jis",
                                    "windows-874" => "windows-874",
                                    "windows-949" => "euc-kr",
                                    "x-cp1250" => "windows-1250",
                                    "x-cp1251" => "windows-1251",
                                    "x-cp1252" => "windows-1252",
                                    "x-cp1253" => "windows-1253",
                                    "x-cp1254" => "windows-1254",
                                    "x-cp1255" => "windows-1255",
                                    "x-cp1256" => "windows-1256",
                                    "x-cp1257" => "windows-1257",
                                    "x-cp1258" => "windows-1258",
                                    "x-euc-jp" => "euc-jp",
                                    "x-gbk" => "gbk",
                                    "x-mac-cyrillic" => "x-mac-cyrillic",
                                    "x-mac-roman" => "macintosh",
                                    "x-mac-ukrainian" => "x-mac-cyrillic",
                                    "x-sjis" => "shift_jis",
                                    "x-unicode20utf8" => "utf-8",
                                    "x-user-defined" => "x-user-defined",
                                    "x-x-big5" => "big5"
                                  }
          };
  
WEB_ENCODING__DEFS

$fatpacked{"WritableStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WRITABLESTREAM';
  package WritableStream;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Scalar::Util qw(weaken);
  use Promise;
  use Streams::_Common;
  
  ## In JS (Streams Standard specification text), stream and controller
  ## are referencing each other by their internal slots:
  ##
  ##   stream.[[WritableStreamController]] === controller
  ##   controller.[[ControlledWritableStream]] === stream
  ##
  ## In this module, a $stream is a blessed hash reference whose
  ## |writable_stream_controller| is a non-blessed hash reference
  ## containing controller's internal slots (except for
  ## [[ControlledWritableStream]]).  A $controller_obj is a blessed
  ## scalar reference to $stream.  $stream->{controller_obj} is a weak
  ## reference to $controller_obj.  $controller_obj is used when
  ## $underlying_sink methods are invoked.  If $stream->{controller_obj}
  ## is not defined, a new blessed scalar reference is created.
  ##
  ## Likewise, stream and reader are referencing each other in JS when
  ## there is a writer whose lock is not released:
  ##
  ##   stream.[[Writer]] === writer
  ##   writer.[[OwnerWritableStream]] === stream
  ##
  ## In this module, a $writer is a blessed scalar reference to $stream
  ## whose |writer| is a non-blessed hash reference containing writer's
  ## internal slots (except for [[OwnerWritableStream]]).  When the
  ## $writer's lock is released, $$writer is replaced by a hash
  ## reference whose |writer| is $writer's hash reference (and
  ## $stream->{writer} is set to |undef|).
  
  sub new ($;$$) {
    die _type_error "Sink is not a HASH"
        if defined $_[1] and not ref $_[1] eq 'HASH'; # Not in JS
    die _type_error "Options is not a HASH"
        if defined $_[2] and not ref $_[2] eq 'HASH'; # Not in JS
    my $self = bless {caller => [caller 0]}, $_[0];
    my $underlying_sink = $_[1] || {};
    my $opts = $_[2] || {high_water_mark => 1};
    die _range_error "Unknown type |$underlying_sink->{type}|"
        if defined $underlying_sink->{type};
    $self->{state} = 'writable';
    $self->{stored_error} = undef;
    $self->{writer} = undef;
    $self->{in_flight_write_request} = undef;
    $self->{close_request} = undef;
    $self->{in_flight_close_request} = undef;
    $self->{pending_abort_request} = undef;
    $self->{write_requests} = [];
    $self->{backpressure} = !!0;
    #$self->{writable_stream_controller} = # (to be set within new)
    WritableStreamDefaultController->new
        ($self, $underlying_sink, $opts->{size}, $opts->{high_water_mark});
    ## [[StartSteps]] is invoked within WritableStreamDefaultController::new
    return $self;
  } # new
  
  sub locked ($) {
    return defined $_[0]->{writer}; # IsWritableStreamLocked
  } # locked
  
  sub get_writer ($) {
    ## AcquireWritableStreamDefaultWriter
    return WritableStreamDefaultWriter->new ($_[0]);
  } # get_writer
  
  sub WritableStream::_update_backpressure ($$) {
    my ($stream, $controller) = @_;
  
    my $backpressure = (
      ## WritableStreamDefaultControllerGetBackpressure
      (
        ## WritableStreamDefaultControllerGetDesiredSize
        (
          $controller->{strategy_hwm} - $controller->{queue_total_size}
        )
        <= 0
      )
    );
  
    ## WritableStreamUpdateBackpressure
    my $writer = $stream->{writer};
    if (defined $writer and
        not $backpressure eq $stream->{backpressure}) {
      if ($backpressure) {
        $writer->{ready_promise} = _promise_capability;
      } else {
        $writer->{ready_promise}->{resolve}->(undef);
      }
    }
    $stream->{backpressure} = $backpressure;
  } # _update_backpressure
  
  sub WritableStream::_reject_close_and_closed_promise_if_needed ($) {
    my $stream = $_[0];
    if (defined $stream->{close_request}) {
      $stream->{close_request}->{reject}->($stream->{stored_error});
      $stream->{close_request} = undef;
    }
    my $writer = $stream->{writer};
    if (defined $writer) {
      $writer->{closed_promise}->{reject}->($stream->{stored_error});
      $writer->{closed_promise}->{promise}->manakai_set_handled;
    }
    $stream->_terminate; # Not in JS
  } # WritableStreamRejectCloseAndClosedPromiseIfNeeded
  
  sub WritableStream::_finish_erroring ($) {
    my $stream = $_[0];
    $stream->{state} = 'errored';
    my $controller_obj = $stream->{controller_obj};
    unless (defined $controller_obj) {
      weaken ($stream->{controller_obj} = bless \$stream, 'WritableStreamDefaultController');
      $controller_obj = $stream->{controller_obj};
    }
    $controller_obj->_error_steps;
    my $stored_error = $stream->{stored_error};
    for my $write_request (@{$stream->{write_requests}}) {
      $write_request->{reject}->($stored_error);
    }
    $stream->{write_requests} = [];
    if (not defined $stream->{pending_abort_request}) {
      WritableStream::_reject_close_and_closed_promise_if_needed $stream;
      return;
    }
    my $abort_request = $stream->{pending_abort_request};
    $stream->{pending_abort_request} = undef;
    if ($abort_request->{was_already_erroring}) {
      $abort_request->{promise}->{reject}->($stored_error);
      WritableStream::_reject_close_and_closed_promise_if_needed $stream;
      return;
    }
    $controller_obj->_abort_steps ($abort_request->{reason})->then (sub {
      $abort_request->{promise}->{resolve}->(undef);
      WritableStream::_reject_close_and_closed_promise_if_needed $stream;
    }, sub {
      $abort_request->{promise}->{reject}->($_[0]);
      WritableStream::_reject_close_and_closed_promise_if_needed $stream;
    });
  } # WritableStreamFinishErroring
  
  sub WritableStream::_start_erroring ($$) {
    my $stream = $_[0];
    my $controller = $stream->{writable_stream_controller};
    $stream->{state} = 'erroring';
    $stream->{stored_error} = $_[1];
    my $writer = $stream->{writer};
    if (defined $writer) {
      ## WritableStreamDefaultWriterEnsureReadyPromiseRejected
      $writer->{ready_promise} ||= _promise_capability;
      $writer->{ready_promise}->{reject}->($_[1]);
      $writer->{ready_promise}->{promise}->manakai_set_handled;
    }
  
    if (not (
      ## WritableStreamHasOperationMarkedInFlight
      not (
        not defined $stream->{in_flight_writer_request} and
        not defined $controller->{in_flight_close_request}
      )
    ) and $controller->{started}) {
      WritableStream::_finish_erroring $stream;
    }
  } # WritableStreamStartErroring
  
  sub WritableStream::_deal_with_rejection ($$) {
    my $stream = $_[0];
    if ($stream->{state} eq 'writable') {
      WritableStream::_start_erroring $stream, $_[1];
      return;
    }
    WritableStream::_finish_erroring $stream;
  } # WritableStreamDealWithRejection
  
  ## This is not a public function but can be used to implement
  ## specification operations invoking WritableStreamAbort.
  sub WritableStream::_abort ($$) {
    ## WritableStreamAbort
    my $stream = $_[0];
    if ($stream->{state} eq 'closed') {
      return Promise->resolve (undef);
    } elsif ($stream->{state} eq 'errored') {
      return Promise->reject ($stream->{stored_error});
    }
    my $error = _type_error "WritableStream is aborted";
    if (defined $stream->{pending_abort_request}) {
      return Promise->reject ($error);
    }
    my $reason = $stream->{state} eq 'erroring' ? undef : $_[1];
    my $was_already_erroring = $stream->{state} eq 'erroring';
    my $p = _promise_capability;
    $stream->{pending_abort_request} = {
      promise => $p,
      reason => $reason,
      was_already_erroring => $was_already_erroring,
    };
    WritableStream::_start_erroring $stream, $error
        unless $was_already_erroring;
    return $p->{promise};
  } # _abort
  
  sub abort ($$) {
    return Promise->reject (_type_error "WritableStream is locked")
        if defined $_[0]->{writer}; # IsWritableStreamLocked
    return WritableStream::_abort $_[0], $_[1];
  } # abort
  
  sub WritableStreamDefaultController::_process_close ($) {
    #my $controller = $_[0];
    #my $stream = $controller->{controlled_writable_stream};
    my $stream = $_[0];
    my $controller = $_[0]->{writable_stream_controller};
  
    ## WritableStreamMarkCloseRequestInFlight
    $stream->{in_flight_close_request} = $stream->{close_request};
    $stream->{close_request} = undef;
  
    ## DequeueValue
    {
      my $pair = shift @{$controller->{queue}};
      $controller->{queue_total_size} -= $pair->{size};
      $controller->{queue_total_size} = 0 if $controller->{queue_total_size} < 0;
      #$pair->{value};
    }
  
    _hashref_method ($controller->{underlying_sink}, 'close', [])->then (sub {
      ## WritableStreamFinishInFlightClose
      $stream->{in_flight_close_request}->{resolve}->(undef);
      $stream->{in_flight_close_request} = undef;
      if ($stream->{state} eq 'erroring') {
        $stream->{stored_error} = undef;
        if (defined $stream->{pending_abort_request}) {
          $stream->{pending_abort_request}->{promise}->{resolve}->(undef);
          $stream->{pending_abort_request} = undef;
        }
      }
      $stream->{state} = 'closed';
      if (defined $stream->{writer}) {
        $stream->{writer}->{closed_promise}->{resolve}->(undef);
      }
      $stream->_terminate; # Not in JS
    }, sub {
      ## WritableStreamFinishInFlightCloseWithError
      $stream->{in_flight_close_request}->{reject}->($_[0]);
      $stream->{in_flight_close_request} = undef;
      if (defined $stream->{pending_abort_request}) {
        $stream->{pending_abort_request}->{promise}->{reject}->($_[0]);
        $stream->{pending_abort_request} = undef;
      }
      WritableStream::_deal_with_rejection $stream, $_[1];
    });
  } # WritableStreamDefaultControllerProcessClose
  
  sub WritableStreamDefaultController::_process_write ($$) {
    #my $controller = $_[0];
    #my $stream = $controller->{controlled_writable_stream};
    my $stream = $_[0];
    my $controller = $_[0]->{writable_stream_controller};
  
    ## WritableStreamMarkFirstWriteRequestInFlight
    $stream->{in_flight_write_request} = shift @{$stream->{write_requests}};
  
    my $controller_obj = $stream->{controller_obj};
    unless (defined $controller_obj) {
      weaken ($stream->{controller_obj} = bless \$stream, 'WritableStreamDefaultController');
      $controller_obj = $stream->{controller_obj};
    }
    _hashref_method ($controller->{underlying_sink}, 'write', [$_[1], $controller_obj])->then (sub {
      ## WritableStreamFinishInFlightWrite
      $stream->{in_flight_write_request}->{resolve}->(undef);
      $stream->{in_flight_write_request} = undef;
  
      ## DequeueValue
      my $pair = shift @{$controller->{queue}};
      $controller->{queue_total_size} -= $pair->{size};
      $controller->{queue_total_size} = 0 if $controller->{queue_total_size} < 0;
      #$pair->{value};
  
      if (
        not
        ## WritableStreamCloseQueuedOrInFlight
        (defined $stream->{close_request} or
         defined $stream->{in_flight_close_request}) and
        $stream->{state} eq 'writable'
      ) {
        $stream->_update_backpressure ($controller);
      }
      WritableStreamDefaultController::_advance_queue_if_needed
          ($stream); #($controller);
    }, sub {
      ## WritableStreamFinishInFlightWriteWithError
      $stream->{in_flight_write_request}->{reject}->($_[0]);
      $stream->{in_flight_write_request} = undef;
      WritableStream::_deal_with_rejection $stream, $_[0];
    });
  } # WritableStreamDefaultControllerProcessWrite
  
  sub WritableStreamDefaultController::_advance_queue_if_needed ($) {
    #my $controller = $_[0];
    #my $stream = $controller->{controlled_writable_stream};
    my $stream = $_[0];
    my $controller = $_[0]->{writable_stream_controller};
    return if not $controller->{started};
    return if defined $stream->{in_flight_write_request};
    return if $stream->{state} eq 'closed' or $stream->{state} eq 'errored';
    if ($stream->{state} eq 'erroring') {
      WritableStream::_finish_erroring $stream;
      return;
    }
    return unless @{$controller->{queue}};
  
    my $write_record = $controller->{queue}->[0]->{value}; # PeekQueueValue
    if ($write_record eq 'close') {
      WritableStreamDefaultController::_process_close $stream; #$controller;
    } else {
      WritableStreamDefaultController::_process_write
          $stream, $write_record->{chunk};
          #$controller, $write_record->{chunk};
    }
  } # WritableStreamDefaultControllerAdvanceQueueIfNeeded
  
  ## Not in JS
  sub _terminate ($) {
    my $stream = $_[0];
    delete $stream->{writable_stream_controller}->{underlying_sink};
    delete $stream->{writable_stream_controller}->{strategy_size};
  } # _terminate
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/) {
      my $diag = '';
      if ($_[0]->{state} eq 'writable') {
        $diag = ' (Stream is not closed)';
      }
      warn "$$: Reference to @{[ref $_[0]]} created at $_[0]->{caller}->[1] line $_[0]->{caller}->[2] is not discarded before global destruction$diag\n";  }
  } # DESTROY
  
  package WritableStreamDefaultController;
  use Scalar::Util qw(weaken);
  use Streams::_Common;
  push our @CARP_NOT, qw(WritableStream);
  
  sub new ($$$$$) {
    my (undef, $stream, $underlying_sink, $size, $hwm) = @_;
    die _type_error "The argument is not a WritableStream"
        unless UNIVERSAL::isa ($stream, 'WritableStream'); # IsWritableStream
    die _type_error "WritableStream has a controller"
        if defined $stream->{writable_stream_controller};
    my $controller = {};
    #$controller->{controlled_writable_stream} = $stream;
    my $controller_obj = bless \$stream, $_[0];
    $controller->{underlying_sink} = $underlying_sink;
    $controller->{started} = 0;
  
    ## ResetQueue
    $controller->{queue} = [];
    $controller->{queue_total_size} = 0;
  
    ## ValidateAndNormalizeQueuingStrategy
    {
      die _type_error "Size is not a CODE"
          if defined $size and not ref $size eq 'CODE';
      $controller->{strategy_size} = $size;
  
      ## ValidateAndNormalizeHighWaterMark
      $hwm = 0+($hwm || 0); ## ToNumber
      $hwm = 0 if $hwm eq 'NaN' or $hwm eq 'nan'; # Not in JS
      $controller->{strategy_hwm} = $hwm;
      die _range_error "High water mark $hwm is negative" if $hwm < 0;
    }
  
    $stream->_update_backpressure ($controller);
  
    ## In spec, done within WritableStream constructor
    $stream->{writable_stream_controller} = $controller;
    weaken ($stream->{controller_obj} = $controller_obj);
  
    ## [[StartSteps]].  In the spec, this is invoked from WritableStream::new.
    _hashref_method_throws ($underlying_sink, 'start', [$controller_obj])->then (sub { # requires Promise
      $controller->{started} = 1;
      WritableStreamDefaultController::_advance_queue_if_needed
          $stream; #$controller;
    }, sub {
      $controller->{started} = 1;
      WritableStream::_deal_with_rejection $stream, $_[0];
    });
  
    return $controller_obj;
  } # new
  
  sub error ($$) {
    my $stream = ${$_[0]}; #$_[0]->{controlled_writable_stream};
    return undef unless $stream->{state} eq 'writable';
  
    ## WritableStreamDefaultControllerError
    WritableStream::_start_erroring $stream, $_[1];
  
    return undef;
  } # error(e)
  
  sub _abort_steps ($$) {
    my $controller = ${$_[0]}->{writable_stream_controller};
  
    return _hashref_method ($controller->{underlying_sink}, 'abort', [$_[1]]);
  } # [[AbortSteps]]
  
  sub _error_steps ($) {
    my $controller = ${$_[0]}->{writable_stream_controller};
  
    ## ResetQueue
    $controller->{queue} = [];
    $controller->{queue_total_size} = 0;
  } # [[ErrorSteps]]
  
  #sub DESTROY ($) {
  #  local $@;
  #  eval { die };
  #  if ($@ =~ /during global destruction/) {
  #    warn "$$: Reference to @{[ref $_[0]]} is not discarded before global destruction\n";
  #  }
  #} # DESTROY
  
  package WritableStreamDefaultWriter;
  use Streams::_Common;
  push our @CARP_NOT, qw(WritableStream);
  
  sub new ($$) {
    my $stream = $_[1];
    die _type_error "The argument is not a WritableStream"
        unless UNIVERSAL::isa ($stream, 'WritableStream'); # IsWritableStream
    die _type_error "WritableStream is locked"
        if defined $stream->{writer}; # IsWritableStreamLocked
    my $writer = {};
    my $self = bless \$stream, $_[0];
    #$writer->{owner_writable_stream} = $stream;
    $stream->{writer} = $writer;
    $writer->{ready_promise} = _promise_capability;
    $writer->{closed_promise} = _promise_capability;
    if ($stream->{state} eq 'writable') {
      if (
        not
        ## WritableStreamCloseQueuedOrInFlight
        (defined $stream->{close_request} or
         defined $stream->{in_flight_close_request}) and
        $stream->{backpressure}
      ) {
        #
      } else {
        $writer->{ready_promise}->{resolve}->(undef);
      }
    } elsif ($stream->{state} eq 'erroring') {
      $writer->{ready_promise}->{reject}->($stream->{stored_error});
      $writer->{ready_promise}->{promise}->manakai_set_handled;
    } elsif ($stream->{state} eq 'closed') {
      $writer->{ready_promise}->{resolve}->(undef);
      $writer->{closed_promise}->{resolve}->(undef);
    } else {
      my $stored_error = $stream->{stored_error};
      $writer->{ready_promise}->{reject}->($stream->{stored_error});
      $writer->{ready_promise}->{promise}->manakai_set_handled;
      $writer->{closed_promise}->{reject}->($stream->{stored_error});
      $writer->{closed_promise}->{promise}->manakai_set_handled;
    }
    return $self;
  } # new
  
  sub closed ($) {
    return ${$_[0]}->{writer}->{closed_promise}->{promise};
  } # closed
  
  sub desired_size ($) {
    my $stream = ${$_[0]}; #${$_[0]}->{writer}->{owner_writable_stream};
    die _type_error "Writer's lock is released" unless defined $stream->{state};
  
    ## WritableStreamDefaultWriterGetDesiredSize
    {
      if ($stream->{state} eq 'errored' or
          $stream->{state} eq 'erroring') {
        return undef;
      } elsif ($stream->{state} eq 'closed') {
        return 0;
      }
  
      ## WritableStreamDefaultControllerGetDesiredSize
      return $stream->{writable_stream_controller}->{strategy_hwm}
           - $stream->{writable_stream_controller}->{queue_total_size};
    }
  } # desired_size
  
  sub ready ($) {
    return ${$_[0]}->{writer}->{ready_promise}->{promise};
  } # ready
  
  sub abort ($$) {
    my $writer = ${$_[0]}->{writer};
    return Promise->reject (_type_error "Writer's lock is released")
        unless defined ${$_[0]}->{state}; #$writer->{owner_writable_stream};
  
    ## WritableStreamDefaultWriterAbort
    return WritableStream::_abort ${$_[0]}, $_[1];
    #return WritableStream::_abort $writer->{owner_writable_stream}, $_[1];
  } # abort
  
  sub close ($) {
    my $writer = ${$_[0]}->{writer};
    my $stream = ${$_[0]}; #$writer->{owner_writable_stream};
    return Promise->reject (_type_error "Writer's lock is released")
        unless defined $stream->{state};
    return Promise->reject (_type_error "WritableStream is closed")
        if
        ## WritableStreamCloseQueuedOrInFlight
        (defined $stream->{close_request} or
         defined $stream->{in_flight_close_request});
  
    ## WritableStreamDefaultWriterClose
    {
      return Promise->reject (_type_error "WritableStream is closed")
          if $stream->{state} eq 'closed' or $stream->{state} eq 'errored';
      my $p = $stream->{close_request} = _promise_capability;
      if ($stream->{backpressure} and $stream->{state} eq 'writable') {
        $writer->{ready_promise}->{resolve}->(undef);
      }
  
      ## WritableStreamDefaultControllerClose
      {
        ## EnqueueValueWithSize
        #my $size = _to_size 0, 'Size';
        push @{$stream->{writable_stream_controller}->{queue}},
            {value => 'close', size => 0};
        #$stream->{writable_stream_controller}->{queue_total_size} += $size;
  
        WritableStreamDefaultController::_advance_queue_if_needed
            $stream; #$stream->{writable_stream_controller};
      }
  
      return $p->{promise};
    }
  } # close
  
  sub release_lock ($) {
    my $writer = ${$_[0]}->{writer};
    return undef unless defined ${$_[0]}->{state}; #$writer->{owner_writable_stream};
  
    ## WritableStreamDefaultWriterRelease
    {
      my $released_error = _type_error "Writer's lock is released";
  
      ## WritableStreamDefaultWriterEnsureReadyPromiseRejected
      $writer->{ready_promise} ||= _promise_capability;
      $writer->{ready_promise}->{reject}->($released_error);
      $writer->{ready_promise}->{promise}->manakai_set_handled;
  
      ## WritableStreamDefaultWriterEnsureClosedPromiseRejected
      $writer->{closed_promise} ||= _promise_capability;
      $writer->{closed_promise}->{reject}->($released_error);
      $writer->{closed_promise}->{promise}->manakai_set_handled;
  
      ${$_[0]}->{writer} = undef;
      ${$_[0]} = {writer => $writer};
      #$writer->{owner_writable_stream}->{writer} = undef;
      #$writer->{owner_writable_stream} = undef;
      return undef;
    }
  } # release_lock
  
  sub write ($$) {
    my $writer = ${$_[0]}->{writer};
    return Promise->reject (_type_error "Writer's lock is released")
        unless defined ${$_[0]}->{state}; #$writer->{owner_writable_stream};
  
    ## WritableStreamDefaultWriterWrite
    my $stream = ${$_[0]}; #$writer->{owner_writable_stream};
    my $controller = $stream->{writable_stream_controller};
  
    ## WritableStreamDefaultControllerGetChunkSize
    my $chunk_size = 1;
    if (defined $controller->{strategy_size}) {
      eval { $chunk_size = $controller->{strategy_size}->($_[1]) };
      if ($@) {
        ## WritableStreamDefaultControllerErrorIfNeeded
        if ($stream->{state} eq 'writable') {
          ## WritableStreamDefaultControllerError
          WritableStream::_start_erroring $stream, $@;
        }
      }
    }
  
    return Promise->reject (_type_error "Writer's lock is released")
        unless defined ${$_[0]}->{state} and
               ${$_[0]}->{writer} eq $writer;
    #    unless defined $writer->{owner_writable_stream} and
    #           $stream eq $writer->{owner_writable_stream};
  
    my $state = $stream->{state};
    return Promise->reject ($stream->{stored_error}) if $state eq 'errored';
    return Promise->reject (_type_error "WritableStream is closed")
        if
        ## WritableStreamCloseQueuedOrInFlight
        (defined $stream->{close_request} or
         defined $stream->{in_flight_close_request}) or
        $state eq 'closed';
    return Promise->reject ($stream->{stored_error}) if $state eq 'erroring';
  
    ## WritableStreamAddWriteRequest
    my $pc = _promise_capability;
    push @{$stream->{write_requests}}, $pc;
  
    ## WritableStreamDefaultControllerWrite
    {
      ## EnqueueValueWithSize
      my $size = eval { _to_size $chunk_size, 'Size' };
      if ($@) {
        ## WritableStreamDefaultControllerErrorIfNeeded
        if ($stream->{state} eq 'writable') {
          ## WritableStreamDefaultControllerError
          WritableStream::_start_erroring $stream, $@;
        }
        last;
      }
      push @{$controller->{queue}}, {value => {chunk => $_[1]}, size => $size};
      $controller->{queue_total_size} += $size;
  
      if (
        not
          ## WritableStreamCloseQueuedOrInFlight
          (defined $stream->{close_request} or
           defined $stream->{in_flight_close_request}) and
        $stream->{state} eq 'writable'
      ) {
        $stream->_update_backpressure ($controller);
      }
      WritableStreamDefaultController::_advance_queue_if_needed
          $stream; #$controller;
    }
  
    return $pc->{promise};
  } # write(chunk)
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    if ($@ =~ /during global destruction/) {
      warn "$$: Reference to @{[ref $_[0]]} is not discarded before global destruction\n";
    }
  } # DESTROY
  
  1;
  
  =head1 LICENSE
  
  Copyright 2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WRITABLESTREAM

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;

use Main;

my $result = Main->main (@ARGV)->to_cv->recv; # or die
exit $result->{result}->{exit_code};

=head1 NAME

tesica

=head1 SYNOPSIS

  $ tesica

=head1 TESTING

The B<base directory> is the current directory.

A B<test script> is a file containing a set of tests.  The files whose
name ends by C<.t> contained directly or indirectly, without following
symlinks, in the C<t> directory under the base directory are the test
scripts to be used.

=head1 RESULT FILE

The result is written to the C<local/test/result.json>, which is a
JSON file of a JSON object with following name/value pairs:

=over 4

=item rule

A JSON object with following name/value pairs:

=over 4

=item base_dir : String

The absolute path of the base directory.

=back

=item executors : Object<String, Object>

An Object whose names are the executor types and values are
corresponding properties of them, with following name/value pair:

=over 4

=item perl_command : Array<String>?

The command of Perl, if the executor type is C<perl>.

If there is an executable file C<perl> in the base directory, it is
used.  Otherwise, C<perl> in the platform's path is used.

=back

=item files : Array<File>

An Array of the files of the test scripts.

=item file_results : Object<Path, Object>

An Object whose names are the paths of the test scripts and values are
corresponding results, with following name/value pairs:

=over 4

=item executor : Executor?

The description of the test executor used for the file, if any.

=item times : Times

The timestamps of the process of the test script.

=item result : Result

The result of the process of the test script, referred to as "file
result".

=back

=item result : Result

The result of the entire test, referred to as "global result".

=back

=head2 Data types

The data types used to describe result file content are as follows:

=over 4

=item Array<I<T>>

A JSON array whose members are of I<T>.

=item Boolean

A boolean value.  False is represented by one of: a JSON number 0, an
empty String, a JSON false value, a JSON null value, or omission of
the name/value pair if the context is the value of a name/value pair
of an Object.  True is represented by a non-false value.

=item Executor

An Object representing an executor, with following name/value pair:

=over 4

=item type : String

The executor type.  A String C<perl> for now.

=back

=item File

An Object representing a file, with following name/value pair:

=over 4

=item file_name_path : Path

The path to the file.

=back

=item Integer

A JSON number representing an integer value.

=item Object

A JSON object.

=item Object<I<T>, I<U>>

A JSON object whose names are of I<T> and values are of I<U>.

=item Path

A String representing a Unix-style file or directory path, which can
be resolved relative to the |rule|'s |base_dir|.

=item String

A JSON string or a number representing its string value.

=item Times

An Object representing timestamps related to a process, with following
name/value pairs:

=over 4

=item end : Timestamp

The end time of the process.

=item start : Timestamp

The start time of the process.

=back

=item Timestamp

A JSON number representing a Unix time.

=item Result

An Object representing a result of the process, with following
name/value pairs:

=over 4

=item exit_code : Integer?

The exit code of the process, if a process is executed.  The exit code
of the Unix process, if the process is a Unix process.  E.g. zero if
there is no problem detected.

=item fail : Integer?

The number of the failed tests within the process, if known.

=item json_file : Path (global result only)

The path to the result JSON file.

=item ok : Boolean

Whether the process is success or not.

=item output_file : Path (file result only)

The path to the output file, which contains standard output and
standard error output of the test script.

The output file is stored under the C<local/test/files> directory
within the base directory.

An output file is a sequence of one or more data chunks.  A chunk is a
chunk header followed by a chunk body.  A chunk header is a sequence
of the followings:

  0x0A byte;
  ASCII "&" byte;
  descriptor integer;
  0x20 byte;
  size integer;
  0x20 byte;
  timestamp; and
  0x0A byte.

Where a descriptor integer is C<1> (the standard output) or C<2> (the
standard error output); A size integer is either a non-zero ASCII
digit followed by zero or more ASCII digits, C<0>, or C<-1>; A
timestamp is one or more ASCII digits followed by an ASCII "." byte
followed by one or more ASCII digits.

The timestamp represents the time the chunk was received, in decimal
number of the Unix time.  The timestamp of a chunk is always equal to
or greater than that of any previous chunk.

the size integer represents the number of the bytes in the chunk body,
in decimal integer, when the number is zero or greater, or represents
the end of the file when the number is C<-1>.

A chunk body is the bytes that belongs to the file identified by the
descriptor integer.

=item pass : Integer?

The number of the passed tests within the process, if known.

=back


=back

=head1 AUTHOR

Wakaba <wakaba@suikawiki.org>.

=head1 HISTORY

This Git repository was located at <https://github.com/wakaba/tesica>
until 14 March, 2022.

=head1 LICENSE

Copyright 2018-2022 Wakaba <wakaba@suikawiki.org>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
